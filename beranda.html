<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Risk & Reward Calculator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <!-- Pustaka untuk Excel (xlsx) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- Pustaka untuk PDF (jsPDF & html2canvas) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- BARU: Tambahkan plugin jsPDF-AutoTable untuk membuat tabel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <style>
      /* Custom styles based on user's provided CSS */
      body {
        font-family: "Inter", sans-serif;
        background-color: #fcfcfc;
        color: #333;
        font-size: 0.8125rem;
        padding: 0;
      }
      .container-wrapper {
        background-color: #ffffff;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03);
        border-radius: 12px;
        border: 1px solid #eeeeee;
        padding: 1.5rem;
        margin-top: 6rem; /* Increased margin to accommodate larger header */
        margin-left: auto;
        margin-right: auto;
        width: 100%;
        max-width: 1536px;
      }
      .header-global {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 1rem 1.5rem; /* Adjusted padding for better mobile view */
        background-color: rgba(255, 255, 255, 0.8); /* White and transparent */
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
        z-index: 50;
        color: #333; /* Black text */
      }
      .header-section {
        background-color: rgba(247, 247, 247, 0.8);
        border-bottom: 1px solid #e8e8e8;
        padding: 1.75rem 1.5rem;
        margin-left: -1.5rem;
        margin-right: -1.5rem;
      }
      .text-primary {
        color: #2a2a2a;
      }
      .input-label {
        color: #5a5a5a;
        font-weight: 500;
        font-size: 0.75rem;
      }
      .input-field,
      .select-field {
        border: 1px solid #e0e0e0;
        background-color: #ffffff;
        color: #333;
        border-radius: 6px;
        padding: 0.55rem 0.8rem;
        transition: border-color 0.2s, box-shadow 0.2s;
        font-size: 0.75rem;
      }
      .input-field:focus,
      .select-field:focus {
        border-color: #bbbbbb;
        outline: none;
        box-shadow: 0 0 0 2px rgba(187, 187, 187, 0.2);
      }
      .input-group-percent span {
        background-color: #f0f0f0;
        border: 1px solid #e0e0e0;
        border-left: none;
        border-radius: 0 6px 6px 0;
        color: #5a5a5a;
        padding: 0.55rem 0.8rem;
        font-size: 0.75rem;
      }
      .buy-button,
      .sell-button {
        border: 1px solid #e0e0e0;
        background-color: #f9f9f9;
        color: #5a5a5a;
        border-radius: 6px;
        transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        font-size: 0.75rem;
        padding: 0.55rem 0.8rem;
      }
      .buy-button.active {
        background-color: #eafaea;
        color: #28a745;
        border-color: #c9ecc9;
        font-weight: 600;
      }
      .sell-button.active {
        background-color: #faeaea;
        color: #dc3545;
        border-color: #ecc9c9;
        font-weight: 600;
      }

      /* --- Perubahan untuk Tombol Aksi (Add, Calculate) --- */
      .action-button {
        background-color: #222222;
        color: #ffffff;
        border: 1px solid #111111;
        border-radius: 6px;
        font-weight: 600;
        padding: 0.6rem 1.1rem;
        transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        font-size: 0.8125rem;
      }
      .action-button:hover {
        background-color: #3a3a3a;
        border-color: #222222;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      }
      .action-button:active {
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      /* --- End Perubahan Tombol Aksi --- */

      /* New style for the "Tambah Foto" button */
      .light-action-button {
        background-color: #e0e0e0;
        color: #222222;
        border: 1px solid #cccccc;
        border-radius: 6px;
        font-weight: 300;
        padding: 0.4rem 0.8rem;
        font-size: 0.75rem;
        transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
        box-shadow: 0 1px 3px (0, 0, 0, 0.08);
      }
      .light-action-button:hover {
        background-color: #d0d0d0;
        border-color: #bbbbbb;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .light-action-button:active {
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.05);
      }

      /* New style for the "Hapus Data" button */
      .delete-data-button {
        background-color: transparent;
        color: #dc3545;
        border: none;
        font-weight: 300;
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        cursor: pointer;
        transition: color 0.2s;
      }
      .delete-data-button:hover {
        color: #c82333;
      }

      /* New style for the "Unggah Data" and "Unduh Excel" buttons */
      .upload-data-button {
        background-color: #e0e0e0;
        color: #222222;
        border: 1px solid #cccccc;
        border-radius: 6px;
        font-weight: 300;
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
      }
      .upload-data-button:hover {
        background-color: #d0d0d0;
        border-color: #bbbbbb;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .upload-data-button:active {
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.05);
      }

      .delete-row-btn {
        color: #999;
        transition: color 0.2s;
      }
      .delete-row-btn:hover {
        color: #f44336;
      }
      .results-table {
        border-collapse: collapse;
        width: 100%;
      }
      .results-table th,
      .results-table td {
        padding: 6px 8px;
        text-align: center;
        border-bottom: 1px solid #f2f2f2;
        font-size: 0.6rem;
        font-weight: 300;
        white-space: nowrap;
      }
      .results-table th {
        background-color: #e0e0e0;
        color: #333;
        font-weight: 300;
        text-transform: uppercase;
        font-size: 0.6rem;
        text-align: center;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .results-table td:nth-child(1),
      .results-table td:nth-child(2) {
        text-align: left;
      }
      .results-table th:nth-child(1),
      .results-table th:nth-child(2) {
        text-align: left;
      }
      .results-table td:nth-child(14) {
        text-align: center;
        font-weight: 300;
        color: #222;
        font-size: 0.6rem;
      }
      .results-table tbody tr:last-child td {
        border-bottom: none;
      }
      .results-table tbody tr:hover {
        background-color: #fdfdfd;
      }
      .positive-value {
        color: #28a745;
        font-weight: 500;
      }
      .negative-value {
        color: #dc3545;
        font-weight: 500;
      }
      .neutral-value {
        color: #333;
      }
      .detail-section {
        background-color: #ffffff;
        border: 1px solid #e0e0e0;
        border-radius: 10px;
        padding: 1.2rem;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        font-size: 0.75rem;
      }
      .detail-section.active {
        opacity: 1;
        transform: translateY(0);
      }
      .detail-label {
        font-weight: 600;
        color: #2a2a2a;
        margin-right: 0.5rem;
      }
      .detail-value {
        color: #555;
      }
      .error-message {
        background-color: #fdeaea;
        color: #dc3545;
        border: 1px solid #f5c6cb;
        border-radius: 6px;
        padding: 8px;
        font-size: 0.75rem;
        margin-top: 1rem;
      }
      /* Custom scrollbar for input rows container */
      #inputRowsContainer {
        max-height: 400px;
        overflow-y: auto;
        padding-right: 8px;
        margin-bottom: 1.5rem;
      }
      #inputRowsContainer::-webkit-scrollbar {
        width: 8px;
      }
      #inputRowsContainer::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 10px;
      }
      #inputRowsContainer::-webkit-scrollbar-thumb {
        background: #d0d0d0;
        border-radius: 10px;
      }
      #inputRowsContainer::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }
      /* Styles for the table cell containing action buttons in active plans */
      .action-buttons-cell {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.4rem;
      }
      /* Styles for the new action buttons in active plans */
      .action-button-small {
        background-color: #222222;
        color: white;
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        font-weight: 500;
        font-size: 0.6rem;
        transition: background-color 0.2s, opacity 0.2s;
        white-space: nowrap;
        border: 1px solid #111111;
      }
      .action-button-small:hover {
        opacity: 0.8;
      }

      /* Specific font size for main titles */
      h1.text-3xl {
        font-size: 1.25rem;
        font-weight: 200;
      }
      /* Adjusted font size for h2 titles in statistics sections */
      h2.text-lg {
        font-size: 0.8rem;
        font-weight: 300;
      }
      /* New style for modal title */
      #photoUploadModal h3 {
        font-size: 0.9rem;
        font-weight: 600;
        color: #2a2a2a;
      }
      p.text-sm {
        font-size: 0.7rem;
        font-weight: 200;
      }

      /* Responsive adjustments for smaller screens */
      @media (max-width: 768px) {
        .container-wrapper {
          padding: 1rem;
          margin-top: 5rem;
        }
        .header-global {
          padding: 1rem 1.5rem;
        }
        .header-global span,
        .header-global a {
          font-size: 0.75rem;
        }
        #currentDateHeader,
        #currentTimeHeader,
        #mobileMenuDateTime {
          font-size: 0.65rem;
        }
        .header-section {
          padding: 1.5rem 1rem;
          margin-left: -1rem;
          margin-right: -1rem;
        }
        h1.text-3xl {
          font-size: 1.1rem;
        }
        h2.text-lg {
          font-size: 0.8rem;
        }
        .input-row {
          padding: 1rem;
        }
        .input-label,
        .input-field,
        .select-field,
        .input-group-percent span,
        .buy-button,
        .sell-button,
        .action-button,
        .results-table th,
        .results-table td {
          font-size: 0.75rem;
        }
        .action-button {
          padding: 0.5rem 0.8rem;
        }
        .action-button-small {
          padding: 0.2rem 0.4rem;
          font-size: 0.6rem;
        }
        .grid-cols-1.sm:grid-cols-2.md:grid-cols-3.lg:grid-cols-6 {
          grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
        .top-left-photo-section {
          flex-direction: column;
          align-items: center;
          gap: 0.5rem;
          padding-left: 0;
          padding-top: 0;
        }
        #executedTradingPlansSection > div.flex {
          flex-direction: column;
          align-items: flex-start;
          gap: 0.75rem;
        }
        #executedTradingPlansSection > div.flex > h2 {
          margin-bottom: 0;
        }
        #executedTradingPlansSection > div.flex > div.flex {
          flex-direction: row;
          width: 100%;
          justify-content: flex-start;
        }
        .photo-gallery-container {
          width: 100%;
          max-width: none;
        }
        .photo-carousel {
          width: 100%;
          height: auto;
          aspect-ratio: 1 / 1;
        }
        .photo-slides img {
          width: 100%;
          height: 100%;
          object-fit: cover;
        }
        #dailyLineChartContainer,
        #monthlyBarChartContainer,
        #overallPercentageCumulativeChartContainer,
        #overallBalanceCumulativeChartContainer,
        #overallPipsCumulativeChartContainer,
        #tradeFrequencyChartContainer {
          padding: 1rem;
          min-height: 220px;
        }
        #pieChartContainer {
          padding: 1rem;
          min-height: 280px;
        }

        /* --- GANTI SELURUH BLOK INI --- */
        /* --- PERBAIKAN POP UP DIMULAI DI SINI --- */
        .modal-content {
          padding: 1rem; /* Padding atas, bawah, kiri, kanan diperkecil */
          width: 95%;
          max-width: 380px; /* Batas lebar maks agar tidak terlalu lebar di mode landscape HP */
        }

        /* Perkecil judul & jaraknya */
        .modal-content h3 {
          font-size: 0.9rem; /* Ukuran font judul diperkecil */
          margin-bottom: 0.75rem; /* Jarak bawah judul dikurangi */
        }

        .modal-body-scrollable {
          max-height: 55vh; /* Tinggi maksimal area scroll dikurangi */
          overflow-y: auto;
          padding-right: 0.5rem;
          margin-right: -0.5rem;
          margin-bottom: 1rem; /* Jarak bawah konten sebelum tombol dikurangi */
        }
        .modal-body-scrollable::-webkit-scrollbar {
          width: 6px;
        }
        .modal-body-scrollable::-webkit-scrollbar-track {
          background: #f0f0f0;
          border-radius: 10px;
        }
        .modal-body-scrollable::-webkit-scrollbar-thumb {
          background: #c0c0c0;
          border-radius: 10px;
        }
        .modal-body-scrollable::-webkit-scrollbar-thumb:hover {
          background: #a0a0a0;
        }
        /* --- AKHIR DARI PERBAIKAN POP UP --- */
        /* --- HINGGA DI SINI --- */
      }

      @media (min-width: 769px) {
        .header-global {
          padding: 2rem 2.5rem;
        }
      }

      /* Ensure tables are horizontally scrollable on small screens */
      .overflow-x-auto {
        overflow-x: auto;
      }
      /* Styles for download buttons */
      .download-buttons {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
        justify-content: flex-end;
        display: none;
      }
      .download-button {
        background-color: #222222;
        color: #ffffff;
        padding: 0.4rem 0.8rem;
        border-radius: 6px;
        font-weight: 500;
        font-size: 0.75rem;
        cursor: pointer;
        border: none;
      }
      .download-button.pdf {
        background-color: #222222;
      }
      .download-button:hover {
        opacity: 0.9;
      }
      .download-button:active {
        transform: translateY(0);
      }

      /* Styles for photo gallery container */
      .photo-gallery-container {
        position: relative;
        display: block;
        width: 100%;
        max-width: 400px;
        margin: 0 auto;
      }
      .photo-carousel {
        width: 100%;
        aspect-ratio: 1 / 1;
        height: auto;
        border-radius: 8px;
        border: 1px solid #cccccc;
        object-fit: cover;
        margin: 0 auto;
        cursor: pointer;
        overflow: hidden;
      }
      .photo-slides {
        display: flex;
        transition: transform 0.3s ease-in-out;
        height: 100%;
      }
      .photo-slides img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        flex-shrink: 0;
      }

      /* New styles for the top-left photo and button container */
      .top-left-photo-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 1.5rem;
      }

      @media (min-width: 769px) {
        .top-left-photo-section {
          flex-direction: row;
          justify-content: center;
        }
        .photo-gallery-container {
          max-width: 400px;
        }
        #executedTradingPlansSection > div.flex {
          flex-direction: row;
          justify-content: space-between;
        }
        #executedTradingPlansPlansSection > div.flex > div.flex {
          width: auto;
        }
      }

      /* Added style for executed plans table container to enable vertical scrolling */
      #executedPlansTableContainer {
        max-height: 300px;
        overflow-y: auto;
        border-radius: 0.5rem;
        border: 1px solid #e0e0e0;
      }
      #executedPlansTableContainer::-webkit-scrollbar {
        width: 8px;
      }
      #executedPlansTableContainer::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 10px;
      }
      #executedPlansTableContainer::-webkit-scrollbar-thumb {
        background: #d0d0d0;
        border-radius: 10px;
      }
      #executedPlansTableContainer::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }

      /* --- PERBAIKAN: Style baru untuk kontainer tabel ringkasan dengan scroll vertikal --- */
      .summary-table-container {
        border-radius: 0.5rem;
        border: 1px solid #e0e0e0;
      }
      .summary-table-container::-webkit-scrollbar {
        width: 8px;
      }
      .summary-table-container::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 10px;
      }
      .summary-table-container::-webkit-scrollbar-thumb {
        background: #d0d0d0;
        border-radius: 10px;
      }
      .summary-table-container::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }
      /* --- AKHIR PERBAIKAN --- */

      /* --- Animasi Scroll (Fade-in-up) --- */
      .scroll-animate-section {
        opacity: 0;
        transform: translateY(50px);
        transition: opacity 0.6s ease-out, transform 0.6s ease-out;
      }
      .scroll-animate-section.scrolled-into-view {
        opacity: 1;
        transform: translateY(0);
      }

      /* Adjusted Pie Chart Container for a balanced size */
      #pieChartContainer {
        min-height: 220px;
        max-width: 350px;
        margin: 0 auto;
      }

      /* Ensure canvas itself is responsive within its container */
      #assetSuccessPieChart {
        width: 100% !important;
        height: auto !important;
      }

      /* Styling for the new informational text section */
      .info-section {
        background-color: #ffffff;
        border: 1px solid #e0e0e0;
        border-radius: 12px;
        padding: 2rem;
        margin-top: 2rem;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03);
      }
      .info-section h2 {
        font-size: 1.25rem;
        font-weight: 500;
        color: #2a2a2a;
        margin-bottom: 1rem;
        border-bottom: 1px solid #e8e8e8;
        padding-bottom: 0.5rem;
      }
      .info-section h3 {
        font-size: 1rem;
        font-weight: 600;
        color: #333;
        margin-top: 1.5rem;
        margin-bottom: 0.75rem;
      }
      .info-section p {
        font-size: 0.875rem;
        font-weight: 300;
        color: #555;
        line-height: 1.6;
        margin-bottom: 1rem;
      }
      .info-section ul {
        list-style-type: disc;
        margin-left: 1.5rem;
        margin-bottom: 1rem;
      }
      .info-section ul li {
        font-size: 0.875rem;
        font-weight: 300;
        color: #555;
        margin-bottom: 0.5rem;
      }
      .info-section strong {
        font-weight: 500;
        color: #333;
      }
      .info-section .list-circle {
        list-style-type: circle;
      }

      /* PERBAIKAN: Aturan warna yang disederhanakan dan konsisten */
      .positive-value {
        color: #2a2a2a; /* Warna hitam untuk nilai positif */
      }
      .negative-value {
        color: #dc3545; /* Warna merah untuk nilai negatif */
      }

      #overallSummaryStatisticsSection p.text-base,
      #riskRewardStatisticsSection p.text-base,
      #riskRewardStatisticsSection p.text-lg {
        font-weight: 300; /* Atur font-weight saja, warna akan diatur oleh JS */
      }

      /* Modal specific styles */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }
      .modal.show {
        opacity: 1;
        visibility: visible;
      }
      .modal-content {
        background-color: #ffffff;
        padding: 2rem;
        border-radius: 12px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 500px;
        position: relative;
        transform: translateY(-20px);
        transition: transform 0.3s ease;
      }
      .modal.show .modal-content {
        transform: translateY(0);
      }
      .modal-close-button {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #999;
      }
      .modal-close-button:hover {
        color: #333;
      }

      #photoUploadModal .flex.justify-center.items-center {
        width: 100%;
        max-width: 400px;
        aspect-ratio: 1 / 1;
        margin: 1rem auto;
      }
      #imageCanvas {
        width: 100%;
        height: 100%;
        display: block;
        border-radius: 8px;
      }

      /* --- NEW: Styles for Monthly Summary Table --- */
      .monthly-summary-table th,
      .monthly-summary-table td {
        font-size: 0.55rem;
        padding: 4px 6px;
      }
      .monthly-summary-table th {
        font-weight: 400;
        text-align: center;
      }
      .info-section .list-circle {
        list-style-type: circle;
      }

      /* --- LETAKKAN KODE BARU DI SINI --- */
      .aspect-16-4 {
        aspect-ratio: 16 / 4;
      }
      .sharp-corners {
        border-radius: 0;
      }

      /* --- PERBAIKAN: Menghilangkan Bingkai di Semua Kontainer Grafik --- */
      #dailyLineChartContainer,
        #monthlyBarChartContainer,
        #overallPercentageCumulativeChartContainer,
        #overallBalanceCumulativeChartContainer,
        #overallPipsCumulativeChartContainer,
        #combinedSummaryBarChartContainer,
        #balanceFrequencyChartContainer,
        #percentageFrequencyChartContainer,
        #pipsFrequencyChartContainer,
        #executionFrequencyChartContainer,
        #assetExecutionCountChartContainer,
        #tradeFrequencyChartContainer,
        #pieChartContainer,
        /* Selector ini menargetkan div pembungkus grafik di bagian "Statistik Persentase Kumulatif Keseluruhan" */
        #overallPercentageCumulativeStatisticsSection > .bg-white {
        border: none !important; /* Menghapus garis bingkai */
        box-shadow: none !important; /* Menghapus bayangan (shadow) */
      }
      /* --- AKHIR DARI KODE PERBAIKAN --- */

      /* --- LETAKKAN KODE BARU DI SINI (di dalam tag <style>) --- */
      .calendar-date {
        font-size: 0.8rem;
        padding: 0.5rem 0;
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: auto;
      }
      .calendar-date:hover:not(.today) {
        background-color: #f0f0f0;
      }
      .prev-month,
      .next-month {
        color: #b0b0b0;
      }
      .today {
        background-color: #2a2a2a;
        color: #ffffff;
        font-weight: 600;
      }
    </style>
  </head>
  <body class="flex items-center justify-center min-h-screen">
    <!-- Global Header for the entire page (fixed at top) -->
    <div class="header-global">
      <div class="flex items-center gap-5">
        <span class="text-sm font-light">Beranda Utama</span>
      </div>
      <div class="text-center absolute left-1/2 -translate-x-1/2">
        <span id="currentDateHeader" class="text-sm"></span>
        <span id="currentTimeHeader" class="text-sm"></span>
      </div>

      <!-- Desktop Navigation -->
      <nav class="hidden md:flex items-center gap-5">
        <a href="index.html" class="text-sm font-light hover:underline">Home</a>
        <a href="about_new.html" class="text-sm font-light hover:underline"
          >About</a
        >
        <a href="services.html" class="text-sm font-light hover:underline"
          >Services</a
        >
        <a href="contact.html" class="text-sm font-light hover:underline"
          >Contact</a
        >
        <a href="investasi.html" class="text-sm font-light hover:underline"
          >Investasi</a
        >
        <a href="backtest.html" class="text-sm font-light hover:underline"
          >Backtest</a
        >
        <a href="Testing.html" class="text-sm font-light hover:underline"
          >Testing</a
        >
      </nav>

      <!-- Hamburger Menu Button for Mobile -->
      <div class="md:hidden">
        <button id="hamburgerBtn" class="focus:outline-none">
          <svg
            class="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 6h16M4 12h16m-7 6h7"
            ></path>
          </svg>
        </button>
      </div>
    </div>

    <!-- Mobile Menu (Initially Hidden) -->
    <div
      id="mobileMenu"
      class="hidden fixed inset-0 bg-white z-50 p-6 transition-transform duration-300 ease-in-out"
    >
      <div class="flex justify-between items-center mb-8">
        <span class="text-lg font-semibold">Menu</span>
        <button id="closeMenuBtn" class="focus:outline-none">
          <svg
            class="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18L18 6M6 6l12 12"
            ></path>
          </svg>
        </button>
      </div>
      <div class="text-center text-gray-600 mb-8">
        <div id="mobileMenuDateTime"></div>
      </div>
      <nav class="flex flex-col items-center space-y-4">
        <a href="index.html" class="text-lg text-gray-700 hover:text-blue-600"
          >Home</a
        >
        <a
          href="about_new.html"
          class="text-lg text-gray-700 hover:text-blue-600"
          >About</a
        >
        <a
          href="services.html"
          class="text-lg text-gray-700 hover:text-blue-600"
          >Services</a
        >
        <a href="contact.html" class="text-lg text-gray-700 hover:text-blue-600"
          >Contact</a
        >
        <a
          href="investasi.html"
          class="text-lg text-gray-700 hover:text-blue-600"
          >Investasi</a
        >
        <a
          href="backtest.html"
          class="text-lg text-gray-700 hover:text-blue-600"
          >Backtest</a
        >
        <a href="Testing.html" class="text-lg text-gray-700 hover:text-blue-600"
          >Testing</a
        >
      </nav>
    </div>

    <div class="container-wrapper rounded-xl shadow-lg">
      <!-- Manually controlled photo gallery -->
      <!-- ▼▼▼ GANTI SELURUH BLOK INI ▼▼▼ -->

      <!-- Manually controlled photo gallery -->
      <section class="top-left-photo-section scroll-animate-section">
        <!-- PERBAIKAN: Bungkus banner dengan <label> untuk fungsionalitas unggah & tahan di HP -->
        <label
          for="imageInput16x4"
          class="relative block w-full mb-4 cursor-pointer"
        >
          <div
            id="bannerContainer"
            class="overflow-hidden sharp-corners border border-gray-200 pointer-events-none"
          >
            <div
              class="aspect-16-4 w-full bg-gray-100 flex items-center justify-center"
            >
              <div id="bannerSlides" class="photo-slides flex h-full w-full">
                <!-- Gambar banner akan dimuat di sini oleh JavaScript -->
              </div>
              <div
                id="bannerCounter"
                class="absolute bottom-2 left-1/2 -translate-x-1/2 bg-black bg-opacity-50 text-white text-xs px-2 py-1 rounded-full hidden"
              ></div>
            </div>
          </div>
        </label>
        <!-- Input file tersembunyi khusus untuk banner -->
        <input
          type="file"
          id="imageInput16x4"
          accept="image/*"
          class="hidden"
        />

        <!-- Galeri Foto 1:1 (Struktur ini sudah benar) -->
        <label
          for="imageInput"
          class="photo-gallery-container relative w-full max-w-sm mx-auto cursor-pointer"
        >
          <div
            id="photoCarousel"
            class="photo-carousel relative bg-gray-100 flex items-center justify-center pointer-events-none"
          >
            <div id="photoSlides" class="photo-slides flex">
              <!-- Manual images will be dynamically loaded here -->
            </div>
            <button
              id="prevPhotoBtn"
              class="absolute left-2 top-1/2 -translate-y-1/2 bg-black bg-opacity-50 text-white p-2 rounded-full hidden z-10 pointer-events-auto"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-5 w-5"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M15 19l-7-7 7-7"
                />
              </svg>
            </button>
            <button
              id="nextPhotoBtn"
              class="absolute right-2 top-1/2 -translate-y-1/2 bg-black bg-opacity-50 text-white p-2 rounded-full hidden z-10 pointer-events-auto"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-5 w-5"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M9 5l7 7-7 7"
                />
              </svg>
            </button>
            <div
              id="photoCounter"
              class="absolute bottom-2 left-1/2 -translate-x-1/2 bg-black bg-opacity-50 text-white text-xs px-2 py-1 rounded-full hidden"
            ></div>
          </div>
        </label>
      </section>

      <!-- ▲▲▲ HINGGA DI SINI ▲▲▲ -->

      <header
        class="header-section text-center mb-8 rounded-t-xl scroll-animate-section"
      >
        <h1 class="text-3xl font-extralight text-primary mb-2">
          Risk & Reward Calculator
        </h1>
        <p class="text-gray-600 text-sm font-extralight">
          <span id="currentDate"></span>, <span id="currentTime"></span>
        </p>
      </header>

      <section id="calculatorInputs" class="mb-8 scroll-animate-section">
        <div id="inputRowsContainer" class="space-y-6">
          <!-- Input rows will be dynamically added here -->
        </div>

        <div class="flex flex-col sm:flex-row gap-4 mt-6">
          <button id="addInputRowBtn" class="w-full sm:flex-1 action-button">
            Tambah Baris Input
          </button>
          <button id="calculateAllBtn" class="w-full sm:flex-1 action-button">
            Hitung Semua
          </button>
        </div>
      </section>

      <!-- New section for Calculated/New Trading Plans -->
      <section id="newTradingPlansSection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Rencana Trading Baru
        </h2>
        <div class="overflow-x-auto rounded-lg border border-gray-200">
          <table class="results-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Aset</th>
                <th>Trade</th>
                <th>Balance Akun</th>
                <th>Waktu Masuk</th>
                <th>Price Now</th>
                <th>Open Price</th>
                <th>SL Price</th>
                <th>TP Price</th>
                <th>Pending Pips/Points</th>
                <th>SL Pips/Points</th>
                <th>TP Pips/Points</th>
                <th>R:R Pips</th>
                <th>R:R %</th>
                <th>Lot/Units</th>
                <th>Nett SL</th>
                <th>Nett TP</th>
                <th>Catatan</th>
                <th>Hasil</th>
                <th class="rounded-tr-lg"></th>
              </tr>
            </thead>
            <tbody id="calculatedPlansBody">
              <tr>
                <td colspan="18" class="py-4 text-center text-gray-500">
                  Belum ada rencana trading baru.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- Existing section, renamed to Rencana Trading Aktif -->
      <section
        id="runningTradingPlansSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-extralight text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Rencana Trading Aktif
        </h2>
        <div class="overflow-x-auto rounded-lg border border-gray-200">
          <table class="results-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Aset</th>
                <th>Trade</th>
                <th>Balance Akun</th>
                <th>Waktu Masuk</th>
                <th>Price Now</th>
                <th>Open Price</th>
                <th>SL Price</th>
                <th>TP Price</th>
                <th>Pending Pips/Points</th>
                <th>SL Pips/Points</th>
                <th>TP Pips/Points</th>
                <th>R:R Pips</th>
                <th>R:R %</th>
                <th>Lot/Units</th>
                <th>Nett SL</th>
                <th>Nett TP</th>
                <th>Catatan</th>
                <th>Hasil</th>
                <th class="rounded-tr-lg"></th>
              </tr>
            </thead>
            <tbody id="runningPlansBody">
              <tr>
                <td colspan="18" class="py-4 text-center text-gray-500">
                  Belum ada rencana trading aktif.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- PERBAIKAN: Grid responsif untuk ringkasan rencana aktif -->
        <div
          id="activePlansSummary"
          class="hidden mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg grid grid-cols-1 sm:grid-cols-3 md:grid-cols-5 gap-4 text-center"
        >
          <div>
            <p class="text-xs font-medium text-gray-500 uppercase">
              Total SL Pips
            </p>
            <p
              id="summaryTotalSlPips"
              class="text-sm font-semibold mt-1 negative-value"
            >
              0
            </p>
          </div>
          <div>
            <p class="text-xs font-medium text-gray-500 uppercase">
              Total TP Pips
            </p>
            <p
              id="summaryTotalTpPips"
              class="text-sm font-semibold mt-1 positive-value"
            >
              0
            </p>
          </div>
          <div>
            <p class="text-xs font-medium text-gray-500 uppercase">
              Total Risiko %
            </p>
            <p
              id="summaryTotalRiskPercentage"
              class="text-sm font-semibold mt-1 negative-value"
            >
              -0.00%
            </p>
          </div>
          <div>
            <p class="text-xs font-medium text-gray-500 uppercase">
              Total Nett SL
            </p>
            <p
              id="summaryTotalNettSL"
              class="text-sm font-semibold mt-1 negative-value"
            >
              $0.00
            </p>
          </div>
          <div>
            <p class="text-xs font-medium text-gray-500 uppercase">
              Total Nett TP
            </p>
            <p
              id="summaryTotalNettTP"
              class="text-sm font-semibold mt-1 positive-value"
            >
              $0.00
            </p>
          </div>
        </div>
        <div id="calculationDetails" class="mt-6 hidden">
          <!-- Calculation details will be displayed here, but hidden by default now -->
        </div>
      </section>

      <section
        id="executedTradingPlansSection"
        class="mt-8 scroll-animate-section"
      >
        <div
          class="flex flex-col sm:flex-row justify-between items-center mb-4 pb-2 border-b border-gray-200"
        >
          <h2 class="text-lg font-extralight text-primary mb-2 sm:mb-0">
            Rencana Trading Selesai
          </h2>
          <div class="flex gap-3 mt-2 sm:mt-0">
            <!-- NEW: "Unduh Excel" button added here -->
            <button id="downloadExecutedExcelBtn" class="upload-data-button">
              Unduh Excel
            </button>
            <button id="uploadDataBtn" class="upload-data-button">
              Unggah Data
            </button>
            <button id="deleteAndExportDataBtn" class="delete-data-button">
              Hapus Data
            </button>
          </div>
        </div>

        <!-- ▼▼▼ GANTI BLOK DIV DI BAWAH INI ▼▼▼ -->
        <!-- PERBAIKAN: Pisahkan container scroll vertikal dan horizontal -->
        <div id="executedPlansTableContainer">
          <!-- Container ini HANYA untuk scroll vertikal (max-height) -->
          <div class="overflow-x-auto">
            <!-- Container ini HANYA untuk scroll horizontal -->
            <table class="results-table" id="executedPlansTable">
              <thead>
                <tr>
                  <th class="rounded-tl-lg">Aset</th>
                  <th>Trade</th>
                  <th>Balance Akun</th>
                  <th>Waktu Masuk</th>
                  <th>Price Now</th>
                  <th>Open Price</th>
                  <th>SL Price</th>
                  <th>TP Price</th>
                  <th>Pending Pips/Points</th>
                  <th>SL Pips/Points</th>
                  <th>TP Pips/Points</th>
                  <th>R:R Pips</th>
                  <th>R:R %</th>
                  <th>Lot/Units</th>
                  <th>Nett SL</th>
                  <th>Nett TP</th>
                  <th>Catatan</th>
                  <th>Hasil</th>
                  <th class="rounded-tr-lg">Waktu Keluar</th>
                </tr>
              </thead>
              <tbody id="executedPlansBody">
                <tr>
                  <td colspan="19" class="py-4 text-center text-gray-500">
                    Belum ada rencana trading yang selesai.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <!-- ▲▲▲ HINGGA DI SINI ▲▲▲ -->
      </section>

      <!-- NEW: Compounding Simulator Section -->
      <section
        id="compoundingSimulatorSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Simulator Compounding
        </h2>
        <div
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-1 md:grid-cols-4 gap-6"
        >
          <div>
            <label for="simBalance" class="block text-sm input-label mb-1"
              >Balance Awal ($)</label
            >
            <input
              type="number"
              id="simBalance"
              placeholder="Cth: 5000"
              class="mt-1 block w-full input-field"
            />
          </div>
          <div>
            <label for="simRiskPerTrade" class="block text-sm input-label mb-1"
              >Risk per Trade (%)</label
            >
            <input
              type="number"
              id="simRiskPerTrade"
              placeholder="Cth: 0.5"
              step="0.01"
              class="mt-1 block w-full input-field"
            />
          </div>
          <div>
            <label for="simMonthlyTarget" class="block text-sm input-label mb-1"
              >Target Bulanan (%)</label
            >
            <input
              type="number"
              id="simMonthlyTarget"
              placeholder="Cth: 5"
              step="0.1"
              class="mt-1 block w-full input-field"
            />
          </div>
          <div>
            <label for="simPeriod" class="block text-sm input-label mb-1"
              >Periode Simulasi (Bulan)</label
            >
            <input
              type="number"
              id="simPeriod"
              placeholder="Cth: 12"
              class="mt-1 block w-full input-field"
            />
          </div>
        </div>
      </section>

      <!-- New section for Overall Summary Statistics -->
      <section
        id="overallSummaryStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Ringkasan Keseluruhan
        </h2>
        <div
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-2 md:grid-cols-6 gap-6 text-center"
        >
          <!-- Baris 1 -->
          <div>
            <p class="text-gray-600 text-sm font-light">Total Trade Selesai</p>
            <p id="totalSettledTradesSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Probabilitas</p>
            <p
              id="probabilitySummary"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Total Pips/Points</p>
            <p id="totalPipsSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Rata-rata % per Trade
            </p>
            <p id="avgPercentagePerTradeSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Persentase Harian</p>
            <p id="dailyPercentageSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Persentase Bulanan</p>
            <p id="monthlyPercentageSummary" class="text-base mt-1">N/A</p>
          </div>
          <!-- Baris 2 -->
          <div>
            <p class="text-gray-600 text-sm font-light">Persentase Tahunan</p>
            <p id="yearlyPercentageSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Persentase Keseluruhan
            </p>
            <p id="overallPercentageSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Saldo Akun Akhir</p>
            <p id="finalBalanceSummary" class="text-base mt-1">N/A</p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Waktu Bergabung</p>
            <p
              id="joinTimeSummary"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Drawdown Saldo</p>
            <p id="balanceDrawdownSummary" class="text-base mt-1">N/A</p>
            <p
              id="balanceDrawdownSummaryPeriod"
              class="text-xs text-gray-500 mt-1"
            >
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Maksimum Drawdown %</p>
            <p id="overallMaxDrawdownPercentage" class="text-base mt-1">N/A</p>
            <p
              id="overallMaxDrawdownPercentagePeriod"
              class="text-xs text-gray-500 mt-1"
            >
              Periode: N/A
            </p>
          </div>
        </div>
      </section>

      <!-- New section for Risk and Reward Statistics -->
      <section
        id="riskRewardStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Risiko dan Imbalan
        </h2>
        <div
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 text-center"
        >
          <div
            class="sm:col-span-2 md:col-span-4 flex flex-col sm:flex-row justify-center items-center p-2 rounded-md bg-gray-100"
          >
            <p class="text-gray-600 text-sm font-light mr-2">
              Rata-rata Risiko dan Imbalan
            </p>
            <p id="avgRiskReward" class="text-lg font-light text-black">
              1 : N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Rata-rata Sinyal Diselesaikan/Minggu
            </p>
            <p
              id="avgSignalSettledWeek"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Rata-rata Sinyal Diselesaikan/Bulan
            </p>
            <p
              id="avgSignalSettledMonth"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Rata-rata Periode Penahanan
            </p>
            <p
              id="avgHoldingPeriod"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Periode Penahanan Maks
            </p>
            <p
              id="maxHoldingPeriod"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Rata-rata Pips</p>
            <p id="averagePips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Rata-rata TP Pips</p>
            <p id="avgTpPips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Max TP Pips</p>
            <p id="maxTpPips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Rata-rata SL Pips</p>
            <p id="avgSlPips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Max SL Pips</p>
            <p id="maxSlPips" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Keuntungan Beruntun</p>
            <p
              id="consecutiveProfit"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p id="consecutiveProfitPeriod" class="text-xs text-gray-500 mt-1">
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Kerugian Beruntun</p>
            <p
              id="consecutiveLoss"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p id="consecutiveLossPeriod" class="text-xs text-gray-500 mt-1">
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Laba Kotor (Total TP)
            </p>
            <p id="grossProfit" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Laba Kotor (Total SL)
            </p>
            <p id="grossLoss" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">Laba Bersih</p>
            <p id="netProfit" class="text-base font-light text-black mt-1">
              N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Balance Drawdown Maximal
            </p>
            <p
              id="maxBalanceDrawdown"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p id="maxBalanceDrawdownPeriod" class="text-xs text-gray-500 mt-1">
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Balance Drawdown Monthly
            </p>
            <p
              id="monthlyBalanceDrawdown"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p
              id="monthlyBalanceDrawdownPeriod"
              class="text-xs text-gray-500 mt-1"
            >
              Periode: N/A
            </p>
          </div>
          <div>
            <p class="text-gray-600 text-sm font-light">
              Maksimum Drawdown Bulanan %
            </p>
            <p
              id="monthlyMaxDrawdownPercentage"
              class="text-base font-light text-black mt-1"
            >
              N/A
            </p>
            <p
              id="monthlyMaxDrawdownPercentagePeriod"
              class="text-xs text-gray-500 mt-1"
            >
              Periode: N/A
            </p>
          </div>
        </div>
      </section>

      <!-- INI KODE BARU UNTUK SELURUH BAGIAN RINGKASAN P/L BULANAN -->
      <section id="monthlyPLSummarySection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan P/L Bulanan
        </h2>
        <!-- Wrapper baru untuk scroll vertikal -->
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Bulan</th>
                <th>Presentase Akumulasi</th>
                <th>Total Eksekusi</th>
                <th>TP / SL</th>
                <!-- Header baru ditambahkan di sini -->
                <th>Total Eksekusi Bersih</th>
                <th>TP Bersih ($)</th>
                <th>Akumulasi Nett ($)</th>
                <th class="rounded-tr-lg">Total Saldo ($)</th>
              </tr>
            </thead>
            <tbody id="monthlyPLSummaryBody">
              <!-- Data akan diisi oleh JavaScript -->
              <tr>
                <td colspan="8" class="py-4 text-center text-gray-500">
                  Menghitung data...
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- Tombol unduh baru ditambahkan di sini -->
        <div class="flex justify-end mt-4">
          <button id="downloadMonthlyPLSummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <!-- PERBAIKAN: Bagian Ringkasan Harian, Mingguan, Bulanan, dan Tahunan -->

      <section id="newDailySummarySection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Harian Kumulatif
        </h2>
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full monthly-summary-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Tanggal</th>
                <th>Presentase Kumulatif</th>
                <th>Total Pips Kumulatif</th>
                <th>Total Trade</th>
                <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
              </tr>
            </thead>
            <tbody id="newDailySummaryBody">
              <tr>
                <td colspan="5" class="py-4 text-center text-gray-500">
                  Belum ada data untuk ditampilkan.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="flex justify-end mt-4">
          <button id="downloadNewDailySummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <section id="newWeeklySummarySection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Mingguan Kumulatif
        </h2>
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full monthly-summary-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Minggu</th>
                <th>Presentase Kumulatif</th>
                <th>Total Pips Kumulatif</th>
                <th>Total Trade</th>
                <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
              </tr>
            </thead>
            <tbody id="newWeeklySummaryBody">
              <tr>
                <td colspan="5" class="py-4 text-center text-gray-500">
                  Belum ada data untuk ditampilkan.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="flex justify-end mt-4">
          <button id="downloadNewWeeklySummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <section id="newMonthlySummarySection" class="mt-8">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Bulanan Kumulatif
        </h2>
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full monthly-summary-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Bulan</th>
                <th>Presentase Kumulatif</th>
                <th>Total Pips Kumulatif</th>
                <th>Total Trade</th>
                <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
              </tr>
            </thead>
            <tbody id="newMonthlySummaryBody">
              <tr>
                <td colspan="5" class="py-4 text-center text-gray-500">
                  Belum ada data untuk ditampilkan.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="flex justify-end mt-4">
          <button id="downloadNewMonthlySummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <section id="newYearlySummarySection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Tahunan Kumulatif
        </h2>
        <div class="summary-table-container overflow-x-auto">
          <table class="results-table w-full monthly-summary-table">
            <thead>
              <tr>
                <th class="rounded-tl-lg">Tahun</th>
                <th>Presentase Kumulatif</th>
                <th>Total Pips Kumulatif</th>
                <th>Total Trade</th>
                <th class="rounded-tr-lg">Saldo Akhir Kumulatif</th>
              </tr>
            </thead>
            <tbody id="newYearlySummaryBody">
              <tr>
                <td colspan="5" class="py-4 text-center text-gray-500">
                  Belum ada data untuk ditampilkan.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="flex justify-end mt-4">
          <button id="downloadNewYearlySummaryBtn" class="upload-data-button">
            Unduh Excel
          </button>
        </div>
      </section>

      <!-- ▼▼▼ LETAKKAN SELURUH BLOK KODE BARU DI BAWAH INI ▼▼▼ -->
      <section id="calendarSection" class="mt-8 scroll-animate-section">
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Kalender Bulanan
        </h2>
        <div
          class="calendar-container bg-white p-4 rounded-lg border border-gray-200 shadow-sm"
        >
          <div class="calendar-header flex justify-between items-center mb-4">
            <button
              id="prevMonthBtn"
              class="calendar-nav-btn p-2 rounded-full hover:bg-gray-100"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-5 w-5"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M15 19l-7-7 7-7"
                />
              </svg>
            </button>
            <h3
              id="monthYearDisplay"
              class="text-base font-semibold text-gray-700"
            ></h3>
            <button
              id="nextMonthBtn"
              class="calendar-nav-btn p-2 rounded-full hover:bg-gray-100"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                class="h-5 w-5"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M9 5l7 7-7 7"
                />
              </svg>
            </button>
          </div>
          <div class="calendar-grid grid grid-cols-7 gap-2 text-center">
            <div class="calendar-day-name text-xs font-bold text-gray-400">
              Su
            </div>
            <div class="calendar-day-name text-xs font-bold text-gray-400">
              Mo
            </div>
            <div class="calendar-day-name text-xs font-bold text-gray-400">
              Tu
            </div>
            <div class="calendar-day-name text-xs font-bold text-gray-400">
              We
            </div>
            <div class="calendar-day-name text-xs font-bold text-gray-400">
              Th
            </div>
            <div class="calendar-day-name text-xs font-bold text-gray-400">
              Fr
            </div>
            <div class="calendar-day-name text-xs font-bold text-gray-400">
              Sa
            </div>
          </div>
          <div
            id="calendarBody"
            class="calendar-grid grid grid-cols-7 gap-2 mt-2 text-center"
          >
            <!-- Tanggal akan diisi oleh JavaScript -->
          </div>
        </div>
      </section>
      <!-- ▲▲▲ AKHIR DARI BLOK KODE BARU ▲▲▲ -->

      <!-- ▼▼▼ LETAKKAN SELURUH BLOK KODE BARU DI BAWAH INI ▼▼▼ -->
      <section
        id="outcomeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          id="outcomeChartTitle"
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Hasil Eksekusi (Total: 0)
        </h2>
        <div
          id="outcomeRadarChartContainer"
          class="bg-white p-6 rounded-lg flex items-center justify-center min-h-[300px]"
        >
          <canvas id="outcomeRadarChart"></canvas>
          <div id="outcomeRadarChartLoading" class="hidden text-gray-500">
            Memuat data hasil eksekusi...
          </div>
          <div id="outcomeRadarChartError" class="hidden error-message"></div>
          <div id="outcomeRadarChartNoData" class="hidden text-gray-500">
            Belum ada data hasil eksekusi.
          </div>
        </div>
      </section>

      <section
        id="assetSuccessStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Keberhasilan Aset
        </h2>
        <div
          id="pieChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center"
        >
          <canvas id="assetSuccessPieChart"></canvas>
          <div id="pieChartLoading" class="hidden text-gray-500">
            Memuat data keberhasilan aset...
          </div>
          <div id="pieChartError" class="hidden error-message"></div>
          <div id="pieChartNoData" class="hidden text-gray-500">
            Tidak ada data keberhasilan aset yang tersedia.
          </div>
        </div>
      </section>

      <section
        id="dailyLineStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Persentase Harian
          <span
            id="dailyChartDateTime"
            class="text-gray-600 text-sm font-light"
          ></span>
        </h2>
        <div
          id="dailyLineChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="dailyLineChart"></canvas>
          <div id="dailyLineChartLoading" class="hidden text-gray-500">
            Memuat data statistik...
          </div>
          <div id="dailyLineChartError" class="hidden error-message"></div>
          <div id="dailyLineChartNoData" class="hidden text-gray-500">
            Tidak ada data statistik harian.
          </div>
        </div>
      </section>

      <section
        id="monthlyBarStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Persentase Bulanan (Diagram Batang)
        </h2>
        <div
          id="monthlyBarChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="monthlyBarChart"></canvas>
          <div id="monthlyBarChartLoading" class="hidden text-gray-500">
            Memuat data statistik...
          </div>
          <div id="monthlyBarChartError" class="hidden error-message"></div>
          <div id="monthlyBarChartNoData" class="hidden text-gray-500">
            Tidak ada data statistik bulanan.
          </div>
        </div>
      </section>

      <section
        id="overallPercentageCumulativeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <div class="flex justify-between items-start mb-4">
          <div class="w-full">
            <h2
              class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
            >
              Statistik Persentase Kumulatif Keseluruhan
            </h2>
            <p id="lastExecDate_Percentage" class="text-xs text-gray-500 -mt-1">
              Bulan & Tahun: N/A
            </p>
            <p
              id="finalValue_Percentage"
              class="text-lg sm:text-xl font-semibold mt-1"
            >
              0.00%
            </p>
          </div>
        </div>
        <div
          id="overallPercentageCumulativeChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="overallPercentageCumulativeChart"></canvas>
          <div
            id="overallPercentageCumulativeChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data statistik...
          </div>
          <div
            id="overallPercentageCumulativeChartError"
            class="hidden error-message"
          ></div>
          <div
            id="overallPercentageCumulativeChartNoData"
            class="hidden text-gray-500"
          >
            Tidak ada data statistik kumulatif keseluruhan.
          </div>
        </div>
        <div class="mt-2">
          <p class="text-xs font-semibold text-gray-600">
            Aset yang Dieksekusi:
          </p>
          <p
            id="assetList_Percentage"
            class="text-xs text-gray-500 leading-tight"
          >
            N/A
          </p>
        </div>
        <!-- ▼▼▼ LETAKKAN KODE BARU DI SINI ▼▼▼ -->
        <div class="flex justify-end mt-2">
          <button
            id="showPercentageDetailsBtn"
            class="text-xs text-blue-600 hover:underline font-light focus:outline-none"
          >
            Data Selengkapnya
          </button>
        </div>
        <!-- ▲▲▲ AKHIR DARI BLOK KODE BARU ▲▲▲ -->
      </section>

      <section
        id="overallBalanceCumulativeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <div class="flex justify-between items-start mb-4">
          <div class="w-full">
            <h2
              class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
            >
              Statistik Saldo Akun Kumulatif Keseluruhan
            </h2>
            <p id="lastExecDate_Balance" class="text-xs text-gray-500 -mt-1">
              Bulan & Tahun: N/A
            </p>
            <p
              id="finalValue_Balance"
              class="text-lg sm:text-xl font-semibold mt-1"
            >
              $0.00
            </p>
          </div>
        </div>
        <div
          id="overallBalanceCumulativeChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="overallBalanceCumulativeChart"></canvas>
          <div
            id="overallBalanceCumulativeChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data statistik...
          </div>
          <div
            id="overallBalanceCumulativeChartError"
            class="hidden error-message"
          ></div>
          <div
            id="overallBalanceCumulativeChartNoData"
            class="hidden text-gray-500"
          >
            Tidak ada data statistik saldo kumulatif keseluruhan.
          </div>
        </div>
        <div class="mt-2">
          <p class="text-xs font-semibold text-gray-600">
            Aset yang Dieksekusi:
          </p>
          <p id="assetList_Balance" class="text-xs text-gray-500 leading-tight">
            N/A
          </p>
        </div>
      </section>

      <section
        id="overallPipsCumulativeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <div class="flex justify-between items-start mb-4">
          <div class="w-full">
            <h2
              class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
            >
              Statistik Pips/Points Kumulatif Keseluruhan
            </h2>
            <p id="lastExecDate_Pips" class="text-xs text-gray-500 -mt-1">
              Bulan & Tahun: N/A
            </p>
            <p
              id="finalValue_Pips"
              class="text-lg sm:text-xl font-semibold mt-1"
            >
              0
            </p>
          </div>
        </div>
        <div
          id="overallPipsCumulativeChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="overallPipsCumulativeChart"></canvas>
          <div
            id="overallPipsCumulativeChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data statistik...
          </div>
          <div
            id="overallPipsCumulativeChartError"
            class="hidden error-message"
          ></div>
          <div
            id="overallPipsCumulativeChartNoData"
            class="hidden text-gray-500"
          >
            Tidak ada data statistik pips/points kumulatif keseluruhan.
          </div>
        </div>
        <div class="mt-2">
          <p class="text-xs font-semibold text-gray-600">
            Aset yang Dieksekusi:
          </p>
          <p id="assetList_Pips" class="text-xs text-gray-500 leading-tight">
            N/A
          </p>
        </div>
      </section>

      <!-- ▼▼▼ LETAKKAN SELURUH BLOK KODE BARU DI BAWAH INI ▼▼▼ -->
      <section
        id="combinedCumulativeStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Statistik Gabungan Kumulatif
        </h2>
        <div
          id="combinedCumulativeChartContainer"
          class="bg-white p-6 rounded-lg flex items-center justify-center min-h-[300px]"
        >
          <canvas id="combinedCumulativeChart"></canvas>
          <div id="combinedCumulativeChartLoading" class="hidden text-gray-500">
            Memuat data gabungan...
          </div>
          <div
            id="combinedCumulativeChartError"
            class="hidden error-message"
          ></div>
          <div id="combinedCumulativeChartNoData" class="hidden text-gray-500">
            Belum ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Combined Summary Bar Chart Section -->
      <section
        id="combinedSummaryBarStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Ringkasan Akumulasi Gabungan (Diagram Batang)
        </h2>
        <div
          id="combinedSummaryBarChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="combinedSummaryBarChart"></canvas>
          <div id="combinedSummaryBarChartLoading" class="hidden text-gray-500">
            Memuat data ringkasan...
          </div>
          <div
            id="combinedSummaryBarChartError"
            class="hidden error-message"
          ></div>
          <div id="combinedSummaryBarChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Balance Frequency Chart Section -->
      <section
        id="balanceFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Balance per Aset
        </h2>
        <div
          id="balanceFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="balanceFrequencyChart"></canvas>
          <div id="balanceFrequencyChartLoading" class="hidden text-gray-500">
            Memuat data frekuensi balance...
          </div>
          <div
            id="balanceFrequencyChartError"
            class="hidden error-message"
          ></div>
          <div id="balanceFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Percentage Frequency Chart Section -->
      <section
        id="percentageFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Persentase per Aset
        </h2>
        <div
          id="percentageFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="percentageFrequencyChart"></canvas>
          <div
            id="percentageFrequencyChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data frekuensi persentase...
          </div>
          <div
            id="percentageFrequencyChartError"
            class="hidden error-message"
          ></div>
          <div id="percentageFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Pips Frequency Chart Section -->
      <section
        id="pipsFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Pips/Points per Aset
        </h2>
        <div
          id="pipsFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="pipsFrequencyChart"></canvas>
          <div id="pipsFrequencyChartLoading" class="hidden text-gray-500">
            Memuat data frekuensi pips...
          </div>
          <div id="pipsFrequencyChartError" class="hidden error-message"></div>
          <div id="pipsFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Execution Frequency Chart Section -->
      <section
        id="executionFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Eksekusi per Aset (BUY vs SELL)
        </h2>
        <div
          id="executionFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="executionFrequencyChart"></canvas>
          <div id="executionFrequencyChartLoading" class="hidden text-gray-500">
            Memuat data frekuensi eksekusi...
          </div>
          <div
            id="executionFrequencyChartError"
            class="hidden error-message"
          ></div>
          <div id="executionFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- NEW: Asset Execution Count Chart Section -->
      <section
        id="assetExecutionCountStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Aset Selesai Dieksekusi
        </h2>
        <div
          id="assetExecutionCountChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="assetExecutionCountChart"></canvas>
          <div
            id="assetExecutionCountChartLoading"
            class="hidden text-gray-500"
          >
            Memuat data frekuensi aset...
          </div>
          <div
            id="assetExecutionCountChartError"
            class="hidden error-message"
          ></div>
          <div id="assetExecutionCountChartNoData" class="hidden text-gray-500">
            Tidak ada data untuk ditampilkan.
          </div>
        </div>
      </section>

      <!-- New section for Trade Frequency Chart -->
      <section
        id="tradeFrequencyStatisticsSection"
        class="mt-8 scroll-animate-section"
      >
        <h2
          class="text-lg font-light text-primary mb-4 pb-2 border-b border-gray-200"
        >
          Frekuensi Eksekusi Trade per Aset
        </h2>
        <div
          id="tradeFrequencyChartContainer"
          class="bg-white p-6 rounded-lg border border-gray-200 shadow-sm flex items-center justify-center min-h-[250px]"
        >
          <canvas id="tradeFrequencyChart"></canvas>
          <div id="tradeFrequencyChartLoading" class="hidden text-gray-500">
            Memuat data frekuensi trade...
          </div>
          <div id="tradeFrequencyChartError" class="hidden error-message"></div>
          <div id="tradeFrequencyChartNoData" class="hidden text-gray-500">
            Tidak ada data frekuensi trade.
          </div>
        </div>
      </section>

      <!-- NEW GUIDE SECTION -->
      <section class="info-section mt-8 scroll-animate-section">
        <h2>Panduan Lengkap: Menggunakan Kalkulator Risk & Reward</h2>
        <p>
          Selamat datang di Kalkulator Risk & Reward! Alat ini dirancang untuk
          menjadi asisten pribadi Anda dalam merencanakan, menghitung, dan
          menganalisis setiap perdagangan. Dengan memahami potensi risiko dan
          imbalan sebelum masuk pasar, Anda dapat membuat keputusan yang lebih
          cerdas dan disiplin.
        </p>

        <h3>Langkah-langkah Penggunaan</h3>
        <ol class="list-decimal list-inside space-y-4">
          <li>
            <strong>Membuat Rencana (Input Data)</strong>
            <p class="mt-2">
              Klik tombol <strong>"Tambah Baris Input"</strong> untuk memulai.
              Sebuah formulir akan muncul. Isi setiap kolom dengan cermat:
            </p>
            <ul class="list-circle list-inside ml-4 mt-2 space-y-1">
              <li>
                <strong>Aset:</strong> Pilih instrumen yang akan Anda
                perdagangkan dari daftar.
              </li>
              <li>
                <strong>Tipe Trade:</strong> Tentukan posisi Anda dengan memilih
                <strong>BUY</strong> atau <strong>SELL</strong>.
              </li>
              <li>
                <strong>Balance Akun ($):</strong> Masukkan total saldo akun
                trading Anda saat ini.
              </li>
              <li>
                <strong>Risiko (%):</strong> Tentukan berapa persen dari saldo
                akun yang Anda relakan sebagai risiko untuk trade ini (misal:
                0.5% atau 1%).
              </li>
              <li>
                <strong>Price Now:</strong> Harga pasar saat ini. Kolom ini
                digunakan untuk menghitung 'Pending Pips' dan tidak memengaruhi
                kalkulasi inti.
              </li>
              <li>
                <strong>Open Price:</strong> Harga di mana Anda berencana untuk
                membuka posisi.
              </li>
              <li>
                <strong>SL Price (Stop Loss):</strong> Harga di mana posisi akan
                ditutup otomatis untuk membatasi kerugian.
              </li>
              <li>
                <strong>TP Price (Take Profit):</strong> Harga di mana posisi
                akan ditutup otomatis untuk mengamankan keuntungan.
              </li>
              <li>
                <strong>Catatan (Opsional):</strong> Tulis catatan singkat
                mengenai strategi atau alasan Anda membuka posisi ini.
              </li>
            </ul>
          </li>
          <li>
            <strong>Menghitung & Memindahkan Rencana</strong>
            <p class="mt-2">
              Setelah semua data terisi, klik <strong>"Hitung Semua"</strong>.
              Hasil perhitungan akan muncul di tabel
              <strong>"Rencana Trading Baru"</strong>. Dari sini, alur kerjanya
              adalah:
            </p>
            <ul class="list-circle list-inside ml-4 mt-2 space-y-1">
              <li>
                <strong>Set Running:</strong> Jika Anda memutuskan untuk
                melanjutkan rencana ini (sebagai pending atau market order),
                klik tombol ini. Rencana akan pindah ke tabel
                <strong>"Rencana Trading Aktif"</strong>.
              </li>
              <li>
                <strong>Menyelesaikan Trade:</strong> Di tabel "Rencana Trading
                Aktif", setelah posisi Anda ditutup, klik
                <strong>"TAKE PROFIT"</strong> atau
                <strong>"STOP LOSS"</strong> sesuai hasil akhirnya. Rencana akan
                pindah ke tabel <strong>"Rencana Trading Selesai"</strong> dan
                semua data statistik akan diperbarui secara otomatis.
              </li>
              <li>
                <strong>Opsi Lain:</strong> Gunakan tombol
                <strong>"BATAL"</strong> atau <strong>"TES"</strong> untuk
                membatalkan rencana aktif tanpa perhitungan statistik, atau
                <strong>"EDIT"</strong> untuk memindahkan kembali rencana ke
                formulir input jika ada perubahan.
              </li>
            </ul>
          </li>
        </ol>

        <h3>Memahami Hasil Kalkulasi</h3>
        <p>Berikut penjelasan untuk setiap kolom di tabel hasil:</p>
        <ul>
          <li>
            <strong>Pending Pips/Points:</strong> Jarak antara
            <strong>Price Now</strong> dan <strong>Open Price</strong> Anda.
          </li>
          <li>
            <strong>SL Pips/Points:</strong> Jarak (risiko) dari
            <strong>Open Price</strong> ke <strong>SL Price</strong>.
          </li>
          <li>
            <strong>TP Pips/Points:</strong> Jarak (potensi imbalan) dari
            <strong>Open Price</strong> ke <strong>TP Price</strong>.
          </li>
          <li>
            <strong>R:R Pips:</strong> Rasio sederhana antara TP Pips dan SL
            Pips. Contoh: 1:2.5 berarti potensi imbalan 2.5 kali lebih besar
            dari risikonya.
          </li>
          <li>
            <strong>R:R %:</strong> Rasio antara persentase potensi profit dan
            persentase risiko dari total balance.
          </li>
          <li>
            <strong>Lot/Units:</strong> Ukuran volume trading yang dihitung
            secara otomatis berdasarkan persentase risiko yang Anda tentukan,
            memastikan Anda tidak merisikokan lebih dari yang direncanakan.
          </li>
          <li>
            <strong>Nett SL:</strong> Total potensi kerugian dalam mata uang
            Dolar jika harga menyentuh Stop Loss.
          </li>
          <li>
            <strong>Nett TP:</strong> Total potensi keuntungan dalam mata uang
            Dolar jika harga menyentuh Take Profit.
          </li>
        </ul>

        <h3>Manajemen Foto & Analisis Data</h3>
        <ul class="list-disc list-inside space-y-2">
          <li>
            <strong>Galeri Foto:</strong> Anda bisa menambahkan hingga 5
            screenshot analisis (misal: dari TradingView) dengan mengklik area
            foto. Untuk menghapus foto, tekan dan tahan (long press) pada gambar
            yang ingin dihapus.
          </li>
          <li>
            <strong>Statistik & Grafik:</strong> Semua bagian di bawah tabel
            "Rencana Trading Selesai" adalah rekapitulasi performa Anda. Gunakan
            grafik ini untuk menganalisis aset mana yang paling menguntungkan,
            bagaimana pertumbuhan akun Anda, dan kapan Anda paling sering profit
            atau loss.
          </li>
          <li>
            <strong>Penting:</strong> Kalkulator ini adalah alat bantu jurnal
            dan analisis. Keputusan trading dan segala risikonya tetap menjadi
            tanggung jawab Anda sepenuhnya.
          </li>
        </ul>
      </section>

      <!-- New section for the provided text content -->
      <section class="info-section mt-8 scroll-animate-section">
        <h2 class="text-xl font-medium text-primary mb-4">
          Bagaimana Kasino Vegas Membuat Pemain Rugi & Mirip dengan Broker
          Curang
        </h2>
        <p class="text-base font-light text-gray-700 leading-relaxed mb-4">
          Baik kasino di Las Vegas maupun beberapa broker "nakal" memiliki
          strategi tersembunyi untuk memastikan keuntungan mereka, seringkali
          dengan mengorbankan pemain atau trader yang menguntungkan. Meskipun
          metode mereka berbeda, prinsip dasarnya sama: memanipulasi
          probabilitas dan informasi untuk keuntungan mereka.
        </p>
        <h3 class="text-lg font-semibold text-gray-800 mb-3">
          Alur Kasino Vegas Membuat Pemain Rugi
        </h3>
        <p class="text-base font-light text-gray-700 leading-relaxed mb-4">
          Kasino tidak perlu "curang" secara terang-terangan untuk menang; model
          bisnis mereka dibangun di atas keunggulan statistik yang disebut
          "house edge". Ini adalah persentase keuntungan jangka panjang yang
          dimiliki kasino atas pemain. Berikut adalah alurnya:
        </p>
        <ul class="list-disc list-inside mb-4">
          <li class="text-base font-light text-gray-700 mb-2">
            <strong
              >Matematika yang Tidak Menguntungkan Pemain (House Edge):</strong
            >
            Setiap permainan kasino dirancang agar kasino selalu memiliki
            sedikit keuntungan matematis dalam jangka panjang. Misalnya, di
            rolet, ada angka 0 (dan kadang 00), yang berarti peluang Anda untuk
            memenangkan taruhan merah/hitam sedikit kurang dari 50%. Meskipun
            Anda mungkin menang beberapa putaran, secara statistik, kasino akan
            selalu di atas angin seiring waktu.
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Variasi dan Keberuntungan Jangka Pendek:</strong> Kasino
            mengandalkan fakta bahwa dalam jangka pendek, keberuntungan bisa
            berpihak pada pemain. Ini menciptakan ilusi bahwa pemain bisa menang
            besar, mendorong mereka untuk terus bermain. Kemenangan sesekali ini
            memicu dopamin dan membuat pemain merasa "beruntung," mendorong
            mereka untuk terus bertaruh.
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Psikologi dan Lingkungan yang Memikat:</strong>
            <ul class="list-circle list-inside ml-4 mt-1">
              <li class="text-base font-light text-gray-700">
                Desain Tanpa Jendela dan Jam: Kasino dirancang untuk membuat
                pemain lupa waktu, mendorong mereka untuk bermain lebih lama.
              </li>
              <li class="text-base font-light text-gray-700">
                Atmosfer Glamor dan Hiburan: Suasana yang mewah, musik, dan
                minuman gratis menciptakan lingkungan yang nyaman dan mendorong
                pengeluaran.
              </li>
              <li class="text-base font-light text-gray-700">
                Kompensasi dan Hadiah (Comp): Kasino memberikan hadiah kecil
                (makanan gratis, kamar murah) kepada pemain yang kalah dalam
                jumlah besar atau bermain untuk waktu yang lama, membuat mereka
                merasa dihargai dan mendorong kunjungan kembali.
              </li>
            </ul>
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Kontrol Informasi dan Aturan Main:</strong> Kasino
            sepenuhnya mengontrol aturan main, pembayaran, dan informasi yang
            diberikan kepada pemain. Pemain seringkali tidak menyadari house
            edge yang sebenarnya atau bagaimana probabilitas bekerja melawan
            mereka.
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Pengelolaan Keuangan Pemain:</strong> Kasino mendorong
            pemain untuk mengambil lebih banyak uang tunai, menyediakan ATM di
            lokasi, dan menawarkan fasilitas kredit, semuanya dirancang untuk
            membuat pemain terus berjudi bahkan setelah mereka kehabisan uang
            tunai yang mereka bawa.
          </li>
        </ul>

        <h3 class="text-lg font-semibold text-gray-800 mb-3">
          Koneksi dengan Broker Curang yang Mencurangi Trader Profitabel
        </h3>
        <p class="text-base font-light text-gray-700 leading-relaxed mb-4">
          Meskipun ranahnya berbeda, modus operasi broker nakal yang mencurangi
          trader profitabel memiliki kemiripan filosofis dengan cara kasino
          beroperasi. Perbedaannya adalah broker tersebut melakukan tindakan
          yang lebih eksplisit dan seringkali ilegal.
        </p>
        <ul class="list-disc list-inside mb-4">
          <li class="text-base font-light text-gray-700 mb-2">
            <strong
              >Manipulasi Data dan Eksekusi (House Edge Tersembunyi):</strong
            >
            <ul class="list-circle list-inside ml-4 mt-1">
              <li class="text-base font-light text-gray-700">
                Slippage yang Tidak Adil: Broker sengaja menerapkan slippage
                negatif yang besar pada pesanan trader yang profitabel, atau
                bahkan pada semua pesanan. Ini berarti harga eksekusi jauh lebih
                buruk dari harga yang diharapkan trader, mengikis keuntungan.
              </li>
              <li class="text-base font-light text-gray-700">
                Requotes dan Penolakan Pesanan: Pesanan trader yang profitabel,
                terutama pada saat volatilitas tinggi, seringkali ditolak atau
                di-requote dengan harga yang kurang menguntungkan. Ini
                mengganggu strategi trading dan menyebabkan frustrasi.
              </li>
              <li class="text-base font-light text-gray-700">
                Pemblokiran Penarikan Dana: Ini adalah bentuk kecurangan yang
                paling ekstrem. Ketika trader berhasil mengumpulkan keuntungan
                yang signifikan, broker membuat berbagai alasan (masalah
                verifikasi, masalah sistem) untuk menunda atau menolak penarikan
                dana.
              </li>
            </ul>
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong
              >Intervensi pada Order Flow (Memprediksi Gerakan Pemain):</strong
            >
            <ul class="list-circle list-inside ml-4 mt-1">
              <li class="text-base font-light text-gray-700">
                Dealing Desk (DD) vs. Non-Dealing Desk (NDD): Broker DD
                seringkali mengambil posisi berlawanan dengan trader mereka.
                Jika seorang trader sangat profitabel, broker DD mungkin akan
                menempatkan "stop-loss hunting" (memicu stop-loss trader secara
                artifisial) atau menahan harga yang menguntungkan.
              </li>
              <li class="text-base font-light text-gray-700">
                Manipulasi Harga: Broker dapat memanipulasi feed harga mereka
                sendiri, terutama saat ada berita penting, untuk memicu
                stop-loss atau menunda take-profit trader.
              </li>
            </ul>
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Psikologi dan Lingkungan yang Menjebak:</strong>
            <ul class="list-circle list-inside ml-4 mt-1">
              <li class="text-base font-light text-gray-700">
                Bonus dan Promosi Palsu: Banyak broker nakal menawarkan bonus
                deposit yang sangat besar, tetapi dengan syarat dan ketentuan
                penarikan yang hampir mustahil untuk dipenuhi. Ini mengunci dana
                trader dan mendorong mereka untuk terus trading.
              </li>
              <li class="text-base font-light text-gray-700">
                Edukasi yang Menyesatkan: Beberapa broker menyediakan "edukasi"
                yang pada dasarnya mendorong gaya trading yang tidak sehat atau
                terlalu agresif, yang pada akhirnya menguntungkan broker karena
                trader akan lebih sering kalah.
              </li>
            </ul>
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Kurangnya Transparansi dan Regulasi yang Lemah:</strong>
            Broker nakal sering beroperasi di yurisdiksi dengan regulasi yang
            longgar atau sama sekali tanpa regulasi. Ini memungkinkan mereka
            untuk melakukan praktik tidak etis tanpa takut dihukum. Mereka tidak
            memberikan laporan transparan tentang eksekusi order atau aliran
            dana.
          </li>
          <li class="text-base font-light text-gray-700 mb-2">
            <strong>Memanfaatkan Emosi Trader:</strong> Sama seperti kasino,
            broker nakal memanfaatkan emosi seperti keserakahan dan ketakutan.
            Mereka tahu bahwa trader yang emosional cenderung membuat keputusan
            impulsif yang menguntungkan broker.
          </li>
        </ul>
        <p class="text-base font-light text-gray-700 leading-relaxed">
          Secara ringkas, baik kasino maupun broker curang bertujuan untuk
          mendapatkan keuntungan jangka panjang. Kasino melakukannya melalui
          keunggulan matematis yang inheren dalam permainan mereka dan
          manipulasi lingkungan psikologis. Broker curang, di sisi lain, secara
          aktif memanipulasi kondisi trading, data, dan terkadang bahkan menahan
          dana untuk memastikan mereka "menang" melawan trader yang
          menguntungkan. Kedua entitas ini mengandalkan fakta bahwa mayoritas
          "pemain" akan kalah dalam jangka panjang, entah karena matematika atau
          karena manipulasi sistem.
        </p>
      </section>

      <!-- NEW: Download All Data Button -->
      <section class="mt-8 text-center scroll-animate-section">
        <button id="downloadAllExcelBtn" class="action-button">
          Unduh Semua Data (Excel)
        </button>
        <button id="downloadAllPdfBtn" class="action-button">
          Unduh Semua Data (PDF)
        </button>
      </section>

      <!-- Footer Section -->
      <footer
        class="w-full py-4 text-center text-gray-700 text-sm font-light mt-8"
      >
        Leodra Sint | Think like a dealer, not like a player.
      </footer>
    </div>

    <!-- Photo Upload Modal -->
    <div id="photoUploadModal" class="modal">
      <div class="modal-content">
        <h3 class="text-lg font-semibold text-primary mb-4">
          Unggah & Pangkas Foto (1:1)
        </h3>
        <!-- This input is now visually hidden but triggered by the label -->
        <input
          type="file"
          id="imageInput"
          accept="image/*"
          class="hidden"
          multiple
        />
        <div
          class="flex justify-center items-center bg-gray-100 rounded-md overflow-hidden"
        >
          <canvas id="imageCanvas"></canvas>
        </div>
        <div class="flex justify-end gap-3 mt-4">
          <button
            id="cancelPhotoBtn"
            class="action-button bg-gray-300 hover:bg-gray-400 text-gray-800"
          >
            Batal
          </button>
          <button id="cropAndSaveBtn" class="action-button">
            Pangkas & Simpan
          </button>
        </div>
      </div>
    </div>

    <!-- PERBAIKAN: Skrip untuk fungsionalitas menu hamburger ditambahkan di sini -->
    <script>
      // --- PERBAIKAN: Event Delegation untuk Tombol Aksi di Semua Tabel ---

      // --- AKHIR DARI BLOK KODE BARU ---
      document.addEventListener("DOMContentLoaded", function () {
        const hamburgerBtn = document.getElementById("hamburgerBtn");
        const mobileMenu = document.getElementById("mobileMenu");
        const closeMenuBtn = document.getElementById("closeMenuBtn");

        hamburgerBtn.addEventListener("click", function () {
          mobileMenu.classList.remove("hidden");
        });

        closeMenuBtn.addEventListener("click", function () {
          mobileMenu.classList.add("hidden");
        });
      });
    </script>

    <script type="module">
      // Firebase imports
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import {
        getAuth,
        signInAnonymously,
        signInWithCustomToken,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        setDoc,
        collection,
        query,
        onSnapshot,
        addDoc,
        deleteDoc,
        getDocs,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
      import {
        getStorage,
        ref,
        uploadBytes,
        getDownloadURL,
        deleteObject,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

      // Global Firebase variables
      let app;
      let db;
      let auth;
      let storage;
      let userId = "anonymous"; // Default to anonymous

      // Initialize Firebase
      const firebaseConfig = JSON.parse(
        typeof __firebase_config !== "undefined" ? __firebase_config : "{}"
      );
      const appId =
        typeof __app_id !== "undefined" ? __app_id : "default-app-id";

      // Global variables for data storage
      let calculatedPlansData = []; // New: for plans that are calculated but not yet running
      let runningPlansData = []; //
      let executedPlansData = [];
      let limitNotificationMessage = "";

      // ... (existing constants like PENDING_PIPS_RULES, MAX_ACTIVE_RISK_PERCENT, etc.) ...
      // --- ATURAN BARU: Batas Risiko & Pending Pips ---
      const PENDING_PIPS_RULES = {};
      // PERUBAHAN: Memperbarui nilai konstanta batas risiko sesuai permintaan pengguna
      const MAX_ACTIVE_RISK_PERCENT = 2.0; // Batas risiko aktif (sebagai persentase positif)
      const DAILY_LOSS_LIMIT = -2.5; // Batas kerugian harian (sebagai persentase negatif)
      const MONTHLY_LOSS_LIMIT = -4.5; // Batas kerugian bulanan (sebagai persentase negatif)
      const OVERALL_MAX_LOSS_LIMIT = -5.5; // Batas kerugian maksimal keseluruhan (sebagai persentase negatif)
      const MAX_RISK_PER_TRADE = 0.2;

      // --- DATA ASET & NILAI PIPS/POINTS ---
      // Menambahkan properti 'minLotIncrement' untuk setiap aset
      const assetValues = {
        "EUR/USD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/USD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/USD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NZD/USD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/SEK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "SEK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/NOK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "NOK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/DKK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "DKK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/GBP": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "GBP",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CAD/JPY": {
          decimals: 3,
          pipValue: 9.09,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CHF/JPY": {
          decimals: 3,
          pipValue: 6.78,
          contractSize: 100000,
          type: "forexCross",
          currency: "JPY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/AUD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "AUD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexCross",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/NZD": {
          decimals: 5,
          pipValue: 6.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NZD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/AUD": {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "AUD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexCross",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/NZD": {
          decimals: 5,
          pipValue: 6.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NZD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexCross",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/NZD": {
          decimals: 5,
          pipValue: 6.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NZD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CAD/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NZD/CAD": {
          decimals: 5,
          pipValue: 7.3,
          contractSize: 100000,
          type: "forexCross",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NZD/CHF": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexCross",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/SEK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "SEK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/NOK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NOK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/SEK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "SEK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/NOK": {
          decimals: 5,
          pipValue: 1.0,
          contractSize: 100000,
          type: "forexCross",
          currency: "NOK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/MXN": {
          decimals: 5,
          pipValue: 0.5,
          contractSize: 100000,
          type: "forexExotic",
          currency: "MXN",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/ZAR": {
          decimals: 5,
          pipValue: 0.05,
          contractSize: 100000,
          type: "forexExotic",
          currency: "ZAR",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/TRY": {
          decimals: 5,
          pipValue: 0.03,
          contractSize: 100000,
          type: "forexExotic",
          currency: "TRY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/SGD": {
          decimals: 5,
          pipValue: 0.74,
          contractSize: 100000,
          type: "forexExotic",
          currency: "SGD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/HKD": {
          decimals: 5,
          pipValue: 1.28,
          contractSize: 100000,
          type: "forexExotic",
          currency: "HKD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "EUR/TRY": {
          decimals: 5,
          pipValue: 0.03,
          contractSize: 100000,
          type: "forexExotic",
          currency: "TRY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "GBP/TRY": {
          decimals: 5,
          pipValue: 0.03,
          contractSize: 100000,
          type: "forexExotic",
          currency: "TRY",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "AUD/SGD": {
          decimals: 5,
          pipValue: 0.74,
          contractSize: 100000,
          type: "forexExotic",
          currency: "SGD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NZD/SGD": {
          decimals: 5,
          pipValue: 0.74,
          contractSize: 100000,
          type: "forexExotic",
          currency: "SGD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CAD/SGD": {
          decimals: 5,
          pipValue: 0.74,
          contractSize: 100000,
          type: "forexExotic",
          currency: "CAD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "CHF/SGD": {
          decimals: 5,
          pipValue: 11.2,
          contractSize: 100000,
          type: "forexExotic",
          currency: "CHF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/PLN": {
          decimals: 5,
          pipValue: 0.25,
          contractSize: 100000,
          type: "forexExotic",
          currency: "PLN",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/HUF": {
          decimals: 5,
          pipValue: 0.003,
          contractSize: 100000,
          type: "forexExotic",
          currency: "HUF",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "USD/CZK": {
          decimals: 5,
          pipValue: 0.04,
          contractSize: 100000,
          type: "forexExotic",
          currency: "CZK",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "XAU/USD": {
          decimals: 2,
          pipValue: 10.0,
          contractSize: 100,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "XAG/USD": {
          decimals: 3,
          pipValue: 50.0,
          contractSize: 5000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "WTI/USD": {
          decimals: 2,
          pipValue: 10.0,
          contractSize: 1000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "BRENT/USD": {
          decimals: 2,
          pipValue: 10.0,
          contractSize: 1000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "NATGAS/USD": {
          decimals: 3,
          pipValue: 10.0,
          contractSize: 10000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "COPPER/USD": {
          decimals: 4,
          pipValue: 25000.0,
          contractSize: 25000,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        "PLATINUM/USD": {
          decimals: 2,
          pipValue: 50.0,
          contractSize: 50,
          type: "commodity",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        },
        // --- LETAKKAN SELURUH BLOK KODE BARU DI SINI ---
        SPX500: {
          decimals: 2,
          pipValue: 1.0,
          contractSize: 1,
          type: "index",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 0,
        },
        NDX100: {
          decimals: 2,
          pipValue: 2.0,
          contractSize: 1,
          type: "index",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 0,
        },
        DJI30: {
          decimals: 2,
          pipValue: 0.5,
          contractSize: 1,
          type: "index",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 0,
        },
        GER40: {
          decimals: 2,
          pipValue: 1.0,
          contractSize: 1,
          type: "index",
          currency: "EUR",
          minLotIncrement: 0.1,
          pipsDecimals: 0,
        },
        JP225: {
          decimals: 2,
          pipValue: 100.0,
          contractSize: 100,
          type: "index",
          currency: "JPY",
          minLotIncrement: 0.1,
          pipsDecimals: 0,
        },
        FTSE100: {
          decimals: 2,
          pipValue: 1.0,
          contractSize: 1,
          type: "index",
          currency: "GBP",
          minLotIncrement: 0.1,
          pipsDecimals: 0,
        },
        STX50: {
          decimals: 2,
          pipValue: 1.0,
          contractSize: 1,
          type: "index",
          currency: "EUR",
          minLotIncrement: 0.1,
          pipsDecimals: 0,
        },
      };

      // --- GLOBAL VARIABLES DOM ELEMENTS ---
      let rowCounter = 0;
      const inputRowsContainer = document.getElementById("inputRowsContainer");
      const calculatedPlansBody = document.getElementById(
        "calculatedPlansBody"
      ); // New element
      const runningPlansBody = document.getElementById("runningPlansBody"); // Renamed from activePlansData
      const executedPlansBody = document.getElementById("executedPlansBody");
      const calculationDetailsContainer =
        document.getElementById("calculationDetails");
      const dailyChartDateTime = document.getElementById("dailyChartDateTime");
      const deleteAndExportDataBtn = document.getElementById(
        "deleteAndExportDataBtn"
      );
      const uploadDataBtn = document.getElementById("uploadDataBtn");
      const photoCarousel = document.getElementById("photoCarousel"); // New carousel container
      const photoSlides = document.getElementById("photoSlides"); // New slides container
      const prevPhotoBtn = document.getElementById("prevPhotoBtn"); // New prev button
      const nextPhotoBtn = document.getElementById("nextPhotoBtn"); // New next button
      const photoCounter = document.getElementById("photoCounter"); // New photo counter
      const imageInput = document.getElementById("imageInput");
      const imageCanvas = document.getElementById("imageCanvas");
      const ctx = imageCanvas.getContext("2d");
      const photoUploadModal = document.getElementById("photoUploadModal");
      const cropAndSaveBtn = document.getElementById("cropAndSaveBtn");
      const cancelPhotoBtn = document.getElementById("cancelPhotoBtn");
      let currentImageToCrop = null; // Stores the image currently being cropped
      let userPhotos = []; // Array to store all user photo URLs
      let currentPhotoIndex = 0; // Index of the currently displayed photo
      const MAX_PHOTOS = 8;
      // --- LETAKKAN KODE BARU DI SINI ---
      let bannerPhotos = []; // Array untuk foto banner 16:4
      let currentBannerPhotoIndex = 0;
      const MAX_BANNER_PHOTOS = 5; // Batas jumlah foto banner
      let bannerAutoslideInterval; // Variabel untuk menyimpan interval autoslide
      let currentUploadTarget = "1:1"; // Untuk membedakan target unggahan
      // NEW: Download buttons
      const downloadExecutedExcelBtn = document.getElementById(
        "downloadExecutedExcelBtn"
      );
      const downloadAllExcelBtn = document.getElementById(
        "downloadAllExcelBtn"
      );
      const lihatkanDataBtn = document.getElementById("lihatkanDataBtn");
      const downloadNewMonthlySummaryBtn = document.getElementById(
        "downloadNewMonthlySummaryBtn"
      );

      let scrollObserver; // Variabel global untuk instance IntersectionObserver
      // --- LETAKKAN KODE BARU DI SINI ---
      let currentCalendarDate = new Date();
      const calendarBody = document.getElementById("calendarBody");
      const monthYearDisplay = document.getElementById("monthYearDisplay");
      const prevMonthBtn = document.getElementById("prevMonthBtn");
      const nextMonthBtn = document.getElementById("nextMonthBtn");
      let dailyLineChart = null,
        monthlyBarChart = null,
        assetPieChart = null,
        overallPercentageCumulativeChart = null,
        overallBalanceCumulativeChart = null,
        overallPipsCumulativeChart = null,
        tradeFrequencyChart = null;
      let combinedBarChart = null;
      let balanceFrequencyChart = null,
        percentageFrequencyChart = null,
        pipsFrequencyChart = null;
      let executionFrequencyChart = null;
      let assetExecutionCountChart = null; // <-- TAMBAHKAN BARIS INI
      let outcomeRadarChart = null;
      let combinedCumulativeChart = null;

      const handleActionClick = (event) => {
        // Cari tombol terdekat yang diklik
        const button = event.target.closest(".action-button-small");
        if (!button) return; // Keluar jika yang diklik bukan tombol

        const { rowId, outcome, fromSection, id } = button.dataset;
        if (!rowId || !fromSection) return; // Keluar jika tombol tidak punya data yang dibutuhkan

        // Aksi untuk tabel "Rencana Trading Baru"
        if (fromSection === "calculated") {
          setRunning(rowId, id);
        }
        // Aksi untuk tabel "Rencana Trading Aktif"
        else if (fromSection === "running") {
          const planToConfirm = runningPlansData.find((p) => p.rowId === rowId);

          if (!planToConfirm) {
            console.error(
              "Tidak dapat menemukan detail trade untuk konfirmasi."
            );
            showMessageBox(
              "Gagal",
              "Tidak dapat menemukan detail trade. Silakan coba muat ulang halaman.",
              false
            );
            return;
          }

          // Siapkan detail HTML untuk ditampilkan di notifikasi
          const rrPipsFormatted =
            planToConfirm.rrPips > 0
              ? "1:" + formatNumber(planToConfirm.rrPips, 1, false)
              : "N/A";
          let rrPercentageHtml = '<span class="neutral-value">N/A</span>';
          if (planToConfirm.rrPercentage) {
            const slFormatted = `-${formatNumber(
              planToConfirm.rrPercentage.sl,
              2
            )}%`;
            const tpFormatted = `${formatNumber(
              planToConfirm.rrPercentage.tp,
              2
            )}%`;
            const tpClass =
              planToConfirm.rrPercentage.tp >= 0
                ? "positive-value"
                : "negative-value";
            rrPercentageHtml = `<span class="negative-value">${slFormatted}</span> : <span class="${tpClass}">${tpFormatted}</span>`;
          }

          const detailsHtml = `
                  <div class="text-left text-xs space-y-1 bg-gray-50 p-4 rounded-lg border border-gray-200 grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2">
                      <p><strong>Aset:</strong></p> <p>${
                        planToConfirm.symbol
                      }</p>
                      <p><strong>Tipe Trade:</strong></p> <p><span class="${
                        planToConfirm.tradeType === "BUY"
                          ? "positive-value"
                          : "negative-value"
                      } font-semibold">${planToConfirm.tradeType}</span></p>
                      <p><strong>Balance Akun:</strong></p> <p>${formatCurrency(
                        planToConfirm.balance,
                        "USD"
                      )}</p>
                      <p><strong>Waktu Masuk:</strong></p> <p>${formatDateAndTimeForExport(
                        planToConfirm.entryTime
                      )}</p>
                      <p><strong>Open Price:</strong></p> <p>${formatNumber(
                        planToConfirm.openPrice,
                        planToConfirm.assetData.decimals,
                        false
                      )}</p>
                      <p><strong>SL Price:</strong></p> <p>${formatNumber(
                        planToConfirm.slPrice,
                        planToConfirm.assetData.decimals,
                        false
                      )}</p>
                      <p><strong>TP Price:</strong></p> <p>${formatNumber(
                        planToConfirm.tpPrice,
                        planToConfirm.assetData.decimals,
                        false
                      )}</p>
                      <p><strong>Pending Pips:</strong></p> <p>${
                        getVisualPoints(
                          planToConfirm.pendingPips,
                          planToConfirm.symbol
                        ).display
                      }</p>
                      <p><strong>SL Pips:</strong></p> <p>${
                        getVisualPoints(
                          planToConfirm.slPips,
                          planToConfirm.symbol
                        ).display
                      }</p>
                      <p><strong>TP Pips:</strong></p> <p>${
                        getVisualPoints(
                          planToConfirm.tpPips,
                          planToConfirm.symbol
                        ).display
                      }</p>
                      <p><strong>R:R Pips:</strong></p> <p>${rrPipsFormatted}</p>
                      <p><strong>R:R %:</strong></p> <div>${rrPercentageHtml}</div>
                      <p><strong>Lot/Units:</strong></p> <p>${formatNumber(
                        planToConfirm.lotSize,
                        2
                      )}</p>
                      <p><strong>Nett SL:</strong></p> <p class="negative-value">${formatCurrency(
                        planToConfirm.nettSL,
                        "USD"
                      )}</p>
                      <p><strong>Nett TP:</strong></p> <p class="${
                        planToConfirm.nettTP >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatCurrency(planToConfirm.nettTP, "USD")}</p>
                      <p><strong>Catatan:</strong></p> <p>${
                        planToConfirm.note || "-"
                      }</p>
                  </div>
                  <hr class="my-4">
              `;

          // Tampilkan notifikasi yang sesuai berdasarkan tombol yang diklik
          if (outcome === "Edit") {
            const confirmationMessage = `<p class="text-sm text-center">Apakah Anda yakin ingin <strong>MENGEDIT</strong> trade ini? Rencana akan dikembalikan ke formulir input.</p>`;
            showMessageBox(
              `Konfirmasi: Edit`,
              detailsHtml + confirmationMessage,
              true
            ).then((result) => {
              // Menggunakan 'result'
              if (result.confirmed) editRunningPlan(rowId, id);
            });
          } else {
            const actionText =
              outcome === "Cancel" ? "MEMBATALKAN" : outcome.toUpperCase();
            const confirmationMessage = `<p class="text-sm text-center">Apakah Anda yakin ingin menyelesaikan trade ini dengan hasil <strong>${actionText}</strong>?</p>`;

            // --- PERBAIKAN DI SINI: Menambahkan parameter ke-4 untuk opsi edit ---
            showMessageBox(
              `Konfirmasi: ${outcome}`,
              detailsHtml + confirmationMessage,
              true,
              { editableNettValues: true, plan: planToConfirm }
            ).then((result) => {
              // --- DAN DI SINI: Menggunakan 'result' dari promise ---
              if (result.confirmed) {
                completeTrade(rowId, outcome, fromSection, result, id);
              }
            });
          }
        }
      };
      // --- ▲▲▲ HINGGA DI SINI ▲▲▲ ---

      // Pasang listener ke kedua tabel
      calculatedPlansBody.addEventListener("click", handleActionClick);
      runningPlansBody.addEventListener("click", handleActionClick);
      // --- HELPER FUNCTIONS ---
      // Modified formatNumber to control thousands grouping
      const formatNumber = (value, decimals = 2, useGrouping = true) => {
        if (isNaN(value) || value === null || !isFinite(value)) return "N/A";
        const num = parseFloat(value);
        if (useGrouping) {
          // Use toLocaleString for grouping (e.g., for currency, balance, etc.)
          return num.toLocaleString("en-US", {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals,
          });
        } else {
          // Use toFixed for raw numerical string with specified decimals, no grouping
          return num.toFixed(decimals);
        }
      };

      const formatCurrency = (value, currency = "USD") =>
        isNaN(value) || value === null || !isFinite(value)
          ? "N/A"
          : parseFloat(value).toLocaleString("en-US", {
              style: "currency",
              currency: currency,
              minimumFractionDigits: 2,
              maximumFractionDigits: 2,
            });
      const getColoredValueHtml = (value, isCurrency = false, decimals = 2) => {
        if (value === "N/A" || isNaN(value) || !isFinite(value))
          return `<span class="text-black">N/A</span>`;
        const formattedValue = isCurrency
          ? formatCurrency(value, "USD")
          : formatNumber(value, decimals);
        const colorClass = value >= 0 ? "text-black" : "text-red-500";
        return `<span class="${colorClass}">${formattedValue}</span>`;
      };
      function updateDateTime() {
        const now = new Date();
        const dateOptions = {
          weekday: "long",
          year: "numeric",
          month: "short",
          day: "numeric",
        };
        const timeOptions = {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: true,
        };
        const fullDateTimeString = `${now.toLocaleDateString(
          "id-ID",
          dateOptions
        )} ${now.toLocaleTimeString("id-ID", timeOptions)}`;

        document.getElementById("currentDate").textContent =
          now.toLocaleDateString("id-ID", dateOptions);
        document.getElementById("currentTime").textContent =
          now.toLocaleTimeString("id-ID", timeOptions);
        document.getElementById("currentDateHeader").textContent =
          now.toLocaleDateString("id-ID", dateOptions);
        document.getElementById("currentTimeHeader").textContent =
          now.toLocaleTimeString("id-ID", timeOptions);
        if (dailyChartDateTime)
          dailyChartDateTime.textContent = `(${fullDateTimeString})`;

        // Update date/time in mobile menu
        const mobileMenuDateTime =
          document.getElementById("mobileMenuDateTime");
        if (mobileMenuDateTime) {
          mobileMenuDateTime.textContent = fullDateTimeString;
        }
      }
      const getRandomColor = (index) =>
        `hsl(${(index * 137.508) % 360}, 70%, 50%)`;

      // --- HELPER FUNCTIONS ---
      // ... (existing helper functions like formatNumber, formatCurrency, getColoredValueHtml, updateDateTime, getRandomColor, getStepValue, getVisualPoints, showModal, hideModal, showMessageBox, updateActivePlansSummary) ...

      // PERBAIKAN: Memperbarui fungsi formatDuration untuk menampilkan "N/A" jika durasi 0
      function formatDuration(milliseconds) {
        if (isNaN(milliseconds) || milliseconds <= 0) return "N/A";
        const seconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
          return `${days} Hari`;
        } else if (hours > 0) {
          return `${hours} Jam`;
        } else if (minutes > 0) {
          return `${minutes} Menit`;
        } else if (seconds > 0) {
          return `${seconds} Detik`;
        }
        return "< 1 Detik"; // Default jika kurang dari 1 detik tapi lebih dari 0
      }

      /**
       * FUNGSI BARU: Memformat tanggal dan waktu ke dalam format dua baris HTML.
       * @param {string} isoString - Timestamp dalam format ISO.
       * @returns {string} String HTML dengan tanggal di atas dan waktu di bawah.
       */
      function formatDateAndTime(isoString) {
        if (!isoString || isNaN(new Date(isoString).getTime())) {
          return "N/A";
        }
        const date = new Date(isoString);
        // Opsi untuk mendapatkan format DD/MM/YYYY
        const dateOptions = {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
        };
        // Opsi untuk mendapatkan format HH:MM:SS
        const timeOptions = {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: false,
        };

        const formattedDate = date.toLocaleDateString("id-ID", dateOptions);
        // Mengganti titik dengan titik dua untuk konsistensi
        const formattedTime = date
          .toLocaleTimeString("id-ID", timeOptions)
          .replace(/\./g, ":");

        // Mengembalikan HTML dengan dua baris: tanggal di atas, waktu di bawah
        return `<div class="flex flex-col items-center">
                      <span class="text-xs text-gray-500">${formattedDate}</span>
                      <span class="font-medium">${formattedTime}</span>
                  </div>`;
      }
      // ... kode fungsi formatDateAndTime yang sudah ada ...

      /**
       * FUNGSI BARU UNTUK EKSPOR: Memformat tanggal dan waktu menjadi satu baris string.
       * @param {string} isoString - Timestamp dalam format ISO.
       * @returns {string} String yang diformat 'DD/MM/YYYY JJ:MM:DD'.
       */
      function formatDateAndTimeForExport(isoString) {
        if (!isoString || isNaN(new Date(isoString).getTime())) {
          return "N/A";
        }
        const date = new Date(isoString);
        const dateOptions = {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
        };
        const timeOptions = {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: false,
        };

        const formattedDate = date.toLocaleDateString("id-ID", dateOptions);
        const formattedTime = date
          .toLocaleTimeString("id-ID", timeOptions)
          .replace(/\./g, ":");

        return `${formattedDate} ${formattedTime}`;
      }

      // ... kode fungsi lainnya setelah ini ...

      // ... kode fungsi lainnya setelah ini ...

      /**
       * Mengambil semua data statistik yang terlihat di UI untuk keperluan ekspor.
       * Fungsi ini memastikan data yang diekspor sama persis dengan yang ditampilkan.
       * @returns {{summaryStats: Array<Array<string>>, riskStats: Array<Array<string>>}}
       */
      function getDetailedStatisticsForExport() {
        // Mengambil data dari bagian Statistik Ringkasan Keseluruhan
        const summaryStats = [
          [
            "Total Trade Selesai",
            document.getElementById("totalSettledTradesSummary").textContent,
          ],
          [
            "Probabilitas",
            document.getElementById("probabilitySummary").textContent,
          ],
          [
            "Total Pips/Points",
            document.getElementById("totalPipsSummary").textContent,
          ],
          [
            "Rata-rata % per Trade",
            document.getElementById("avgPercentagePerTradeSummary").textContent,
          ],
          [
            "Persentase Harian",
            document.getElementById("dailyPercentageSummary").textContent,
          ],
          [
            "Persentase Bulanan",
            document.getElementById("monthlyPercentageSummary").textContent,
          ],
          [
            "Persentase Tahunan",
            document.getElementById("yearlyPercentageSummary").textContent,
          ],
          [
            "Persentase Keseluruhan",
            document.getElementById("overallPercentageSummary").textContent,
          ],
          [
            "Saldo Akun Akhir",
            document.getElementById("finalBalanceSummary").textContent,
          ],
          [
            "Waktu Bergabung",
            document.getElementById("joinTimeSummary").textContent,
          ],
          [
            "Drawdown Saldo",
            `${
              document.getElementById("balanceDrawdownSummary").textContent
            } (${
              document.getElementById("balanceDrawdownSummaryPeriod")
                .textContent
            })`,
          ],
          [
            "Maksimum Drawdown %",
            `${
              document.getElementById("overallMaxDrawdownPercentage")
                .textContent
            } (${
              document.getElementById("overallMaxDrawdownPercentagePeriod")
                .textContent
            })`,
          ],
        ];

        // Mengambil data dari bagian Statistik Risiko dan Imbalan
        const riskStats = [
          [
            "Rata-rata Risiko dan Imbalan",
            document.getElementById("avgRiskReward").textContent,
          ],
          [
            "Rata-rata Sinyal Diselesaikan/Minggu",
            document.getElementById("avgSignalSettledWeek").textContent,
          ],
          [
            "Rata-rata Sinyal Diselesaikan/Bulan",
            document.getElementById("avgSignalSettledMonth").textContent,
          ],
          [
            "Rata-rata Periode Penahanan",
            document.getElementById("avgHoldingPeriod").textContent,
          ],
          [
            "Periode Penahanan Maks",
            document.getElementById("maxHoldingPeriod").textContent,
          ],
          [
            "Rata-rata Pips",
            document.getElementById("averagePips").textContent,
          ],
          [
            "Rata-rata TP Pips",
            document.getElementById("avgTpPips").textContent,
          ],
          ["Max TP Pips", document.getElementById("maxTpPips").textContent],
          [
            "Rata-rata SL Pips",
            document.getElementById("avgSlPips").textContent,
          ],
          ["Max SL Pips", document.getElementById("maxSlPips").textContent],
          [
            "Keuntungan Beruntun",
            `${document.getElementById("consecutiveProfit").textContent} (${
              document.getElementById("consecutiveProfitPeriod").textContent
            })`,
          ],
          [
            "Kerugian Beruntun",
            `${document.getElementById("consecutiveLoss").textContent} (${
              document.getElementById("consecutiveLossPeriod").textContent
            })`,
          ],
          [
            "Laba Kotor (Total TP)",
            document.getElementById("grossProfit").textContent,
          ],
          [
            "Laba Kotor (Total SL)",
            document.getElementById("grossLoss").textContent,
          ],
          ["Laba Bersih", document.getElementById("netProfit").textContent], // <-- DATA YANG HILANG SEKARANG DITAMBAHKAN
          [
            "Balance Drawdown Maximal",
            `${document.getElementById("maxBalanceDrawdown").textContent} (${
              document.getElementById("maxBalanceDrawdownPeriod").textContent
            })`,
          ],
          [
            "Balance Drawdown Monthly",
            `${
              document.getElementById("monthlyBalanceDrawdown").textContent
            } (${
              document.getElementById("monthlyBalanceDrawdownPeriod")
                .textContent
            })`,
          ],
          [
            "Maksimum Drawdown Bulanan %",
            `${
              document.getElementById("monthlyMaxDrawdownPercentage")
                .textContent
            } (${
              document.getElementById("monthlyMaxDrawdownPercentagePeriod")
                .textContent
            })`,
          ],
        ];

        return { summaryStats, riskStats };
      }
      // Fungsi pembantu baru untuk mengatur atribut step
      function getStepValue(decimals) {
        if (decimals <= 0) return "1"; // Untuk bilangan bulat
        return "0." + "0".repeat(decimals - 1) + "1";
      }

      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
      /**
       * PERBAIKAN: Fungsi ini sekarang memiliki aturan khusus untuk XAG/USD.
       * Untuk XAG/USD, nilai pips visual akan dikalikan 100 (menambahkan satu angka).
       * Untuk aset lain, tetap dikalikan 10.
       * @param {number} pipsValue The precise pips value (e.g., 12.5).
       * @param {string} symbol The asset symbol (e.g., 'XAG/USD').
       * @param {boolean} isForExecutedTable - Flag to determine display format.
       * @returns {{display: string, forCalc: number}} An object with the display string and the number for calculation.
       */
      function getVisualPoints(pipsValue, symbol, isForExecutedTable = false) {
        // 1. Tangani input yang tidak valid atau nol
        if (pipsValue === 0) {
          return { display: "0", forCalc: 0 };
        }
        if (isNaN(pipsValue) || pipsValue === null || !isFinite(pipsValue)) {
          return { display: "N/A", forCalc: 0 };
        }

        // 2. Ambil nilai absolut
        const floatValue = Math.abs(parseFloat(pipsValue));
        let finalValue;

        // 3. LOGIKA BARU: Terapkan aturan khusus untuk XAG/USD
        if (symbol === "XAG/USD") {
          // Untuk XAG/USD, kalikan 100 untuk menambahkan satu angka di belakang
          // Contoh: 12.5 -> 1250
          finalValue = Math.round(floatValue * 100);
        } else {
          // Untuk semua aset lainnya, gunakan logika standar (kalikan 10)
          // Contoh: 12.5 -> 125
          finalValue = Math.round(floatValue * 10);
        }

        // 4. Kembalikan nilai yang sudah diformat
        return { display: String(finalValue), forCalc: finalValue };
      }

      // Helper functions for modals
      function showModal(modalElement) {
        modalElement.classList.add("show");
      }
      function hideModal(modalElement) {
        modalElement.classList.remove("show");
      }

      // --- GANTI FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      /**
       * Menampilkan kotak pesan modal kustom yang serbaguna.
       * @param {string} title - Judul kotak pesan.
       * @param {string} message - Konten pesan utama, bisa berisi HTML.
       * @param {boolean} isConfirm - Menampilkan tombol Batal/Ya.
       * @param {Object} options - Opsi tambahan.
       * @param {boolean} options.editableNettValues - Jika true, tampilkan input untuk edit.
       * @param {Object} options.plan - Objek data 'plan' yang diperlukan untuk mengisi nilai placeholder.
       * @returns {Promise<Object>} Mengembalikan promise yang resolve dengan objek hasil konfirmasi.
       */
      function showMessageBox(title, message, isConfirm = false, options = {}) {
        return new Promise((resolve) => {
          const existingModal = document.querySelector(".message-box-modal");
          if (existingModal) existingModal.remove();

          let editableFieldsHtml = "";
          if (options.editableNettValues && options.plan) {
            const plan = options.plan;
            const assetData = getAssetData(plan.symbol);
            const stepValue = getStepValue(assetData.decimals);

            // --- PERBAIKAN UTAMA DIMULAI DI SINI ---
            editableFieldsHtml = `
                      <div class="mt-4 pt-4 border-t border-gray-200">
                          <h4 class="text-sm font-semibold text-center mb-3">Edit Manual Hasil Akhir (Opsional)</h4>
                          <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs">
                              <div>
                                  <label for="editedTpPrice" class="block mb-1 font-medium">TP Price</label>
                                  <input type="number" id="editedTpPrice" step="${stepValue}" class="w-full input-field" placeholder="${formatNumber(
              plan.tpPrice,
              assetData.decimals,
              false
            )}">
                              </div>
                              <div>
                                  <label for="editedNettSL" class="block mb-1 font-medium">Nett SL ($)</label>
                                  <input type="number" id="editedNettSL" step="0.01" class="w-full input-field" placeholder="${formatNumber(
                                    plan.nettSL,
                                    2,
                                    false
                                  )}">
                              </div>
                              <div>
                                  <label for="editedNettTP" class="block mb-1 font-medium">Nett TP ($)</label>
                                  <input type="number" id="editedNettTP" step="0.01" class="w-full input-field" placeholder="${formatNumber(
                                    plan.nettTP,
                                    2,
                                    false
                                  )}">
                              </div>
                          </div>
                      </div>
                  `;
            // --- AKHIR DARI PERBAIKAN ---
          }

          const modal = document.createElement("div");
          modal.className = "modal message-box-modal";
          modal.innerHTML = `
                  <div class="modal-content">
                      <button class="modal-close-button" id="closeMessageBoxBtn">&times;</button>
                      <h3 class="text-lg font-light text-primary mb-4">${title}</h3>
                      <!-- PERBAIKAN: Wrapper baru untuk semua konten yang dapat di-scroll -->
                      <div class="modal-body-scrollable">
                          <div class="text-gray-700 mb-6 font-light">${message}</div>
                          ${editableFieldsHtml}
                          <div class="flex justify-end gap-3 mt-6">
                              ${
                                isConfirm
                                  ? `
                                  <button id="cancelMessageBoxBtn" class="action-button bg-gray-500 hover:bg-gray-600 font-light">Batal</button>
                                  <button id="confirmMessageBoxBtn" class="action-button font-light">Ya</button>
                              `
                                  : `<button id="okMessageBoxBtn" class="action-button font-light">OK</button>`
                              }
                          </div>
                      </div>
                  </div>
              `;
          document.body.appendChild(modal);
          setTimeout(() => showModal(modal), 10);

          const hideAndResolve = (result) => {
            hideModal(modal);
            modal.addEventListener("transitionend", () => modal.remove(), {
              once: true,
            });
            resolve(result);
          };

          modal
            .querySelector("#closeMessageBoxBtn")
            ?.addEventListener("click", () =>
              hideAndResolve({ confirmed: false })
            );
          modal
            .querySelector("#okMessageBoxBtn")
            ?.addEventListener("click", () =>
              hideAndResolve({ confirmed: true })
            );
          modal
            .querySelector("#cancelMessageBoxBtn")
            ?.addEventListener("click", () =>
              hideAndResolve({ confirmed: false })
            );

          modal
            .querySelector("#confirmMessageBoxBtn")
            ?.addEventListener("click", () => {
              let result = { confirmed: true };
              if (options.editableNettValues) {
                // --- PERBAIKAN: Membaca nilai dari semua input, termasuk yang baru ---
                const editedTpPrice =
                  document.getElementById("editedTpPrice").value;
                const editedNettSL =
                  document.getElementById("editedNettSL").value;
                const editedNettTP =
                  document.getElementById("editedNettTP").value;

                if (editedTpPrice !== "")
                  result.editedTpPrice = parseFloat(editedTpPrice);
                if (editedNettSL !== "")
                  result.editedNettSL = parseFloat(editedNettSL);
                if (editedNettTP !== "")
                  result.editedNettTP = parseFloat(editedNettTP);
                // --- AKHIR DARI PERBAIKAN ---
              }
              hideAndResolve(result);
            });
        });
      }
      /**
       * PERBAIKAN: Fungsi untuk memperbarui ringkasan rencana aktif.
       */
      function updateActivePlansSummary() {
        const summaryContainer = document.getElementById("activePlansSummary");
        if (!summaryContainer) return;

        const totalSlPipsEl = document.getElementById("summaryTotalSlPips");
        const totalTpPipsEl = document.getElementById("summaryTotalTpPips");
        const totalRiskPercentageEl = document.getElementById(
          "summaryTotalRiskPercentage"
        );
        const totalNettSLEl = document.getElementById("summaryTotalNettSL");
        const totalNettTPEl = document.getElementById("summaryTotalNettTP");

        if (runningPlansData.length === 0) {
          summaryContainer.classList.add("hidden");
          return;
        }
        summaryContainer.classList.remove("hidden");

        let totalSlPips = 0;
        let totalTpPips = 0;
        let totalRiskPercentage = 0;
        let totalNettSL = 0;
        let totalNettTP = 0;

        runningPlansData.forEach((plan) => {
          // Gunakan poin visual untuk ringkasan agar sesuai dengan tabel
          totalSlPips += getVisualPoints(plan.slPips, plan.symbol).forCalc;
          totalTpPips += getVisualPoints(plan.tpPips, plan.symbol).forCalc;
          if (plan.rrPercentage && plan.rrPercentage.sl) {
            totalRiskPercentage += plan.rrPercentage.sl;
          }
          totalNettSL += plan.nettSL;
          totalNettTP += plan.nettTP;
        });

        totalSlPipsEl.textContent = formatNumber(totalSlPips, 0);
        totalTpPipsEl.textContent = formatNumber(totalTpPips, 0);
        totalRiskPercentageEl.textContent = `-${formatNumber(
          totalRiskPercentage,
          2
        )}%`;
        totalNettSLEl.textContent = formatCurrency(totalNettSL, "USD");
        totalNettTPEl.textContent = formatCurrency(totalNettTP, "USD");

        // PERBAIKAN: Pastikan Total SL Pips selalu berwarna merah
        totalSlPipsEl.className = "text-sm font-semibold mt-1 negative-value";
        totalTpPipsEl.className =
          "text-sm font-semibold mt-1 " +
          (totalTpPips > 0 ? "positive-value" : "negative-value");
        totalNettTPEl.className =
          "text-sm font-semibold mt-1 " +
          (totalNettTP > 0 ? "positive-value" : "negative-value");
      }
      // --- PERBAIKAN ---
      // Fungsi ini sekarang tidak lagi memerlukan 'uid' dan hanya memuat dari localStorage.
      function loadBannerPhotos() {
        console.log("Loading banner photos from localStorage.");
        try {
          // Cukup ambil data dari localStorage dan parse. Jika tidak ada, gunakan array kosong.
          bannerPhotos = JSON.parse(localStorage.getItem("bannerPhotos")) || [];
        } catch (e) {
          console.error("Error loading banner photos from localStorage:", e);
          bannerPhotos = []; // Jika ada error parsing, reset ke array kosong.
        }
        renderBannerGallery(); // Tampilkan gambar yang sudah dimuat.
      }

      /**
       * Menyimpan array foto banner saat ini ke localStorage.
       */
      function saveBannerPhotosToLocalStorage() {
        try {
          localStorage.setItem("bannerPhotos", JSON.stringify(bannerPhotos));
        } catch (e) {
          console.error("Error saving banner photos to localStorage:", e);
        }
      }

      // --- PERBAIKAN ---
      // Fungsi ini tidak lagi 'async' dan tidak memerlukan 'uid'.
      function saveBannerPhoto(imageDataUrl, index) {
        console.log(`Saving banner photo to localStorage at index ${index}.`);

        // Langsung tambahkan URL data base64 ke array.
        bannerPhotos[index] = imageDataUrl;

        // Panggil fungsi yang sudah ada untuk menyimpan array ke localStorage.
        saveBannerPhotosToLocalStorage();
      }

      // --- PERBAIKAN ---
      // Fungsi ini tidak lagi 'async' dan tidak memerlukan 'uid'.
      function deleteBannerPhoto(index) {
        if (index < 0 || index >= bannerPhotos.length) {
          console.error("Indeks tidak valid untuk menghapus foto banner.");
          return;
        }

        // Cukup hapus item dari array.
        bannerPhotos.splice(index, 1);

        // Simpan array yang sudah diperbarui ke localStorage.
        saveBannerPhotosToLocalStorage();
        console.log(
          `Banner photo at index ${index} deleted from localStorage.`
        );
      }

      /**
       * Menampilkan gambar di galeri banner 16:4.
       */
      function renderBannerGallery() {
        const bannerSlides = document.getElementById("bannerSlides");
        const bannerCounter = document.getElementById("bannerCounter");
        if (!bannerSlides || !bannerCounter) return;

        bannerSlides.innerHTML = ""; // Kosongkan slide

        if (bannerPhotos.length === 0) {
          bannerSlides.innerHTML = `<img src="https://placehold.co/1600x400/cccccc/ffffff?text=Click+%26+Hold+to+Add+Banner" alt="Placeholder Banner" class="w-full h-full object-cover">`;
          bannerCounter.classList.add("hidden");
          return;
        }

        bannerPhotos.forEach((url) => {
          const img = document.createElement("img");
          img.src = url;
          img.className = "w-full h-full object-cover flex-shrink-0";
          bannerSlides.appendChild(img);
        });

        bannerSlides.style.transform = `translateX(-${
          currentBannerPhotoIndex * 100
        }%)`;
        bannerCounter.textContent = `${currentBannerPhotoIndex + 1} / ${
          bannerPhotos.length
        }`;
        bannerCounter.classList.toggle("hidden", bannerPhotos.length <= 1);
      }

      /**
       * Pindah ke foto banner berikutnya, kembali ke awal jika sudah di akhir.
       */
      function showNextBannerPhoto() {
        if (bannerPhotos.length > 1) {
          currentBannerPhotoIndex =
            (currentBannerPhotoIndex + 1) % bannerPhotos.length;
          renderBannerGallery();
        }
      }

      /**
       * Memulai fungsi autoslide untuk banner.
       */
      function startBannerAutoslide() {
        // Hentikan interval sebelumnya jika ada
        if (bannerAutoslideInterval) {
          clearInterval(bannerAutoslideInterval);
        }
        // Mulai interval baru
        bannerAutoslideInterval = setInterval(showNextBannerPhoto, 30000); // 30 detik
      }

      // --- FIREBASE STORAGE FUNCTIONS ---
      async function loadProfilePictures(uid) {
        if (!storage) {
          console.warn(
            "Firebase Storage is not initialized. Using localStorage for photos."
          );
          loadPhotosFromLocalStorage();
          renderPhotoGallery();
          return;
        }

        let permissionErrorOccurred = false;
        userPhotos = [];
        const loadPromises = [];

        for (let i = 0; i < MAX_PHOTOS; i++) {
          const imageRef = ref(
            storage,
            `artifacts/${appId}/users/${uid}/profile_${i}.png`
          );
          loadPromises.push(
            getDownloadURL(imageRef)
              .then((url) => ({ url, index: i }))
              .catch((error) => {
                if (error.code === "storage/unauthorized") {
                  // Set flag jika terjadi error izin, jangan log di sini untuk menghindari spam.
                  permissionErrorOccurred = true;
                } else if (error.code !== "storage/object-not-found") {
                  // Log error lain yang tidak terduga, abaikan jika file tidak ditemukan (ini normal).
                  console.error(
                    `Error loading profile picture profile_${i}.png:`,
                    error
                  );
                }
                return null; // Kembalikan null untuk setiap kegagalan muat.
              })
          );
        }

        const results = await Promise.all(loadPromises);

        // Jika error izin terdeteksi, tangani sekarang secara terpusat.
        if (permissionErrorOccurred) {
          console.error(
            "Firebase Storage Permission Error: User does not have permission to access profile pictures. Please check your Firebase Storage Security Rules to ensure read access for authenticated users (e.g., 'allow read: if request.auth != null;'). Falling back to localStorage for photos."
          );
          loadPhotosFromLocalStorage(); // Fallback ke data lokal
          renderPhotoGallery();
          return; // Hentikan eksekusi lebih lanjut
        }

        // Jika tidak ada error izin, lanjutkan seperti biasa.
        results.forEach((result) => {
          if (result) {
            userPhotos[result.index] = result.url;
          }
        });
        userPhotos = userPhotos.filter((url) => url); // Bersihkan slot kosong
        console.log(
          "Profile pictures loaded from Firebase Storage:",
          userPhotos.length
        );
        renderPhotoGallery();
        savePhotosToLocalStorage(); // Sinkronkan dengan local storage
      }

      async function saveProfilePicture(uid, imageDataUrl, index) {
        if (!storage) {
          console.warn(
            "Firebase Storage is not initialized. Cannot save profile picture."
          );
          userPhotos[index] = imageDataUrl; // Update in memory
          savePhotosToLocalStorage(); // Fallback to local storage
          renderPhotoGallery();
          return;
        }
        try {
          const imageRef = ref(
            storage,
            `artifacts/${appId}/users/${uid}/profile_${index}.png`
          );
          const response = await fetch(imageDataUrl);
          const blob = await response.blob();
          await uploadBytes(imageRef, blob);

          // Update local state AFTER successful upload
          userPhotos[index] = imageDataUrl;
          console.log(
            `Profile picture profile_${index}.png saved to Firebase Storage.`
          );

          // --- PERBAIKAN DITAMBAHKAN DI SINI ---
          // Selalu sinkronkan dengan local storage setelah berhasil menyimpan ke Firebase.
          savePhotosToLocalStorage();
          // --- AKHIR PERBAIKAN ---

          showMessageBox("Berhasil", "Foto profil berhasil disimpan.", false);
          renderPhotoGallery(); // Update display after successful save
        } catch (error) {
          if (error.code === "storage/unauthorized") {
            console.error(
              "Firebase Storage Permission Error: User does not have permission to save profile picture. Please check your Firebase Storage Security Rules to ensure write access for authenticated users (e.g., 'allow write: if request.auth != null;').",
              error
            );
            showMessageBox(
              "Gagal",
              "Tidak ada izin untuk menyimpan foto. Periksa aturan keamanan Firebase Anda.",
              false
            );
          } else {
            console.error(
              `Error saving profile picture profile_${index}.png to Firebase:`,
              error
            );
            showMessageBox(
              "Gagal",
              "Terjadi kesalahan saat menyimpan foto. Silakan coba lagi.",
              false
            );
          }
        }
      }

      async function deleteProfilePicture(uid, indexToDelete) {
        if (!storage) {
          console.warn(
            "Firebase Storage is not initialized. Cannot delete profile picture."
          );
          userPhotos.splice(indexToDelete, 1); // Remove from array
          savePhotosToLocalStorage(); // Fallback to local storage
          renderPhotoGallery();
          return;
        }
        try {
          const imageRef = ref(
            storage,
            `artifacts/${appId}/users/${uid}/profile_${indexToDelete}.png`
          );
          await deleteObject(imageRef);
          console.log(
            `Profile picture profile_${indexToDelete}.png deleted from Firebase Storage.`
          );
          userPhotos.splice(indexToDelete, 1); // Remove from array
          // Re-index remaining photos in Firebase storage to fill the gap
          for (let i = indexToDelete; i < userPhotos.length; i++) {
            const oldRef = ref(
              storage,
              `artifacts/${appId}/users/${uid}/profile_${i + 1}.png`
            );
            const newRef = ref(
              storage,
              `artifacts/${appId}/users/${uid}/profile_${i}.png`
            );
            // This is a workaround as Firebase Storage doesn't have a direct "rename" or "move" operation.
            // We re-upload the next image to the current slot and then delete the old one.
            try {
              const url = await getDownloadURL(oldRef);
              const response = await fetch(url);
              const blob = await await response.blob();
              await uploadBytes(newRef, blob);
              await deleteObject(oldRef);
              userPhotos[i] = url; // Update local array with the moved image
            } catch (error) {
              if (error.code === "storage/object-not-found") {
                // No next image to shift, stop re-indexing
                break;
              } else {
                console.error(
                  `Error re-indexing photo from ${i + 1} to ${i}:`,
                  error
                );
              }
            }
          }
          // Finally, delete the last photo if it was shifted
          if (userPhotos.length < MAX_PHOTOS) {
            // Check if there's a potential leftover at the end
            const lastPossibleRef = ref(
              storage,
              `artifacts/${appId}/users/${uid}/profile_${userPhotos.length}.png`
            );
            try {
              await deleteObject(lastPossibleRef);
            } catch (error) {
              if (error.code === "storage/object-not-found") {
                /* fine */
              } else {
                console.error("Error deleting last shifted photo:", error);
              }
            }
          }
          savePhotosToLocalStorage(); // Keep local storage in sync
          renderPhotoGallery();
        } catch (error) {
          console.error(
            "Error deleting profile picture from Firebase Storage:",
            error
          );
          // Even if Firebase delete fails, try to update local storage and re-render
          userPhotos.splice(indexToDelete, 1);
          savePhotosToLocalStorage();
          renderPhotoGallery();
        }
      }

      // --- FIREBASE FIRESTORE FUNCTIONS (No changes needed here for photo functionality) ---

      async function saveCalculatedPlan(uid, plan) {
        if (!db) return;
        try {
          await setDoc(
            doc(
              db,
              `artifacts/${appId}/users/${uid}/calculatedPlans`,
              plan.rowId
            ),
            plan
          );
          console.log("Calculated plan saved to Firestore:", plan.rowId);
        } catch (error) {
          console.error("Error saving calculated plan to Firestore:", error);
        }
      }

      async function deleteCalculatedPlan(uid, rowId) {
        if (!db) return;
        try {
          await deleteDoc(
            doc(db, `artifacts/${appId}/users/${uid}/calculatedPlans`, rowId)
          );
          console.log("Calculated plan deleted from Firestore:", rowId);
        } catch (error) {
          console.error(
            "Error deleting calculated plan from Firestore:",
            error
          );
        }
      }

      async function loadRunningPlans(uid) {
        if (!db) return;
        try {
          const q = query(
            collection(db, `artifacts/${appId}/users/${uid}/runningPlans`)
          );
          onSnapshot(
            q,
            (snapshot) => {
              runningPlansData = snapshot.docs.map((doc) => {
                const data = doc.data();
                data.assetData = getAssetData(data.symbol);
                return data;
              });
              console.log(
                "Running plans loaded from Firestore:",
                runningPlansData.length
              );
              renderRunningPlans();
              saveDataToLocalStorage(); // Keep local storage in sync
            },
            (error) => {
              console.error(
                "Error listening to running plans from Firestore:",
                error
              );
            }
          );
        } catch (error) {
          console.error(
            "Error setting up Firestore listener for running plans:",
            error
          );
        }
      }

      async function updatePrice(
        id,
        tpPrice,
        NettSL,
        NetTP,
        slPercentage,
        tpPercentage,
        RrPips,
        TpPips,
        slPips
      ) {
        try {
          await fetch("http://101.50.2.92:4578/api/trade/price", {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
            body: JSON.stringify({
              id,
              tpPrice,
              NettSL,
              NetTP,
              slPercentage,
              tpPercentage,
              RrPips,
              TpPips,
              slPips,
            }),
          });
        } catch (error) {
          console.error("Error updating price to backend:", error);
        }
      }

      async function saveRunningPlan(
        id,
        status = "RUNNING",
        outcome = null,
        exitTime = null,
        originalTpPrice = null,
        originalNettSL = null,
        originalNettTP = null,
        originalrrSlPercentage = null,
        originalrrTpPercentage = null,
        originalRrPips = null,
        originalTpPips = null,
        originalSlPips = null
      ) {
        try {
          await fetch("http://101.50.2.92:4578/api/trade", {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
            body: JSON.stringify({
              id,
              status,
              outcome,
              exitTime,
              originalTpPrice,
              originalNettSL,
              originalNettTP,
              originalrrSlPercentage,
              originalrrTpPercentage,
              originalRrPips,
              originalTpPips,
              originalSlPips,
            }),
          });
        } catch (error) {
          console.error("Error saving running plan to Firestore:", error);
        }
      }

      async function deleteRunningPlan(uid, id) {
        try {
          await fetch(`http://101.50.2.92:4578/api/trade/${id}`, {
            method: "DELETE",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });
          console.log("Running plan deleted from Firestore:", rowId);
        } catch (error) {
          console.error("Error deleting running plan from Firestore:", error);
        }
      }

      // --- PERBAIKAN STRUKTURAL: FUNGSI loadExecutedPlans YANG SUDAH DIBERSIHKAN ---
      async function loadExecutedPlans(uid) {
        if (!db) {
          console.warn(
            "Firestore is not initialized. Cannot load executed plans."
          );
          await initializeAppFromLocalStorage(); // Fallback jika DB tidak ada
          return;
        }
        try {
          const q = query(
            collection(db, `artifacts/${appId}/users/${uid}/executedPlans`)
          );
          onSnapshot(
            q,
            (snapshot) => {
              const plans = snapshot.docs.map((doc) => {
                const data = doc.data();
                data.assetData = getAssetData(data.symbol);
                return data;
              });

              executedPlansData = plans.sort(
                (a, b) => new Date(a.timestamp) - new Date(b.timestamp)
              );
              console.log(
                "Executed plans loaded from Firestore:",
                executedPlansData.length
              );

              // Alur yang Benar: Render tabel, lalu hitung semua statistik & ringkasan
              renderExecutedPlans();
              calculateSummaryStatistics();
              updateRiskRewardStatistics();
              calculateAndRenderMonthlyPLSummary();
              calculateAndRenderDailySummary();
              calculateAndRenderWeeklySummary();
              calculateAndRenderNewMonthlySummary();
              calculateAndRenderYearlySummary();
              fetchAndRenderOutcomeRadarChart();
              fetchAndRenderCombinedCumulativeChart();
              // --- AKHIR PERBAIKAN ---

              saveDataToLocalStorage();
            },
            (error) => {
              console.error(
                "Error listening to executed plans from Firestore:",
                error
              );
            }
          );
        } catch (error) {
          console.error(
            "Error setting up Firestore listener for executed plans:",
            error
          );
          await initializeAppFromLocalStorage(); // Fallback jika setup listener gagal
        }
      }

      async function saveExecutedPlan(uid, plan) {
        if (!db) {
          console.warn(
            "Firestore is not initialized. Cannot save executed plan."
          );
          return;
        }
        try {
          await addDoc(
            collection(db, `artifacts/${appId}/users/${uid}/executedPlans`),
            plan
          );
          console.log("Executed plan saved to Firestore.");
        } catch (error) {
          console.error("Error saving executed plan to Firestore:", error);
        }
      }

      async function deleteAllExecutedPlans() {
        try {
          await fetch("http://101.50.2.92:4578/api/trade/all", {
            method: "DELETE",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });
        } catch (error) {
          console.error(
            "Error deleting all executed plans from Firestore:",
            error
          );
        }
      }

      async function deleteAllCalculatedPlans(uid) {
        if (!db) return;
        try {
          const q = query(
            collection(db, `artifacts/${appId}/users/${uid}/calculatedPlans`)
          );
          const snapshot = await getDocs(q);
          const deletePromises = snapshot.docs.map((doc) => deleteDoc(doc.ref));
          await Promise.all(deletePromises);
          console.log("All calculated plans deleted from Firestore.");
        } catch (error) {
          console.error(
            "Error deleting all calculated plans from Firestore:",
            error
          );
        }
      }

      // --- LOCAL STORAGE FUNCTIONS (Used as fallback if Firebase is not configured or fails) ---
      function saveDataToLocalStorage() {
        try {
          localStorage.setItem(
            "calculatedPlansData",
            JSON.stringify(calculatedPlansData)
          );
          localStorage.setItem(
            "runningPlansData",
            JSON.stringify(runningPlansData)
          );
          localStorage.setItem(
            "executedPlansData",
            JSON.stringify(executedPlansData)
          );
          console.log("Data saved to localStorage.");
        } catch (e) {
          console.error("Error saving to localStorage:", e);
        }
      }
      async function loadDataFromLocalStorage() {
        try {
          const response = await fetch("http://101.50.2.92:4578/api/trade", {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });

          if (!response.ok) {
            console.error("Fetch failed:", response.status);
            return;
          }

          const res = await response.json();

          calculatedPlansData = res.calculated || [];
          runningPlansData = res.running || [];
          executedPlansData = res.executed || [];

          console.log("Data loaded:", {
            calculated: calculatedPlansData.length,
            running: runningPlansData.length,
            executed: executedPlansData.length,
          });
        } catch (e) {
          console.error("Error loading data:", e);
        }
      }

      // --- Photo Local Storage (separate for photos) ---
      function savePhotosToLocalStorage() {
        try {
          localStorage.setItem("userPhotos", JSON.stringify(userPhotos));
          console.log("Photos saved to localStorage.");
        } catch (e) {
          console.error("Error saving photos to localStorage:", e);
        }
      }

      function loadPhotosFromLocalStorage() {
        try {
          userPhotos = JSON.parse(localStorage.getItem("userPhotos")) || [];
          console.log("Photos loaded from localStorage:", userPhotos.length);
        } catch (e) {
          console.error("Error loading photos from localStorage:", e);
          userPhotos = [];
        }
      }

      // --- Simulator Local Storage ---
      function saveSimulatorData() {
        try {
          const simData = {
            balance: document.getElementById("simBalance").value,
            risk: document.getElementById("simRiskPerTrade").value,
            target: document.getElementById("simMonthlyTarget").value,
            period: document.getElementById("simPeriod").value,
          };
          localStorage.setItem(
            "compoundingSimulatorData",
            JSON.stringify(simData)
          );
        } catch (e) {
          console.error("Error saving simulator data to localStorage:", e);
        }
      }

      function loadSimulatorData() {
        try {
          const simData = JSON.parse(
            localStorage.getItem("compoundingSimulatorData")
          );
          if (simData) {
            document.getElementById("simBalance").value = simData.balance || "";
            document.getElementById("simRiskPerTrade").value =
              simData.risk || "";
            document.getElementById("simMonthlyTarget").value =
              simData.target || "";
            document.getElementById("simPeriod").value = simData.period || "";
          }
        } catch (e) {
          console.error("Error loading simulator data from localStorage:", e);
        }
      }

      // --- Input Rows Local Storage ---
      function saveInputRowsToLocalStorage() {
        try {
          const inputRows = document.querySelectorAll(".input-row");
          const dataToSave = [];
          inputRows.forEach((row) => {
            const rowId = row.id.split("-")[1];
            const rowData = {
              symbol: row.querySelector(`#symbol-${rowId}`).value,
              tradeType: row
                .querySelector(`#buyBtn-${rowId}`)
                .classList.contains("active")
                ? "BUY"
                : "SELL",
              balance: row.querySelector(`#balance-${rowId}`).value,
              riskPercent: row.querySelector(`#riskPercent-${rowId}`).value,
              priceNow: row.querySelector(`#priceNow-${rowId}`).value,
              openPrice: row.querySelector(`#openPrice-${rowId}`).value,
              slPrice: row.querySelector(`#slPrice-${rowId}`).value,
              tpPrice: row.querySelector(`#tpPrice-${rowId}`).value,
              note: row.querySelector(`#note-${rowId}`).value,
            };
            dataToSave.push(rowData);
          });
          localStorage.setItem(
            "calculatorInputRows",
            JSON.stringify(dataToSave)
          );
        } catch (e) {
          console.error("Error saving input rows to localStorage:", e);
        }
      }

      function loadInputRowsFromLocalStorage() {
        try {
          const savedRows = JSON.parse(
            localStorage.getItem("calculatorInputRows")
          );
          if (savedRows && savedRows.length > 0) {
            inputRowsContainer.innerHTML = ""; // Clear any default rows
            savedRows.forEach((rowData) => addInputRow(rowData));
            return true; // Indicate that data was loaded
          }
          return false; // No data found
        } catch (e) {
          console.error("Error loading input rows from localStorage:", e);
          return false;
        }
      }

      // --- CHART.JS RENDERING FUNCTIONS (simplified error/loading handling) ---
      const setupChartContainer = (canvasId, loadingId, errorId, noDataId) => {
        const canvas = document.getElementById(canvasId);
        const loading = document.getElementById(loadingId);
        const error = document.getElementById(errorId);
        const noData = document.getElementById(noDataId);
        loading.classList.remove("hidden");
        error.classList.add("hidden");
        noData.classList.add("hidden");
        canvas.style.display = "none";
        return { canvas, loading, error, noData };
      };

      // --- ▼▼▼ GANTI SELURH FUNGSI LAMA INI DENGAN VERSI BARU ▼▼▼ ---

      const handleChartData = (
        data,
        { canvas, loading, error, noData },
        chartInstanceRef,
        chartType,
        options
      ) => {
        loading.classList.add("hidden");
        // Check if data is empty or if all values are zero for pie chart
        if (
          data.labels.length === 0 ||
          (chartType === "pie" &&
            data.datasets &&
            data.datasets.length > 0 &&
            data.datasets[0].data.every((val) => val === 0))
        ) {
          noData.classList.remove("hidden");
          canvas.style.display = "none";
          return false;
        }

        // --- PERBAIKAN UTAMA DI SINI ---
        // Secara eksplisit hancurkan chart yang ada di kanvas ini, jika ada.
        // Ini adalah cara paling andal untuk mencegah error "Canvas is already in use",
        // terlepas dari status variabel global yang kita lacak.
        const existingChart = Chart.getChart(canvas);
        if (existingChart) {
          existingChart.destroy();
        }
        // --- AKHIR PERBAIKAN ---

        canvas.style.display = "block";

        // Buat instance chart baru dan perbarui referensi global melalui setter.
        // Pengecekan lama (if (chartInstanceRef.chart)...) dihapus karena sudah ditangani di atas.
        chartInstanceRef.chart = new Chart(canvas, {
          type: chartType,
          data: { labels: data.labels, datasets: data.datasets },
          options,
        });

        return true;
      };

      // --- ▲▲▲ HINGGA DI SINI ▲▲▲ ---

      // --- LETAKKAN 5 FUNGSI YANG SUDAH DIPERBAIKI DI SINI ---

      // --- GANTI SEMUA FUNGSI GRAFIK (fetchAndRender...) DENGAN BLOK DI BAWAH INI ---

      async function fetchAndRenderPieChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "assetSuccessPieChart",
          "pieChartLoading",
          "pieChartError",
          "pieChartNoData"
        );
        try {
          const takeProfitTradesByAsset = {};
          let totalTakeProfitTrades = 0;

          // PERBAIKAN: Menggunakan helper getTradeResult
          executedPlansData.forEach((trade) => {
            if (getTradeResult(trade).isWin) {
              takeProfitTradesByAsset[trade.symbol] =
                (takeProfitTradesByAsset[trade.symbol] || 0) + 1;
              totalTakeProfitTrades++;
            }
          });

          if (totalTakeProfitTrades === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: assetPieChart,
                set chart(c) {
                  assetPieChart = c;
                },
              },
              "pie",
              {}
            );
            return;
          }

          const labels = [],
            data = [],
            backgroundColors = [];
          let colorIndex = 0;
          for (const symbol in takeProfitTradesByAsset) {
            const percentage =
              (takeProfitTradesByAsset[symbol] / totalTakeProfitTrades) * 100;
            labels.push(`${symbol} (${formatNumber(percentage, 2)}%)`);
            data.push(percentage);
            backgroundColors.push(getRandomColor(colorIndex++));
          }

          handleChartData(
            {
              labels,
              datasets: [
                {
                  data,
                  backgroundColor: backgroundColors,
                  hoverOffset: 10,
                  borderColor: "#fff",
                  borderWidth: 2,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: assetPieChart,
              set chart(c) {
                assetPieChart = c;
              },
            },
            "pie",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: {
                  display: true,
                  position: "bottom",
                  labels: {
                    color: "#333",
                    font: { family: "Inter", size: 10, weight: "300" },
                    padding: 15,
                    boxWidth: 12,
                  },
                },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      `${ctx.label || ""}: ${formatNumber(ctx.raw, 2)}%`,
                  },
                  spacing: 10,
                },
              },
            }
          );
        } catch (err) {
          console.error("Error pie chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data grafik: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderDailyLineChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "dailyLineChart",
          "dailyLineChartLoading",
          "dailyLineChartError",
          "dailyLineChartNoData"
        );
        try {
          const now = new Date();
          const todayStart = new Date(
            now.getFullYear(),
            now.getMonth(),
            now.getDate(),
            0,
            0,
            0
          ).getTime();

          // PERBAIKAN: Filter dan urutkan data
          const tradesToday = executedPlansData
            .filter(
              (trade) =>
                getTradeResult(trade).isValid &&
                new Date(trade.timestamp).getTime() >= todayStart
            )
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (tradesToday.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: dailyLineChart,
                set chart(c) {
                  dailyLineChart = c;
                },
              },
              "line",
              {}
            );
            return;
          }

          const initialBalanceForTheDay = tradesToday[0].balance;
          let cumulativePLForTheDay = 0;
          const labels = ["Mulai"],
            data = [0];

          tradesToday.forEach((trade) => {
            cumulativePLForTheDay += getTradeResult(trade).profitLoss;
            const currentCumulativePercentage =
              initialBalanceForTheDay > 0
                ? (cumulativePLForTheDay / initialBalanceForTheDay) * 100
                : 0;
            labels.push(
              new Date(trade.timestamp).toLocaleString("id-ID", {
                hour: "2-digit",
                minute: "2-digit",
              })
            );
            data.push(currentCumulativePercentage);
          });

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Persentase Harian",
                  data,
                  borderColor: "#222",
                  backgroundColor: "rgba(34, 34, 34, 0.1)",
                  fill: true,
                  tension: 0.3,
                  borderWidth: 1,
                  pointRadius: 3,
                  pointBackgroundColor: "#222",
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: dailyLineChart,
              set chart(c) {
                dailyLineChart = c;
              },
            },
            "line",
            {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      ctx.dataset.label + ": " + formatNumber(ctx.raw, 2) + "%",
                  },
                },
              },
              scales: {
                x: { ticks: { font: { size: 7 } } },
                y: {
                  ticks: {
                    callback: (val) => formatNumber(val, 2) + "%",
                    font: { size: 7 },
                  },
                },
              },
            }
          );
        } catch (err) {
          console.error("Error daily line chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderMonthlyBarChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "monthlyBarChart",
          "monthlyBarChartLoading",
          "monthlyBarChartError",
          "monthlyBarChartNoData"
        );
        try {
          // PERBAIKAN: Filter dan urutkan data
          const relevantTrades = executedPlansData
            .filter((trade) => getTradeResult(trade).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (relevantTrades.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: monthlyBarChart,
                set chart(c) {
                  monthlyBarChart = c;
                },
              },
              "bar",
              {}
            );
            return;
          }

          const monthlyStatsMap = {};

          relevantTrades.forEach((trade) => {
            const monthYear = new Date(trade.timestamp).toLocaleString(
              "id-ID",
              { month: "long", year: "numeric" }
            );
            if (!monthlyStatsMap[monthYear]) {
              const firstTradeOfMonth = relevantTrades.find(
                (t) =>
                  new Date(t.timestamp).toLocaleString("id-ID", {
                    month: "long",
                    year: "numeric",
                  }) === monthYear
              );
              monthlyStatsMap[monthYear] = {
                monthlyPL: 0,
                initialBalance: firstTradeOfMonth
                  ? firstTradeOfMonth.balance
                  : 0,
              };
            }
            monthlyStatsMap[monthYear].monthlyPL +=
              getTradeResult(trade).profitLoss;
          });

          const labels = Object.keys(monthlyStatsMap).sort(
            (a, b) => new Date(`01 ${a}`) - new Date(`01 ${b}`)
          );
          const data = labels.map((my) => {
            const monthData = monthlyStatsMap[my];
            return monthData.initialBalance > 0
              ? (monthData.monthlyPL / monthData.initialBalance) * 100
              : 0;
          });

          const backgroundColors = data.map((val) =>
            val >= 0 ? "rgba(34, 34, 34, 0.8)" : "rgba(220, 53, 69, 0.8)"
          );
          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Perubahan Bulanan",
                  data,
                  backgroundColor: backgroundColors,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: monthlyBarChart,
              set chart(c) {
                monthlyBarChart = c;
              },
            },
            "bar",
            {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      ctx.dataset.label + ": " + formatNumber(ctx.raw, 2) + "%",
                  },
                },
              },
              scales: {
                y: { ticks: { callback: (val) => formatNumber(val, 2) + "%" } },
              },
            }
          );
        } catch (err) {
          console.error("Error monthly bar chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderOverallPercentageCumulativeChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "overallPercentageCumulativeChart",
          "overallPercentageCumulativeChartLoading",
          "overallPercentageCumulativeChartError",
          "overallPercentageCumulativeChartNoData"
        );

        const lastExecDateEl = document.getElementById(
          "lastExecDate_Percentage"
        );
        const finalValueEl = document.getElementById("finalValue_Percentage");
        const assetListEl = document.getElementById("assetList_Percentage");

        try {
          const sortedTrades = [...executedPlansData]
            .filter((t) => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            lastExecDateEl.textContent = "Bulan & Tahun: N/A";
            finalValueEl.textContent = "0.00%";
            assetListEl.textContent = "N/A";
            finalValueEl.classList.remove("positive-value", "negative-value");
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: overallPercentageCumulativeChart,
                set chart(c) {
                  overallPercentageCumulativeChart = c;
                },
              },
              "line",
              {}
            );
            return;
          }

          const actualLabels = [],
            actualData = [];
          let initialBalance = sortedTrades[0].balance;
          let currentBalance = initialBalance;

          actualLabels.push("Mulai");
          actualData.push(0);

          sortedTrades.forEach((trade) => {
            currentBalance += getTradeResult(trade).isWin
              ? trade.nettTP
              : trade.nettSL;
            actualLabels.push(
              new Date(trade.timestamp).toLocaleString("id-ID", {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              })
            );
            actualData.push(
              initialBalance > 0
                ? ((currentBalance - initialBalance) / initialBalance) * 100
                : 0
            );
          });

          const lastTrade = sortedTrades[sortedTrades.length - 1];
          const lastDate = new Date(lastTrade.timestamp);
          lastExecDateEl.textContent = `Eksekusi Terakhir: ${lastDate.toLocaleString(
            "id-ID",
            { month: "long", year: "numeric" }
          )}`;

          const finalValue = actualData[actualData.length - 1];
          finalValueEl.textContent = `${formatNumber(finalValue, 2)}%`;
          finalValueEl.classList.toggle("positive-value", finalValue >= 0);
          finalValueEl.classList.toggle("negative-value", finalValue < 0);

          const uniqueAssets = [
            ...new Set(
              executedPlansData
                .filter((t) => getTradeResult(t).isValid)
                .map((trade) => trade.symbol)
            ),
          ];
          assetListEl.textContent = uniqueAssets.join(", ");

          const { projectionLabels, projectionData } =
            calculateProjectionData("percentage");
          const combinedLabels = [...actualLabels, ...projectionLabels];
          const actualDataset = {
            label: "Persentase Aktual",
            data: actualData,
            borderColor: "#007bff",
            backgroundColor: "rgba(0, 123, 255, 0.1)",
            fill: true,
            tension: 0.3,
            borderWidth: 1.5,
            pointRadius: 2,
            pointBackgroundColor: "#007bff",
          };
          const projectionDataset = {
            label: "Proyeksi",
            data: [
              ...new Array(actualData.length - 1).fill(null),
              actualData[actualData.length - 1],
              ...projectionData,
            ],
            borderColor: "rgba(0, 123, 255, 0.5)",
            borderDash: [5, 5],
            fill: false,
            tension: 0.3,
            borderWidth: 1.5,
            pointRadius: 2,
            pointBackgroundColor: "rgba(0, 123, 255, 0.5)",
          };
          const datasets = [actualDataset];
          if (projectionData.length > 0) datasets.push(projectionDataset);

          const scalesConfig = getResponsiveChartScales(
            combinedLabels,
            "Persentase Kumulatif (%)",
            (val) => formatNumber(val, 2) + "%"
          );
          handleChartData(
            { labels: combinedLabels, datasets },
            { canvas, loading, error, noData },
            {
              chart: overallPercentageCumulativeChart,
              set chart(c) {
                overallPercentageCumulativeChart = c;
              },
            },
            "line",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 1000, easing: "easeOutQuart" },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      ctx.dataset.label + ": " + formatNumber(ctx.raw, 2) + "%",
                  },
                },
              },
              scales: scalesConfig,
            }
          );
        } catch (err) {
          console.error("Error overall cumulative percentage chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data grafik: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderOverallBalanceCumulativeChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "overallBalanceCumulativeChart",
          "overallBalanceCumulativeChartLoading",
          "overallBalanceCumulativeChartError",
          "overallBalanceCumulativeChartNoData"
        );

        const lastExecDateEl = document.getElementById("lastExecDate_Balance");
        const finalValueEl = document.getElementById("finalValue_Balance");
        const assetListEl = document.getElementById("assetList_Balance");

        try {
          const sortedTrades = [...executedPlansData]
            .filter((t) => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            lastExecDateEl.textContent = "Bulan & Tahun: N/A";
            finalValueEl.textContent = formatCurrency(0);
            assetListEl.textContent = "N/A";
            finalValueEl.classList.remove("positive-value", "negative-value");
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: overallBalanceCumulativeChart,
                set chart(c) {
                  overallBalanceCumulativeChart = c;
                },
              },
              "line",
              {}
            );
            return;
          }

          const actualLabels = [],
            actualData = [];
          let currentBalance = sortedTrades[0].balance;

          actualLabels.push("Mulai");
          actualData.push(currentBalance);

          sortedTrades.forEach((trade) => {
            currentBalance += getTradeResult(trade).isWin
              ? trade.nettTP
              : trade.nettSL;
            actualLabels.push(
              new Date(trade.timestamp).toLocaleString("id-ID", {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              })
            );
            actualData.push(currentBalance);
          });

          const lastTrade = sortedTrades[sortedTrades.length - 1];
          const lastDate = new Date(lastTrade.timestamp);
          lastExecDateEl.textContent = `Eksekusi Terakhir: ${lastDate.toLocaleString(
            "id-ID",
            { month: "long", year: "numeric" }
          )}`;

          const finalValue = actualData[actualData.length - 1];
          const initialBalance = actualData[0];
          finalValueEl.textContent = formatCurrency(finalValue, "USD");
          finalValueEl.classList.toggle(
            "positive-value",
            finalValue >= initialBalance
          );
          finalValueEl.classList.toggle(
            "negative-value",
            finalValue < initialBalance
          );

          const uniqueAssets = [
            ...new Set(
              executedPlansData
                .filter((t) => getTradeResult(t).isValid)
                .map((trade) => trade.symbol)
            ),
          ];
          assetListEl.textContent = uniqueAssets.join(", ");

          const { projectionLabels, projectionData } =
            calculateProjectionData("balance");
          const combinedLabels = [...actualLabels, ...projectionLabels];
          const actualDataset = {
            label: "Saldo Aktual",
            data: actualData,
            borderColor: "#dc3545",
            backgroundColor: "rgba(220, 53, 69, 0.1)",
            fill: true,
            tension: 0.3,
            borderWidth: 1.5,
            pointRadius: 2,
            pointBackgroundColor: "#dc3545",
          };
          const projectionDataset = {
            label: "Proyeksi",
            data: [
              ...new Array(actualData.length - 1).fill(null),
              actualData[actualData.length - 1],
              ...projectionData,
            ],
            borderColor: "rgba(220, 53, 69, 0.5)",
            borderDash: [5, 5],
            fill: false,
            tension: 0.3,
            borderWidth: 1.5,
            pointRadius: 2,
            pointBackgroundColor: "rgba(220, 53, 69, 0.5)",
          };
          const datasets = [actualDataset];
          if (projectionData.length > 0) datasets.push(projectionDataset);

          const scalesConfig = getResponsiveChartScales(
            combinedLabels,
            "Saldo Akun ($)",
            (val) => formatCurrency(val, "USD")
          );
          handleChartData(
            { labels: combinedLabels, datasets },
            { canvas, loading, error, noData },
            {
              chart: overallBalanceCumulativeChart,
              set chart(c) {
                overallBalanceCumulativeChart = c;
              },
            },
            "line",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 1000, easing: "easeOutQuart" },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      ctx.dataset.label + ": " + formatCurrency(ctx.raw, "USD"),
                  },
                },
              },
              scales: scalesConfig,
            }
          );
        } catch (err) {
          console.error("Error overall cumulative balance chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data grafik: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderOverallPipsCumulativeChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "overallPipsCumulativeChart",
          "overallPipsCumulativeChartLoading",
          "overallPipsCumulativeChartError",
          "overallPipsCumulativeChartNoData"
        );

        // Ambil elemen UI baru
        const lastExecDateEl = document.getElementById("lastExecDate_Pips");
        const finalValueEl = document.getElementById("finalValue_Pips");
        const assetListEl = document.getElementById("assetList_Pips");

        try {
          const sortedTrades = executedPlansData
            .filter((t) => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            // Reset info jika tidak ada data
            lastExecDateEl.textContent = "Bulan & Tahun: N/A";
            finalValueEl.textContent = "0";
            assetListEl.textContent = "N/A";
            finalValueEl.classList.remove("positive-value", "negative-value");
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: overallPipsCumulativeChart,
                set chart(c) {
                  overallPipsCumulativeChart = c;
                },
              },
              "line",
              {}
            );
            return;
          }

          const labels = [],
            data = [];
          let currentCumulativePoints = 0;

          // Tambahkan titik awal
          labels.push("Mulai");
          data.push(0);

          sortedTrades.forEach((trade) => {
            const pointsForTrade = getTradeResult(trade).isWin
              ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
              : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;
            currentCumulativePoints += pointsForTrade;
            labels.push(
              new Date(trade.timestamp).toLocaleString("id-ID", {
                day: "numeric",
                month: "short",
                year: "numeric",
                hour: "2-digit",
                minute: "2-digit",
              })
            );
            data.push(currentCumulativePoints);
          });

          // Update Info Tambahan
          const lastTrade = sortedTrades[sortedTrades.length - 1];
          const lastDate = new Date(lastTrade.timestamp);
          lastExecDateEl.textContent = `Eksekusi Terakhir: ${lastDate.toLocaleString(
            "id-ID",
            { month: "long", year: "numeric" }
          )}`;

          const finalValue = data[data.length - 1];
          finalValueEl.textContent = formatNumber(finalValue, 0);
          finalValueEl.classList.toggle("positive-value", finalValue >= 0);
          finalValueEl.classList.toggle("negative-value", finalValue < 0);

          const uniqueAssets = [
            ...new Set(executedPlansData.map((trade) => trade.symbol)),
          ];
          assetListEl.textContent = uniqueAssets.join(", ");

          // Lanjutkan render grafik seperti biasa...
          const scalesConfig = getResponsiveChartScales(
            labels,
            "Pips/Points",
            (val) => formatNumber(val, 0),
            true
          );
          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Pips/Points Kumulatif Keseluruhan",
                  data,
                  borderColor: "#ffc107",
                  backgroundColor: "rgba(255, 193, 7, 0.1)",
                  fill: true,
                  tension: 0.3,
                  borderWidth: 1.5,
                  pointRadius: 2,
                  pointBackgroundColor: "#ffc107",
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: overallPipsCumulativeChart,
              set chart(c) {
                overallPipsCumulativeChart = c;
              },
            },
            "line",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 1000, easing: "easeOutQuart" },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) =>
                      ctx.dataset.label + ": " + formatNumber(ctx.raw, 0),
                  },
                },
              },
              scales: scalesConfig,
            }
          );
        } catch (err) {
          console.error("Error overall cumulative pips chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data grafik: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderCombinedBarChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "combinedSummaryBarChart",
          "combinedSummaryBarChartLoading",
          "combinedSummaryBarChartError",
          "combinedSummaryBarChartNoData"
        );
        try {
          const sortedTrades = [...executedPlansData]
            .filter(
              (trade) =>
                trade.outcome === "Take Profit" || trade.outcome === "Stop Loss"
            )
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: combinedBarChart,
                set chart(c) {
                  combinedBarChart = c;
                },
              },
              "bar",
              {}
            );
            return;
          }

          const labels = [];
          const balanceData = [];
          // Objek untuk menyimpan data tambahan untuk tooltip
          const tooltipData = [];

          let initialBalance = sortedTrades[0].balance;
          let cumulativeBalance = initialBalance;
          let cumulativePips = 0;
          let cumulativeTradeCount = 0;

          sortedTrades.forEach((trade, index) => {
            const profitLossAmount =
              trade.outcome === "Take Profit" ? trade.nettTP : trade.nettSL;
            const pointsForTrade =
              trade.outcome === "Take Profit"
                ? getVisualPoints(trade.tpPips, trade.symbol).forCalc
                : -getVisualPoints(trade.slPips, trade.symbol).forCalc;

            cumulativeBalance += profitLossAmount;
            cumulativePips += pointsForTrade;
            cumulativeTradeCount++;
            const cumulativePercentage =
              initialBalance > 0
                ? ((cumulativeBalance - initialBalance) / initialBalance) * 100
                : 0;

            labels.push(`Trade #${index + 1}`);
            balanceData.push(cumulativeBalance);
            tooltipData.push({
              percentage: cumulativePercentage,
              pips: cumulativePips,
              trades: cumulativeTradeCount,
            });
          });

          const scalesConfig = getResponsiveChartScales(
            labels,
            "Akumulasi Saldo ($)",
            (val) => formatCurrency(val, "USD")
          );

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Akumulasi Saldo",
                  data: balanceData,
                  backgroundColor: "rgba(220, 53, 69, 0.8)", // Warna merah
                  borderColor: "rgba(220, 53, 69, 1)",
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: combinedBarChart,
              set chart(c) {
                combinedBarChart = c;
              },
            },
            "bar",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    // Menampilkan data gabungan di tooltip
                    label: function (context) {
                      const index = context.dataIndex;
                      const balance = context.raw;
                      const extraData = tooltipData[index];
                      return `Saldo: ${formatCurrency(balance, "USD")}`;
                    },
                    afterLabel: function (context) {
                      const index = context.dataIndex;
                      const extraData = tooltipData[index];
                      return [
                        `Persentase: ${formatNumber(extraData.percentage, 2)}%`,
                        `Total Pips: ${formatNumber(extraData.pips, 0)}`,
                        `Total Trade: ${extraData.trades}`,
                      ];
                    },
                  },
                },
              },
              scales: scalesConfig,
            }
          );
        } catch (err) {
          console.error("Error combined bar chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data grafik gabungan: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderTradeFrequencyChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "tradeFrequencyChart",
          "tradeFrequencyChartLoading",
          "tradeFrequencyChartError",
          "tradeFrequencyChartNoData"
        );
        try {
          const tradeCounts = {};
          executedPlansData.forEach((trade) => {
            if (trade.outcome !== "Cancel" && trade.outcome !== "Tes") {
              const key = `${trade.symbol} - ${trade.tradeType}`;
              tradeCounts[key] = (tradeCounts[key] || 0) + 1;
            }
          });
          const labels = Object.keys(tradeCounts).sort();
          const data = labels.map((label) => tradeCounts[label]);
          const backgroundColors = labels.map((label) =>
            label.includes("BUY")
              ? "rgba(34, 34, 34, 0.8)"
              : label.includes("SELL")
              ? "rgba(220, 53, 69, 0.8)"
              : "rgba(108, 117, 125, 0.8)"
          );
          const borderColors = backgroundColors.map((c) =>
            c.replace("0.8)", "1)")
          );

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Jumlah Eksekusi",
                  data,
                  backgroundColor: backgroundColors,
                  borderColor: borderColors,
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: tradeFrequencyChart,
              set chart(c) {
                tradeFrequencyChart = c;
              },
            },
            "bar",
            {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) => `${ctx.label}: ${ctx.raw} kali`,
                  },
                },
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: "Aset & Tipe Trade",
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                    autoSkip: false,
                    maxRotation: 45,
                    minRotation: 45,
                  },
                },
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Jumlah Eksekusi",
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    callback: (val) => (Number.isInteger(val) ? val : null),
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                  },
                },
              },
            }
          );
        } catch (err) {
          console.error("Error trade frequency chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data grafik frekuensi trade: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      // --- NEW: Functions for Frequency Charts ---

      /**
       * Generic data aggregation function for frequency charts.
       * @returns {Object} Aggregated data grouped by asset symbol.
       */
      function aggregateAssetFrequencyData() {
        const assetStats = {};
        const relevantTrades = executedPlansData.filter(
          (trade) =>
            trade.outcome === "Take Profit" || trade.outcome === "Stop Loss"
        );

        // Find the first trade for each asset to establish its initial balance for percentage calculation
        const initialBalances = {};
        [...relevantTrades]
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
          .forEach((trade) => {
            if (!initialBalances[trade.symbol]) {
              initialBalances[trade.symbol] = trade.balance;
            }
          });

        relevantTrades.forEach((trade) => {
          const symbol = trade.symbol;
          if (!assetStats[symbol]) {
            assetStats[symbol] = {
              tradeCount: 0,
              cumulativeBalance: 0,
              cumulativePips: 0,
              initialBalance: initialBalances[symbol] || 0, // Use the found initial balance
            };
          }

          const profitLossAmount =
            trade.outcome === "Take Profit" ? trade.nettTP : trade.nettSL;
          const pointsForTrade =
            trade.outcome === "Take Profit"
              ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
              : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          assetStats[symbol].tradeCount++;
          assetStats[symbol].cumulativeBalance += profitLossAmount;
          assetStats[symbol].cumulativePips += pointsForTrade;
        });

        // Calculate cumulative percentage for each asset
        for (const symbol in assetStats) {
          const stats = assetStats[symbol];
          stats.cumulativePercentage =
            stats.initialBalance > 0
              ? (stats.cumulativeBalance / stats.initialBalance) * 100
              : 0;
        }

        return assetStats;
      }

      /**
       * Generic rendering function for horizontal frequency bar charts.
       */
      async function renderFrequencyChart(chartConfig) {
        const { canvas, loading, error, noData } = setupChartContainer(
          chartConfig.canvasId,
          chartConfig.loadingId,
          chartConfig.errorId,
          chartConfig.noDataId
        );
        try {
          const assetStats = aggregateAssetFrequencyData();
          const sortedSymbols = Object.keys(assetStats).sort(
            (a, b) =>
              assetStats[b][chartConfig.dataKey] -
              assetStats[a][chartConfig.dataKey]
          );

          if (sortedSymbols.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              chartConfig.chartInstanceRef,
              "bar",
              {}
            );
            return;
          }

          const labels = sortedSymbols;
          const data = sortedSymbols.map(
            (symbol) => assetStats[symbol][chartConfig.dataKey]
          );

          // Use the provided color, with a lighter version for negative values
          const backgroundColors = data.map((val) =>
            val >= 0 ? chartConfig.positiveColor : chartConfig.negativeColor
          );
          const borderColors = backgroundColors.map((c) =>
            c.replace("0.8)", "1)").replace("0.4)", "0.6)")
          );

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: chartConfig.label,
                  data,
                  backgroundColor: backgroundColors,
                  borderColor: borderColors,
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            chartConfig.chartInstanceRef,
            "bar",
            {
              indexAxis: "y", // Make it a horizontal bar chart
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (context) => {
                      const symbol = context.label;
                      const value = context.raw;
                      const tradeCount = assetStats[symbol].tradeCount;
                      return `${chartConfig.label}: ${chartConfig.formatter(
                        value
                      )} (Total Trade: ${tradeCount})`;
                    },
                  },
                },
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: chartConfig.xAxisLabel,
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    callback: chartConfig.formatter,
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                  },
                },
                y: {
                  ticks: { color: "#555", font: { family: "Inter", size: 7 } },
                },
              },
            }
          );
        } catch (err) {
          console.error(`Error rendering ${chartConfig.label} chart:`, err);
          loading.classList.add("hidden");
          error.textContent =
            `Gagal memuat data ${chartConfig.label}: ` + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      // Specific functions that call the generic renderer
      async function fetchAndRenderBalanceFrequencyChart() {
        await renderFrequencyChart({
          canvasId: "balanceFrequencyChart",
          loadingId: "balanceFrequencyChartLoading",
          errorId: "balanceFrequencyChartError",
          noDataId: "balanceFrequencyChartNoData",
          chartInstanceRef: {
            chart: balanceFrequencyChart,
            set chart(c) {
              balanceFrequencyChart = c;
            },
          },
          dataKey: "cumulativeBalance",
          label: "Akumulasi Balance",
          xAxisLabel: "Total Balance ($)",
          formatter: (val) => formatCurrency(val, "USD"),
          positiveColor: "rgba(220, 53, 69, 0.8)", // Red
          negativeColor: "rgba(220, 53, 69, 0.4)", // Lighter Red
        });
      }

      async function fetchAndRenderPercentageFrequencyChart() {
        await renderFrequencyChart({
          canvasId: "percentageFrequencyChart",
          loadingId: "percentageFrequencyChartLoading",
          errorId: "percentageFrequencyChartError",
          noDataId: "percentageFrequencyChartNoData",
          chartInstanceRef: {
            chart: percentageFrequencyChart,
            set chart(c) {
              percentageFrequencyChart = c;
            },
          },
          dataKey: "cumulativePercentage",
          label: "Akumulasi Persentase",
          xAxisLabel: "Total Persentase (%)",
          formatter: (val) => `${formatNumber(val, 2)}%`,
          positiveColor: "rgba(0, 0, 139, 0.8)", // Dark Blue
          negativeColor: "rgba(0, 0, 139, 0.4)", // Lighter Dark Blue
        });
      }

      async function fetchAndRenderPipsFrequencyChart() {
        await renderFrequencyChart({
          canvasId: "pipsFrequencyChart",
          loadingId: "pipsFrequencyChartLoading",
          errorId: "pipsFrequencyChartError",
          noDataId: "pipsFrequencyChartNoData",
          chartInstanceRef: {
            chart: pipsFrequencyChart,
            set chart(c) {
              pipsFrequencyChart = c;
            },
          },
          dataKey: "cumulativePips",
          label: "Akumulasi Pips/Points",
          xAxisLabel: "Total Pips/Points",
          formatter: (val) => formatNumber(val, 0),
          positiveColor: "rgba(255, 193, 7, 0.8)", // Yellow
          negativeColor: "rgba(255, 193, 7, 0.4)", // Lighter Yellow
        });
      }

      // --- NEW: Functions for Execution Frequency Chart ---

      /**
       * Aggregates executed trade data, separating stats by asset and trade type (BUY/SELL).
       * @returns {Object} Aggregated data.
       */
      function aggregateExecutionFrequencyData() {
        const assetStats = {};
        const relevantTrades = executedPlansData.filter(
          (trade) =>
            trade.outcome === "Take Profit" || trade.outcome === "Stop Loss"
        );

        // Find the initial balance for each asset to calculate percentage changes accurately.
        const initialBalances = {};
        [...relevantTrades]
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
          .forEach((trade) => {
            if (!initialBalances[trade.symbol]) {
              initialBalances[trade.symbol] = trade.balance;
            }
          });

        relevantTrades.forEach((trade) => {
          const symbol = trade.symbol;
          const tradeType = trade.tradeType.toUpperCase(); // 'BUY' or 'SELL'

          // Initialize structure if it doesn't exist
          if (!assetStats[symbol]) {
            assetStats[symbol] = {
              BUY: {
                tradeCount: 0,
                cumulativeBalance: 0,
                cumulativePips: 0,
                initialBalance: initialBalances[symbol] || 0,
              },
              SELL: {
                tradeCount: 0,
                cumulativeBalance: 0,
                cumulativePips: 0,
                initialBalance: initialBalances[symbol] || 0,
              },
            };
          }

          const profitLossAmount =
            trade.outcome === "Take Profit" ? trade.nettTP : trade.nettSL;
          const pointsForTrade =
            trade.outcome === "Take Profit"
              ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
              : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          if (assetStats[symbol][tradeType]) {
            assetStats[symbol][tradeType].tradeCount++;
            assetStats[symbol][tradeType].cumulativeBalance += profitLossAmount;
            assetStats[symbol][tradeType].cumulativePips += pointsForTrade;
          }
        });

        // Calculate cumulative percentage for each asset and trade type
        for (const symbol in assetStats) {
          for (const tradeType in assetStats[symbol]) {
            const stats = assetStats[symbol][tradeType];
            stats.cumulativePercentage =
              stats.initialBalance > 0
                ? (stats.cumulativeBalance / stats.initialBalance) * 100
                : 0;
          }
        }

        return assetStats;
      }

      /**
       * Renders the horizontal grouped bar chart for execution frequency.
       */
      async function fetchAndRenderExecutionFrequencyChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "executionFrequencyChart",
          "executionFrequencyChartLoading",
          "executionFrequencyChartError",
          "executionFrequencyChartNoData"
        );
        try {
          const assetStats = aggregateExecutionFrequencyData();
          const sortedSymbols = Object.keys(assetStats).sort((a, b) => {
            const totalBalanceA =
              (assetStats[a].BUY.cumulativeBalance || 0) +
              (assetStats[a].SELL.cumulativeBalance || 0);
            const totalBalanceB =
              (assetStats[b].BUY.cumulativeBalance || 0) +
              (assetStats[b].SELL.cumulativeBalance || 0);
            return totalBalanceB - totalBalanceA;
          });

          if (sortedSymbols.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: executionFrequencyChart,
                set chart(c) {
                  executionFrequencyChart = c;
                },
              },
              "bar",
              {}
            );
            return;
          }

          const labels = sortedSymbols;
          const buyData = sortedSymbols.map(
            (symbol) => assetStats[symbol].BUY.cumulativeBalance
          );
          const sellData = sortedSymbols.map(
            (symbol) => assetStats[symbol].SELL.cumulativeBalance
          );

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "BUY",
                  data: buyData,
                  backgroundColor: "rgba(0, 0, 139, 0.8)", // Dark Blue
                  borderColor: "rgba(0, 0, 139, 1)",
                  borderWidth: 1,
                },
                {
                  label: "SELL",
                  data: sellData,
                  backgroundColor: "rgba(220, 53, 69, 0.8)", // Red
                  borderColor: "rgba(220, 53, 69, 1)",
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: executionFrequencyChart,
              set chart(c) {
                executionFrequencyChart = c;
              },
            },
            "bar",
            {
              indexAxis: "y", // Horizontal bar chart
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: true, position: "top" },
                tooltip: {
                  callbacks: {
                    label: (context) => {
                      return context.dataset.label; // Just show BUY or SELL
                    },
                    afterLabel: (context) => {
                      const symbol = context.label;
                      const tradeType = context.dataset.label;
                      const stats = assetStats[symbol][tradeType];
                      return [
                        `  Saldo: ${formatCurrency(
                          stats.cumulativeBalance,
                          "USD"
                        )}`,
                        `  Persentase: ${formatNumber(
                          stats.cumulativePercentage,
                          2
                        )}%`,
                        `  Pips/Points: ${formatNumber(
                          stats.cumulativePips,
                          0
                        )}`,
                        `  Total Trade: ${stats.tradeCount}`,
                      ];
                    },
                  },
                },
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: "Akumulasi Saldo ($)",
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    callback: (val) => formatCurrency(val, "USD"),
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                  },
                },
                y: {
                  ticks: { color: "#555", font: { family: "Inter", size: 7 } },
                },
              },
            }
          );
        } catch (err) {
          console.error("Error rendering execution frequency chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data frekuensi eksekusi: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      /**
       * Renders the horizontal bar chart for total executed trades per asset.
       */
      async function fetchAndRenderAssetExecutionCountChart() {
        const { canvas, loading, error, noData } = setupChartContainer(
          "assetExecutionCountChart",
          "assetExecutionCountChartLoading",
          "assetExecutionCountChartError",
          "assetExecutionCountChartNoData"
        );
        try {
          const assetCounts = {};
          const relevantTrades = executedPlansData.filter(
            (trade) =>
              trade.outcome === "Take Profit" || trade.outcome === "Stop Loss"
          );

          relevantTrades.forEach((trade) => {
            const symbol = trade.symbol;
            assetCounts[symbol] = (assetCounts[symbol] || 0) + 1;
          });

          const sortedSymbols = Object.keys(assetCounts).sort(
            (a, b) => assetCounts[b] - assetCounts[a]
          );

          if (sortedSymbols.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              {
                chart: assetExecutionCountChart,
                set chart(c) {
                  assetExecutionCountChart = c;
                },
              },
              "bar",
              {}
            );
            return;
          }

          const labels = sortedSymbols;
          const data = sortedSymbols.map((symbol) => assetCounts[symbol]);

          handleChartData(
            {
              labels,
              datasets: [
                {
                  label: "Jumlah Eksekusi",
                  data,
                  backgroundColor: "rgba(132, 204, 22, 0.8)", // Bright Green
                  borderColor: "rgba(101, 163, 13, 1)",
                  borderWidth: 1,
                },
              ],
            },
            { canvas, loading, error, noData },
            {
              chart: assetExecutionCountChart,
              set chart(c) {
                assetExecutionCountChart = c;
              },
            },
            "bar",
            {
              indexAxis: "y", // Horizontal bar chart
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 800 },
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (context) => `Jumlah Eksekusi: ${context.raw}`,
                  },
                },
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: "Jumlah Eksekusi Selesai",
                    color: "#555",
                    font: { family: "Inter", size: 8, weight: "bold" },
                  },
                  ticks: {
                    color: "#555",
                    font: { family: "Inter", size: 7 },
                    stepSize: 1, // Ensure ticks are integers
                  },
                },
                y: {
                  ticks: { color: "#555", font: { family: "Inter", size: 7 } },
                },
              },
            }
          );
        } catch (err) {
          console.error("Error rendering asset execution count chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data frekuensi aset: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderOutcomeRadarChart() {
        const chartConfig = {
          canvasId: "outcomeRadarChart",
          loadingId: "outcomeRadarChartLoading",
          errorId: "outcomeRadarChartError",
          noDataId: "outcomeRadarChartNoData",
        };
        const chartInstanceRef = {
          chart: outcomeRadarChart,
          set chart(c) {
            outcomeRadarChart = c;
          },
        };
        const { canvas, loading, error, noData } = setupChartContainer(
          chartConfig.canvasId,
          chartConfig.loadingId,
          chartConfig.errorId,
          chartConfig.noDataId
        );
        const titleElement = document.getElementById("outcomeChartTitle");

        try {
          const outcomeCounts = {
            "Take Profit": 0,
            "Stop Loss": 0,
            Tes: 0,
            Cancel: 0,
          };

          executedPlansData.forEach((trade) => {
            if (trade.outcome && outcomeCounts.hasOwnProperty(trade.outcome)) {
              outcomeCounts[trade.outcome]++;
            }
          });

          const totalExecutions = Object.values(outcomeCounts).reduce(
            (sum, count) => sum + count,
            0
          );

          if (titleElement) {
            titleElement.textContent = `Ringkasan Hasil Eksekusi (Total: ${totalExecutions})`;
          }

          if (totalExecutions === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              chartInstanceRef,
              "radar",
              {}
            );
            return;
          }

          const labels = Object.keys(outcomeCounts);
          const data = Object.values(outcomeCounts);

          handleChartData(
            {
              labels: labels,
              datasets: [
                {
                  label: "Jumlah Eksekusi",
                  data: data,
                  fill: true,
                  backgroundColor: "rgba(42, 42, 42, 0.2)",
                  borderColor: "rgba(42, 42, 42, 1)",
                  borderWidth: 1, // <-- PERBAIKAN: Baris ini ditambahkan untuk menipiskan garis
                  pointBackgroundColor: "rgba(42, 42, 42, 1)",
                  pointBorderColor: "#fff",
                  pointHoverBackgroundColor: "#fff",
                  pointHoverBorderColor: "rgba(42, 42, 42, 1)",
                },
              ],
            },
            { canvas, loading, error, noData },
            chartInstanceRef,
            "radar",
            {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
              },
              scales: {
                r: {
                  // 'r' adalah untuk sumbu radial (nilai)
                  beginAtZero: true,
                  ticks: {
                    stepSize: 1, // Pastikan skala dalam bilangan bulat
                    backdropColor: "rgba(255, 255, 255, 0.75)",
                  },
                  pointLabels: {
                    font: {
                      size: 10,
                      family: "Inter",
                    },
                  },
                },
              },
            }
          );
        } catch (err) {
          console.error("Error rendering outcome radar chart:", err);
          loading.classList.add("hidden");
          error.textContent =
            "Gagal memuat data ringkasan hasil: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      async function fetchAndRenderCombinedCumulativeChart() {
        const chartConfig = {
          canvasId: "combinedCumulativeChart",
          loadingId: "combinedCumulativeChartLoading",
          errorId: "combinedCumulativeChartError",
          noDataId: "combinedCumulativeChartNoData",
        };
        const chartInstanceRef = {
          chart: combinedCumulativeChart,
          set chart(c) {
            combinedCumulativeChart = c;
          },
        };
        const { canvas, loading, error, noData } = setupChartContainer(
          chartConfig.canvasId,
          chartConfig.loadingId,
          chartConfig.errorId,
          chartConfig.noDataId
        );

        try {
          const sortedTrades = executedPlansData
            .filter((t) => getTradeResult(t).isValid)
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

          if (sortedTrades.length === 0) {
            handleChartData(
              { labels: [], datasets: [] },
              { canvas, loading, error, noData },
              chartInstanceRef,
              "line",
              {}
            );
            return;
          }

          const labels = ["Mulai"],
            balanceData = [],
            percentageData = [],
            pipsData = [];
          const initialBalance = sortedTrades[0].balance;
          let currentBalance = initialBalance;
          let currentCumulativePips = 0;

          balanceData.push(initialBalance);
          percentageData.push(0);
          pipsData.push(0);

          sortedTrades.forEach((trade) => {
            currentBalance += getTradeResult(trade).isWin
              ? trade.nettTP
              : trade.nettSL;
            currentCumulativePips += getTradeResult(trade).isWin
              ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
              : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;
            const currentPercentage =
              initialBalance > 0
                ? ((currentBalance - initialBalance) / initialBalance) * 100
                : 0;

            labels.push(
              new Date(trade.timestamp).toLocaleDateString("id-ID", {
                day: "2-digit",
                month: "short",
              })
            );
            balanceData.push(currentBalance);
            percentageData.push(currentPercentage);
            pipsData.push(currentCumulativePips);
          });

          handleChartData(
            {
              labels: labels,
              datasets: [
                {
                  label: "Saldo Akun ($)",
                  data: balanceData,
                  borderColor: "#2a2a2a", // Hitam
                  backgroundColor: "rgba(42, 42, 42, 0.1)",
                  yAxisID: "yBalance",
                  tension: 0.3,
                  borderWidth: 2,
                },
                {
                  label: "Persentase (%)",
                  data: percentageData,
                  borderColor: "#007bff", // Biru
                  backgroundColor: "rgba(0, 123, 255, 0.1)",
                  yAxisID: "yPercentage",
                  tension: 0.3,
                  borderWidth: 1.5,
                },
                {
                  label: "Pips/Points",
                  data: pipsData,
                  borderColor: "#ffc107", // Kuning
                  backgroundColor: "rgba(255, 193, 7, 0.1)",
                  yAxisID: "yPips",
                  tension: 0.3,
                  borderWidth: 1.5,
                },
              ],
            },
            { canvas, loading, error, noData },
            chartInstanceRef,
            "line",
            {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { position: "top" },
                tooltip: {
                  mode: "index",
                  intersect: false,
                  callbacks: {
                    label: function (context) {
                      let label = context.dataset.label || "";
                      if (label) {
                        label += ": ";
                      }
                      if (context.parsed.y !== null) {
                        if (context.dataset.yAxisID === "yBalance") {
                          label += formatCurrency(context.parsed.y, "USD");
                        } else if (context.dataset.yAxisID === "yPercentage") {
                          label += `${formatNumber(context.parsed.y, 2)}%`;
                        } else {
                          label += formatNumber(context.parsed.y, 0);
                        }
                      }
                      return label;
                    },
                  },
                },
              },
              scales: {
                x: { ticks: { autoSkip: true, maxTicksLimit: 10 } },
                yBalance: {
                  type: "linear",
                  display: true,
                  position: "left",
                  title: { display: true, text: "Saldo Akun ($)" },
                  ticks: { callback: (value) => formatCurrency(value, "USD") },
                },
                yPercentage: {
                  type: "linear",
                  display: true,
                  position: "right",
                  title: { display: true, text: "Persentase (%)" },
                  ticks: { callback: (value) => `${formatNumber(value, 1)}%` },
                  grid: { drawOnChartArea: false },
                },
                yPips: {
                  type: "linear",
                  display: false, // Disembunyikan agar tidak terlalu ramai, tapi tetap bisa dilihat di tooltip
                },
              },
            }
          );
        } catch (err) {
          console.error("Error rendering combined cumulative chart:", err);
          loading.classList.add("hidden");
          error.textContent = "Gagal memuat data gabungan: " + err.message;
          error.classList.remove("hidden");
          canvas.style.display = "none";
        }
      }

      // --- NEW: Compounding Simulator Logic ---
      function calculateProjectionData(dataType) {
        const simBalanceInput = document.getElementById("simBalance");
        const simMonthlyTargetInput =
          document.getElementById("simMonthlyTarget");
        const simPeriodInput = document.getElementById("simPeriod");

        const startBalance = parseFloat(simBalanceInput.value);
        const monthlyTarget = parseFloat(simMonthlyTargetInput.value) / 100;
        const periodMonths = parseInt(simPeriodInput.value);

        const projectionLabels = [];
        const projectionData = [];

        if (
          isNaN(startBalance) ||
          isNaN(monthlyTarget) ||
          isNaN(periodMonths) ||
          periodMonths <= 0
        ) {
          return { projectionLabels, projectionData };
        }

        const sortedTrades = [...executedPlansData]
          .filter((t) => t.outcome !== "Cancel" && t.outcome !== "Tes")
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        let lastTradeDate =
          sortedTrades.length > 0
            ? new Date(sortedTrades[sortedTrades.length - 1].timestamp)
            : new Date();
        let currentProjectedBalance = startBalance;
        let historicalInitialBalance =
          sortedTrades.length > 0 ? sortedTrades[0].balance : startBalance;

        for (let i = 1; i <= periodMonths; i++) {
          currentProjectedBalance *= 1 + monthlyTarget;
          const projectedDate = new Date(lastTradeDate);
          projectedDate.setMonth(projectedDate.getMonth() + i);

          projectionLabels.push(
            projectedDate.toLocaleString("id-ID", {
              day: "numeric",
              month: "short",
              year: "numeric",
            })
          );

          if (dataType === "balance") {
            projectionData.push(currentProjectedBalance);
          } else if (dataType === "percentage") {
            const percentageChange =
              historicalInitialBalance > 0
                ? ((currentProjectedBalance - historicalInitialBalance) /
                    historicalInitialBalance) *
                  100
                : 0;
            projectionData.push(percentageChange);
          }
        }
        return { projectionLabels, projectionData };
      }

      // --- GANTI FUNGSI LAMA DI BAWAH INI DENGAN YANG BARU ---
      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      function handleImageUpload(event, target) {
        const files = event.target.files;
        if (files.length === 0) return;

        currentUploadTarget = target;
        const isBanner = target === "16:4";
        // Gunakan array yang sudah disaring dari nilai null/undefined untuk pengecekan batas
        const photoArray = isBanner
          ? bannerPhotos.filter(Boolean)
          : userPhotos.filter(Boolean);
        const maxPhotos = isBanner ? MAX_BANNER_PHOTOS : MAX_PHOTOS;

        if (photoArray.length >= maxPhotos) {
          showMessageBox(
            "Batas Unggahan Tercapai",
            `Anda hanya dapat mengunggah maksimal ${maxPhotos} foto untuk galeri ini.`,
            false
          );
          event.target.value = ""; // Reset input
          return;
        }

        const file = files[0];
        if (!file || !file.type.startsWith("image/")) {
          showMessageBox(
            "Gagal",
            "Silakan pilih file gambar yang valid.",
            false
          );
          event.target.value = ""; // Reset input
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const imageDataUrl = e.target.result;

          if (isBanner) {
            // PERBAIKAN: Logika disederhanakan untuk memastikan data disimpan dan dirender dengan benar.
            try {
              // 1. Tambahkan foto baru ke array data menggunakan 'push'.
              bannerPhotos.push(imageDataUrl);

              // 2. Simpan seluruh array yang sudah diperbarui ke localStorage.
              saveBannerPhotosToLocalStorage();

              // 3. Atur indeks agar foto yang baru diunggah yang ditampilkan.
              currentBannerPhotoIndex = bannerPhotos.length - 1;

              // 4. Panggil fungsi untuk merender ulang galeri dengan data baru.
              renderBannerGallery();

              // 5. Beri tahu pengguna bahwa proses berhasil setelah semuanya selesai.
              showMessageBox(
                "Berhasil",
                "Foto banner berhasil diunggah.",
                false
              );
            } catch (error) {
              console.error("Gagal menyimpan foto banner:", error);
              showMessageBox(
                "Gagal Unggah",
                "Terjadi kesalahan saat mengunggah foto banner.",
                false
              );
            }
          } else {
            // Logika untuk galeri 1:1 (tidak berubah)
            currentImageToCrop = new Image();
            currentImageToCrop.onload = () => {
              const modalCanvasContainer = photoUploadModal.querySelector(
                ".flex.justify-center.items-center"
              );
              const canvasSize = 600;

              modalCanvasContainer.style.aspectRatio = `1 / 1`;
              imageCanvas.width = canvasSize;
              imageCanvas.height = canvasSize;

              const modalTitle = photoUploadModal.querySelector("h3");
              modalTitle.textContent = `Unggah & Pangkas Foto (1:1)`;

              drawImageCover(
                ctx,
                currentImageToCrop,
                imageCanvas.width,
                imageCanvas.height,
                1 / 1
              );
              showModal(photoUploadModal);
            };
            currentImageToCrop.src = imageDataUrl;
          }
        };
        reader.readAsDataURL(file);
        event.target.value = ""; // Reset input agar bisa unggah file yang sama lagi
      }

      function handleSimulatorInputChange() {
        // Save data to local storage whenever it changes
        saveSimulatorData();
        // This function triggers the re-rendering of the charts that need projection lines.
        // The chart rendering functions themselves will read the simulator inputs.
        if (
          chartSections.overallBalanceCumulativeStatisticsSection.hasRendered
        ) {
          fetchAndRenderOverallBalanceCumulativeChart();
        }
        if (
          chartSections.overallPercentageCumulativeStatisticsSection.hasRendered
        ) {
          fetchAndRenderOverallPercentageCumulativeChart();
        }
      }

      // --- PERBAIKAN STRUKTURAL: BLOK FUNGSI RINGKASAN DIPINDAHKAN KE SINI (LINGKUP GLOBAL) ---

      /**
       * Helper function to get the week number of a date.
       * @param {Date} d The date.
       * @returns {number} The week number.
       */
      function getWeekNumber(d) {
        d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
        var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        var weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
        return weekNo;
      }

      // --- GANTI FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      function calculateAndRenderMonthlyPLSummary() {
        const summaryBody = document.getElementById("monthlyPLSummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter(
            (trade) => getTradeResult(trade).isValid && trade && trade.timestamp
          )
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          // Perbarui colspan menjadi 8
          summaryBody.innerHTML = `<tr><td colspan="8" class="py-4 text-center text-gray-500">Belum ada data trading yang selesai.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const monthlyData = {};
        const firstTradeWithBalance = relevantTrades.find(
          (t) => typeof t.balance === "number" && !isNaN(t.balance)
        );
        const initialBalance = firstTradeWithBalance
          ? firstTradeWithBalance.balance
          : 0;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          if (isNaN(tradeDate.getTime())) return;
          const monthKey = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}`;

          if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = {
              tradeCount: 0,
              tpCount: 0,
              slCount: 0,
              monthlyPL: 0,
              totalTPValue: 0,
              totalSLValue: 0,
              monthName: tradeDate.toLocaleString("id-ID", {
                month: "long",
                year: "numeric",
              }),
            };
          }

          const { isWin } = getTradeResult(trade);
          const profitLossAmount = isWin
            ? parseFloat(trade.nettTP)
            : parseFloat(trade.nettSL);

          monthlyData[monthKey].tradeCount++;
          monthlyData[monthKey].monthlyPL += profitLossAmount;
          if (isWin) {
            monthlyData[monthKey].tpCount++;
            monthlyData[monthKey].totalTPValue += parseFloat(trade.nettTP);
          } else {
            monthlyData[monthKey].slCount++;
            monthlyData[monthKey].totalSLValue += Math.abs(
              parseFloat(trade.nettSL)
            );
          }
        });

        const sortedMonthKeys = Object.keys(monthlyData).sort((a, b) => {
          const [yearA, monthA] = a.split("-");
          const [yearB, monthB] = b.split("-");
          return new Date(yearA, monthA) - new Date(yearB, monthB);
        });

        let cumulativePL = 0;
        let cumulativeBalance = initialBalance;

        for (const monthKey of sortedMonthKeys) {
          const month = monthlyData[monthKey];
          cumulativePL += month.monthlyPL;
          cumulativeBalance = initialBalance + cumulativePL;

          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;
          const nettTP = month.totalTPValue - month.totalSLValue;

          // Kalkulasi baru untuk eksekusi bersih
          const netExecutions = month.tpCount - month.slCount;

          const percentageClass =
            cumulativePercentage >= 0 ? "positive-value" : "negative-value";
          const nettTPClass = nettTP >= 0 ? "positive-value" : "negative-value";
          const cumulativePLClass =
            cumulativePL >= 0 ? "positive-value" : "negative-value";
          const totalBalanceClass =
            cumulativeBalance >= initialBalance
              ? "positive-value"
              : "negative-value";
          // Kelas warna baru
          const netExecutionsClass =
            netExecutions >= 0 ? "positive-value" : "negative-value";

          // Tambahkan <td> baru untuk data eksekusi bersih
          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                          <tr>
                              <td class="py-3 px-4 text-center text-neutral-value">${
                                month.monthName
                              }</td>
                              <td class="py-3 px-4 text-center ${percentageClass}">${formatNumber(
              cumulativePercentage,
              2
            )}%</td>
                              <td class="py-3 px-4 text-center text-neutral-value">${
                                month.tradeCount
                              }</td>
                              <td class="py-3 px-4 text-center">
                                  <span class="positive-value">${
                                    month.tpCount
                                  }</span> / <span class="negative-value">${
              month.slCount
            }</span>
                              </td>
                              <td class="py-3 px-4 text-center ${netExecutionsClass}">${netExecutions}</td>
                              <td class="py-3 px-4 text-center ${nettTPClass}">${formatCurrency(
              nettTP,
              "USD"
            )}</td>
                              <td class="py-3 px-4 text-center ${cumulativePLClass}">${formatCurrency(
              cumulativePL,
              "USD"
            )}</td>
                              <td class="py-3 px-4 text-center ${totalBalanceClass}">${formatCurrency(
              cumulativeBalance,
              "USD"
            )}</td>
                          </tr>
                      `
          );
        }
      }

      // --- GANTI SEMUA FUNGSI RINGKASAN (HARIAN, MINGGUAN, BULANAN, TAHUNAN) DENGAN BLOK DI BAWAH INI ---

      function calculateAndRenderDailySummary() {
        const summaryBody = document.getElementById("newDailySummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data harian.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const dailyData = {};
        const initialBalance = relevantTrades[0].balance;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          const dayKey = tradeDate.toISOString().slice(0, 10);

          if (!dailyData[dayKey]) {
            dailyData[dayKey] = {
              tradeCount: 0,
              pips: 0,
              pl: 0,
              dayName: tradeDate.toLocaleDateString("id-ID", {
                weekday: "long",
                year: "numeric",
                month: "long",
                day: "numeric",
              }),
            };
          }

          const tradeResult = getTradeResult(trade);
          const pointsForTrade = tradeResult.isWin
            ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
            : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          dailyData[dayKey].pips += pointsForTrade;
          dailyData[dayKey].pl += tradeResult.profitLoss;
          dailyData[dayKey].tradeCount++;
        });

        const sortedDayKeys = Object.keys(dailyData).sort();
        let cumulativeTradeCount = 0,
          cumulativePips = 0,
          cumulativePL = 0;

        for (const dayKey of sortedDayKeys) {
          const day = dailyData[dayKey];
          cumulativeTradeCount += day.tradeCount;
          cumulativePips += day.pips;
          cumulativePL += day.pl;

          const cumulativeBalance = initialBalance + cumulativePL;
          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;

          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                  <tr>
                      <td class="py-3 px-4 text-center">${day.dayName}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePercentage >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePercentage, 2)}%</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePips >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePips, 0)}</td>
                      <td class="py-3 px-4 text-center">${cumulativeTradeCount}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativeBalance >= initialBalance
                          ? "positive-value"
                          : "negative-value"
                      }">${formatCurrency(cumulativeBalance, "USD")}</td>
                  </tr>
              `
          );
        }
      }

      function calculateAndRenderWeeklySummary() {
        const summaryBody = document.getElementById("newWeeklySummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data mingguan.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const weeklyData = {};
        const initialBalance = relevantTrades[0].balance;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          const weekKey = `${tradeDate.getFullYear()}-W${String(
            getWeekNumber(tradeDate)
          ).padStart(2, "0")}`;

          if (!weeklyData[weekKey]) {
            weeklyData[weekKey] = {
              tradeCount: 0,
              pips: 0,
              pl: 0,
              weekName: `Minggu ${getWeekNumber(
                tradeDate
              )}, ${tradeDate.getFullYear()}`,
            };
          }

          const tradeResult = getTradeResult(trade);
          const pointsForTrade = tradeResult.isWin
            ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
            : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          weeklyData[weekKey].pips += pointsForTrade;
          weeklyData[weekKey].pl += tradeResult.profitLoss;
          weeklyData[weekKey].tradeCount++;
        });

        const sortedWeekKeys = Object.keys(weeklyData).sort();
        let cumulativeTradeCount = 0,
          cumulativePips = 0,
          cumulativePL = 0;

        for (const weekKey of sortedWeekKeys) {
          const week = weeklyData[weekKey];
          cumulativeTradeCount += week.tradeCount;
          cumulativePips += week.pips;
          cumulativePL += week.pl;

          const cumulativeBalance = initialBalance + cumulativePL;
          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;

          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                  <tr>
                      <td class="py-3 px-4 text-center">${week.weekName}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePercentage >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePercentage, 2)}%</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePips >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePips, 0)}</td>
                      <td class="py-3 px-4 text-center">${cumulativeTradeCount}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativeBalance >= initialBalance
                          ? "positive-value"
                          : "negative-value"
                      }">${formatCurrency(cumulativeBalance, "USD")}</td>
                  </tr>
              `
          );
        }
      }

      function calculateAndRenderNewMonthlySummary() {
        const summaryBody = document.getElementById("newMonthlySummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data bulanan.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const monthlyData = {};
        const initialBalance = relevantTrades[0].balance;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          const monthKey = tradeDate.toISOString().slice(0, 7);

          if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = {
              tradeCount: 0,
              pips: 0,
              pl: 0,
              monthName: tradeDate.toLocaleString("id-ID", {
                month: "long",
                year: "numeric",
              }),
            };
          }

          const tradeResult = getTradeResult(trade);
          const pointsForTrade = tradeResult.isWin
            ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
            : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          monthlyData[monthKey].pips += pointsForTrade;
          monthlyData[monthKey].pl += tradeResult.profitLoss;
          monthlyData[monthKey].tradeCount++;
        });

        const sortedMonthKeys = Object.keys(monthlyData).sort();
        let cumulativeTradeCount = 0,
          cumulativePips = 0,
          cumulativePL = 0;

        for (const monthKey of sortedMonthKeys) {
          const month = monthlyData[monthKey];
          cumulativeTradeCount += month.tradeCount;
          cumulativePips += month.pips;
          cumulativePL += month.pl;

          const cumulativeBalance = initialBalance + cumulativePL;
          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;

          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                  <tr>
                      <td class="py-3 px-4 text-center">${month.monthName}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePercentage >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePercentage, 2)}%</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePips >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePips, 0)}</td>
                      <td class="py-3 px-4 text-center">${cumulativeTradeCount}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativeBalance >= initialBalance
                          ? "positive-value"
                          : "negative-value"
                      }">${formatCurrency(cumulativeBalance, "USD")}</td>
                  </tr>
              `
          );
        }
      }

      function calculateAndRenderYearlySummary() {
        const summaryBody = document.getElementById("newYearlySummaryBody");
        if (!summaryBody) return;

        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          summaryBody.innerHTML = `<tr><td colspan="5" class="py-4 text-center text-gray-500">Belum ada data tahunan.</td></tr>`;
          return;
        }

        summaryBody.innerHTML = "";
        const yearlyData = {};
        const initialBalance = relevantTrades[0].balance;

        relevantTrades.forEach((trade) => {
          const tradeDate = new Date(trade.timestamp);
          const yearKey = `${tradeDate.getFullYear()}`;

          if (!yearlyData[yearKey]) {
            yearlyData[yearKey] = {
              tradeCount: 0,
              pips: 0,
              pl: 0,
              yearName: yearKey,
            };
          }

          const tradeResult = getTradeResult(trade);
          const pointsForTrade = tradeResult.isWin
            ? getVisualPoints(trade.tpPips, trade.symbol, true).forCalc
            : -getVisualPoints(trade.slPips, trade.symbol, true).forCalc;

          yearlyData[yearKey].pips += pointsForTrade;
          yearlyData[yearKey].pl += tradeResult.profitLoss;
          yearlyData[yearKey].tradeCount++;
        });

        const sortedYearKeys = Object.keys(yearlyData).sort();
        let cumulativeTradeCount = 0,
          cumulativePips = 0,
          cumulativePL = 0;

        for (const yearKey of sortedYearKeys) {
          const year = yearlyData[yearKey];
          cumulativeTradeCount += year.tradeCount;
          cumulativePips += year.pips;
          cumulativePL += year.pl;

          const cumulativeBalance = initialBalance + cumulativePL;
          const cumulativePercentage =
            initialBalance > 0 ? (cumulativePL / initialBalance) * 100 : 0;

          summaryBody.insertAdjacentHTML(
            "beforeend",
            `
                  <tr>
                      <td class="py-3 px-4 text-center">${year.yearName}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePercentage >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePercentage, 2)}%</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativePips >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${formatNumber(cumulativePips, 0)}</td>
                      <td class="py-3 px-4 text-center">${cumulativeTradeCount}</td>
                      <td class="py-3 px-4 text-center ${
                        cumulativeBalance >= initialBalance
                          ? "positive-value"
                          : "negative-value"
                      }">${formatCurrency(cumulativeBalance, "USD")}</td>
                  </tr>
              `
          );
        }
      }

      // --- TAMBAHKAN FUNGSI BARU INI ---
      function downloadMonthlyPLSummaryAsExcel(filename) {
        const summaryBody = document.getElementById("monthlyPLSummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan P/L bulanan untuk diunduh.",
            false
          );
          return;
        }
        // Perbarui header sesuai dengan tabel baru
        const headers = [
          "Bulan",
          "Presentase Akumulasi (%)",
          "Total Eksekusi",
          "TP / SL",
          "Total Eksekusi Bersih",
          "TP Bersih ($)",
          "Akumulasi Nett ($)",
          "Total Saldo ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";

        for (const row of summaryBody.rows) {
          const rowData = Array.from(row.cells).map((cell) => {
            // Membersihkan data sebelum dimasukkan ke CSV
            let cellText = cell.textContent.replace(/[$,%]/g, "").trim();
            // Menangani format "TP / SL"
            if (cellText.includes("/")) {
              cellText = `"${cellText}"`; // Apit dengan kutip agar tidak dianggap pemisah
            }
            return cellText;
          });
          csvContent += rowData.join(",") + "\r\n";
        }

        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // --- TAMBAHKAN EVENT LISTENER BARU INI ---
      const downloadMonthlyPLBtn = document.getElementById(
        "downloadMonthlyPLSummaryBtn"
      );
      if (downloadMonthlyPLBtn) {
        downloadMonthlyPLBtn.addEventListener("click", () => {
          downloadMonthlyPLSummaryAsExcel(
            `Ringkasan_PL_Bulanan_${new Date().toISOString().slice(0, 10)}.csv`
          );
        });
      }

      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      /**
       * PERBAIKAN: Menggabungkan data baru dan lama, lalu mengurutkannya
       * berdasarkan Waktu Keluar (timestamp) dari yang TERBARU ke TERLAMA.
       */
      function updateAllDataAndRenderUI(
        newCalculated,
        newRunning,
        newExecuted
      ) {
        // 1. GABUNGKAN DATA: Menambahkan data baru ke data yang sudah ada.
        if (newCalculated && newCalculated.length > 0) {
          calculatedPlansData.push(...newCalculated);
        }
        if (newRunning && newRunning.length > 0) {
          runningPlansData.push(...newRunning);
        }
        if (newExecuted && newExecuted.length > 0) {
          executedPlansData.push(...newExecuted);
        }

        // 2. URUTKAN DENGAN BENAR & AMAN: Mengurutkan berdasarkan Waktu Keluar (Terbaru -> Lama).
        executedPlansData.sort((a, b) => {
          const dateA = a.timestamp ? new Date(a.timestamp) : null;
          const dateB = b.timestamp ? new Date(b.timestamp) : null;

          const aIsValid = dateA && !isNaN(dateA.getTime());
          const bIsValid = dateB && !isNaN(dateB.getTime());

          // --- PERBAIKAN UTAMA ADA DI BARIS INI ---
          if (aIsValid && bIsValid) return dateB - dateA; // Mengurutkan dari terbaru (descending)
          // --- AKHIR PERBAIKAN ---

          if (bIsValid) return 1;
          if (aIsValid) return -1;
          return 0;
        });

        // 3. Simpan dan Render Ulang Semuanya
        saveDataToLocalStorage();
        renderCalculatedPlans();
        renderRunningPlans();
        renderExecutedPlans();
        calculateSummaryStatistics();
        updateRiskRewardStatistics();
        calculateAndRenderMonthlyPLSummary();
        calculateAndRenderDailySummary();
        calculateAndRenderWeeklySummary();
        calculateAndRenderNewMonthlySummary();
        calculateAndRenderYearlySummary();
        fetchAndRenderOutcomeRadarChart();
        fetchAndRenderCombinedCumulativeChart();

        console.log(
          "UI dan semua data telah digabungkan dan diperbarui dengan benar."
        );
      }

      // --- AKHIR DARI BLOK PENGGANTIAN ---

      function downloadDailySummaryAsExcel(filename) {
        const summaryBody = document.getElementById("newDailySummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan harian untuk diunduh.",
            false
          );
          return;
        }
        const headers = [
          "Tanggal",
          "Presentase Kumulatif (%)",
          "Total Pips Kumulatif",
          "Total Trade",
          "Saldo Akhir Kumulatif ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";
        for (const row of summaryBody.rows) {
          const rowData = Array.from(row.cells).map(
            (cell) => `"${cell.textContent.replace(/[%$,]/g, "").trim()}"`
          );
          csvContent += rowData.join(",") + "\r\n";
        }
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
      }

      function downloadWeeklySummaryAsExcel(filename) {
        const summaryBody = document.getElementById("newWeeklySummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan mingguan untuk diunduh.",
            false
          );
          return;
        }
        const headers = [
          "Minggu",
          "Presentase Kumulatif (%)",
          "Total Pips Kumulatif",
          "Total Trade",
          "Saldo Akhir Kumulatif ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";
        for (const row of summaryBody.rows) {
          const rowData = Array.from(row.cells).map(
            (cell) => `"${cell.textContent.replace(/[%$,]/g, "").trim()}"`
          );
          csvContent += rowData.join(",") + "\r\n";
        }
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
      }

      function downloadYearlySummaryAsExcel(filename) {
        const summaryBody = document.getElementById("newYearlySummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan tahunan untuk diunduh.",
            false
          );
          return;
        }
        const headers = [
          "Tahun",
          "Presentase Kumulatif (%)",
          "Total Pips Kumulatif",
          "Total Trade",
          "Saldo Akhir Kumulatif ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";
        for (const row of summaryBody.rows) {
          const rowData = Array.from(row.cells).map(
            (cell) => `"${cell.textContent.replace(/[%$,]/g, "").trim()}"`
          );
          csvContent += rowData.join(",") + "\r\n";
        }
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
      }

      function downloadNewMonthlySummaryAsExcel(filename) {
        const summaryBody = document.getElementById("newMonthlySummaryBody");
        if (
          !summaryBody ||
          summaryBody.rows.length === 0 ||
          (summaryBody.rows.length === 1 &&
            summaryBody.rows[0].cells.length <= 1)
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data ringkasan bulanan untuk diunduh.",
            false
          );
          return;
        }

        const headers = [
          "Bulan",
          "Presentase Kumulatif (%)",
          "Total Pips Kumulatif",
          "Total Trade",
          "Saldo Akhir Kumulatif ($)",
        ];
        let csvContent = headers.join(",") + "\r\n";

        for (const row of summaryBody.rows) {
          const rowData = [];
          for (const cell of row.cells) {
            let cellText = cell.textContent
              .replace(/[%$]/g, "")
              .replace(/,/g, "")
              .trim();
            if (cellText.includes(",")) {
              cellText = `"${cellText}"`;
            }
            rowData.push(cellText);
          }
          csvContent += rowData.join(",") + "\r\n";
        }

        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // --- CORE CALCULATOR LOGIC ---
      const getAssetData = (symbol) =>
        assetValues[symbol] || {
          decimals: 5,
          pipValue: 10.0,
          contractSize: 100000,
          type: "forexMajor",
          currency: "USD",
          minLotIncrement: 0.01,
          pipsDecimals: 1,
        };

      // Updated calculatePipsPoints to correctly handle different asset types
      function calculatePipsPoints(priceDiff, symbol) {
        const assetData = getAssetData(symbol);
        if (!assetData) return 0; // Handle unknown symbol

        if (assetData.type.includes("forex")) {
          // For 5-decimal forex pairs (e.g., EUR/USD), 1 pip = 0.0001 (multiplier 10000)
          // For 3-decimal forex pairs (e.g., USD/JPY), 1 pip = 0.01 (multiplier 100)
          const pipMultiplier = assetData.decimals === 5 ? 10000 : 100;
          return priceDiff * pipMultiplier;
        }
        // For other assets (indices, commodities, crypto), priceDiff is directly the "points"
        return priceDiff;
      }

      // --- LETAKKAN FUNGSI BARU DI SINI ---
      function renderCalendar(date) {
        if (!calendarBody || !monthYearDisplay) return;

        calendarBody.innerHTML = "";
        const year = date.getFullYear();
        const month = date.getMonth();
        const today = new Date();

        monthYearDisplay.textContent = new Date(year, month).toLocaleString(
          "id-ID",
          {
            month: "long",
            year: "numeric",
          }
        );

        const firstDayOfMonth = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();

        // Hari dari bulan sebelumnya
        const daysInPrevMonth = new Date(year, month, 0).getDate();
        for (let i = firstDayOfMonth; i > 0; i--) {
          const day = daysInPrevMonth - i + 1;
          calendarBody.innerHTML += `<div class="calendar-date prev-month">${day}</div>`;
        }

        // Hari dari bulan ini
        for (let i = 1; i <= daysInMonth; i++) {
          let classes = "calendar-date";
          if (
            i === today.getDate() &&
            month === today.getMonth() &&
            year === today.getFullYear()
          ) {
            classes += " today";
          }
          calendarBody.innerHTML += `<div class="${classes}">${i}</div>`;
        }

        // Hari dari bulan berikutnya
        const totalCells = calendarBody.children.length;
        const nextDays = (7 - (totalCells % 7)) % 7;
        for (let i = 1; i <= nextDays; i++) {
          calendarBody.innerHTML += `<div class="calendar-date next-month">${i}</div>`;
        }
      }

      /**
       * FUNGSI BANTUAN BARU: Mengonversi data dari <tbody> tabel HTML menjadi format Array of Arrays.
       * @param {HTMLElement} tableBodyElement - Elemen <tbody> dari tabel yang akan dibaca.
       * @param {Array<string>} headers - Array berisi string header untuk baris pertama.
       * @returns {Array<Array<string>>} Data tabel dalam format AoA.
       */
      function tableToAoA(tableBodyElement, headers) {
        const data = [headers]; // Mulai dengan baris header
        if (tableBodyElement && tableBodyElement.rows.length > 0) {
          // Cek jika baris pertama adalah pesan "tidak ada data"
          if (tableBodyElement.rows[0].cells.length <= 1) {
            return data; // Kembalikan hanya header jika tidak ada data
          }
          for (const row of tableBodyElement.rows) {
            const rowData = Array.from(row.cells).map((cell) => {
              // Bersihkan teks dari karakter mata uang, persen, dan koma ribuan
              return cell.textContent.replace(/[$,%]/g, "").trim();
            });
            data.push(rowData);
          }
        }
        return data;
      }

      // --- GANTI SELURUH FUNGSI LAMA DI BAWAH INI DENGAN VERSI BARU ---
      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
      /**
       * PERBAIKAN UTAMA: Logika kalkulasi diubah total sesuai permintaan.
       * Nett SL/TP sekarang dihitung berdasarkan: Lot Size * Visual Pips * Pip Value.
       * Lot Size dihitung dari risiko yang ditentukan pengguna.
       */
      function calculateRow(rowId) {
        const rowElement = document.getElementById(`inputRow-${rowId}`);
        if (!rowElement) return null;
        const tradeType = rowElement
          .querySelector(`#buyBtn-${rowId}`)
          .classList.contains("active")
          ? "BUY"
          : "SELL";
        const inputs = [
          "symbol",
          "balance",
          "riskPercent",
          "priceNow",
          "openPrice",
          "slPrice",
          "tpPrice",
          "note",
        ].reduce(
          (acc, id) => ({
            ...acc,
            [id]: rowElement.querySelector(`#${id}-${rowId}`),
          }),
          {}
        );

        // 1. Validasi input dasar
        const selectedSymbol = inputs.symbol.value;
        const balance = parseFloat(inputs.balance.value);
        const riskPercent = parseFloat(inputs.riskPercent.value);
        const priceNow = parseFloat(inputs.priceNow.value);
        const openPrice = parseFloat(inputs.openPrice.value);
        const slPrice = parseFloat(inputs.slPrice.value);
        const tpPrice = parseFloat(inputs.tpPrice.value);
        const note = inputs.note.value.trim();

        // (Bagian validasi input tidak berubah, jadi kita lewati untuk keringkasan)
        let isValid = true;
        // ... (kode validasi isNaN, dll. tetap sama)
        if (
          !selectedSymbol ||
          isNaN(balance) ||
          isNaN(riskPercent) ||
          isNaN(openPrice) ||
          isNaN(slPrice) ||
          isNaN(tpPrice)
        ) {
          // (Logika untuk menandai input yang salah tetap sama)
          return { error: true };
        }

        const assetData = getAssetData(selectedSymbol);

        // 2. Hitung Pips/Points Presisi (untuk rasio) dan Visual (untuk tampilan & kalkulasi Nett)
        const priceDiffSL =
          tradeType === "BUY" ? openPrice - slPrice : slPrice - openPrice;
        const priceDiffTP =
          tradeType === "BUY" ? tpPrice - openPrice : openPrice - tpPrice;
        const priceDiffPending =
          tradeType === "BUY" ? priceNow - openPrice : openPrice - priceNow;

        if (priceDiffSL <= 0 || priceDiffTP <= 0) return { error: true }; // Validasi SL/TP tetap

        const slPipsPrecise = calculatePipsPoints(priceDiffSL, selectedSymbol);
        const tpPipsPrecise = calculatePipsPoints(priceDiffTP, selectedSymbol);
        const pendingPipsPrecise = calculatePipsPoints(
          priceDiffPending,
          selectedSymbol
        );

        // Nilai visual yang akan ditampilkan di tabel
        const visualSLPoints = getVisualPoints(
          slPipsPrecise,
          selectedSymbol
        ).forCalc;
        const visualTPPoints = getVisualPoints(
          tpPipsPrecise,
          selectedSymbol
        ).forCalc;

        // 3. Kalkulasi Lot Size (berdasarkan risiko yang ditentukan)
        const riskAmount = balance * (riskPercent / 100);
        const { pipValue, minLotIncrement } = assetData;

        // Rumus baru untuk lot size: Lot = Risk Amount / (Visual SL Pips * Pip Value)
        const rawLotSize =
          visualSLPoints > 0 && pipValue > 0
            ? riskAmount / (visualSLPoints * pipValue)
            : 0;

        // Sesuaikan dengan kenaikan lot minimum
        let finalLotSize =
          Math.floor(rawLotSize / minLotIncrement) * minLotIncrement;
        if (finalLotSize === 0 && rawLotSize > 0)
          finalLotSize = minLotIncrement;

        // 4. Kalkulasi Nett SL dan Nett TP (berdasarkan rumus baru)
        const finalNettSL = -(finalLotSize * visualSLPoints * pipValue);
        const finalNettTP = finalLotSize * visualTPPoints * pipValue;

        // 5. Kalkulasi R:R dan Persentase
        const rrPips = slPipsPrecise > 0 ? tpPipsPrecise / slPipsPrecise : 0;
        const [percentageSL, percentageTP] =
          balance > 0
            ? [
                (Math.abs(finalNettSL) / balance) * 100,
                (finalNettTP / balance) * 100,
              ]
            : [0, 0];

        // 6. Kembalikan hasil
        return {
          rowId,
          symbol: selectedSymbol,
          tradeType,
          balance,
          entryTime: new Date().toISOString(),
          openPrice,
          slPrice,
          tpPrice,
          priceNow,
          pendingPips: pendingPipsPrecise,
          slPips: slPipsPrecise,
          tpPips: tpPipsPrecise,
          rrPips,
          rrPercentage: { sl: percentageSL, tp: percentageTP },
          lotSize: finalLotSize,
          nettSL: finalNettSL,
          nettTP: finalNettTP,
          error: false,
          assetData,
          riskPercent: riskPercent,
          note,
        };
      }

      function displayCalculationDetails(result) {
        calculationDetailsContainer.innerHTML = "";
        // This section is now hidden by default and might be used for single-plan details if needed in the future
        // For now, it won't display anything unless explicitly made visible and populated.
      }

      function calculateAllRows() {
        console.log("Calculating all rows...");
        calculatedPlansData = []; // Clear previous calculated plans
        const allInputRows = document.querySelectorAll(".input-row");
        if (allInputRows.length === 0) {
          renderCalculatedPlans(); // Render empty table
          return;
        }
        allInputRows.forEach((row) => {
          const rowId = row.id.split("-")[1];
          const result = calculateRow(rowId);
          if (result && !result.error) {
            addDataToDatabase(result);
            calculatedPlansData.push(result);
          }
        });
        renderCalculatedPlans();
        console.log(
          "Calculation complete. Calculated Plans:",
          calculatedPlansData.length
        );
      }

      async function addDataToDatabase(result) {
        await fetch("http://101.50.2.92:4578/api/trade", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
          body: JSON.stringify({
            rowId: result.rowId,
            symbol: result.symbol,
            tradeType: result.tradeType,
            balance: result.balance,
            entryTime: result.entryTime,
            openPrice: result.openPrice,
            slPrice: result.slPrice,
            tpPrice: result.tpPrice,
            priceNow: result.priceNow,
            pendingPips: result.pendingPips,
            slPips: result.slPips,
            tpPips: result.tpPips,
            rrPips: result.rrPips,
            rrPercentage: result.rrPercentage,
            lotSize: result.lotSize,
            nettSL: result.nettSL,
            nettTP: result.nettTP,
            error: result.error,
            assetData: result.assetData,
            riskPercent: result.riskPercent,
            note: result.note,
          }),
        });
      }

      // --- ▼▼▼ GANTI SELURUH FUNGSI INI ▼▼▼ ---
      function renderPlans(
        plans,
        bodyElement,
        colspan,
        emptyMessage,
        isCalculated = false,
        isRunning = false
      ) {
        bodyElement.innerHTML = "";

        const isExecutedPlanTable = bodyElement.id === "executedPlansBody";

        if (plans.length === 0) {
          bodyElement.innerHTML = `<tr><td colspan="${colspan}" class="py-4 text-center text-gray-500">${emptyMessage}</td></tr>`;
          return;
        }

        plans.forEach((plan) => {
          const createComparisonHtml = (
            newValue,
            oldValue,
            isPositive = true
          ) => `
                  <div class="flex flex-col items-center">
                      <span class="${
                        isPositive ? "positive-value" : "negative-value"
                      } font-semibold">${newValue}</span>
                      <span class="text-xs text-gray-400 line-through">${oldValue}</span>
                  </div>`;

          const {
            id,
            symbol,
            tradeType,
            balance,
            entryTime,
            priceNow,
            openPrice,
            slPrice,
            tpPrice,
            pendingPips,
            slPips,
            tpPips,
            rrPips,
            lotSize,
            nettSL,
            nettTP,
            note,
            assetData,
            outcome,
            timestamp,
            rowId,
            originalNettSL,
            originalNettTP,
            originalTpPrice,
            originalTpPips,
            originalRrPips,
            originalRrPercentage,
          } = plan;

          const currentAssetData = assetData || getAssetData(symbol);

          // Siapkan variabel untuk nilai yang akan ditampilkan
          let display_tpPrice = formatNumber(
            tpPrice,
            currentAssetData.decimals,
            false
          );
          let display_tpPips = getVisualPoints(tpPips, symbol, true).display;
          let display_rrPips =
            rrPips > 0 ? "1:" + formatNumber(rrPips, 1, false) : "N/A";
          let display_rrPercentage = plan.rrPercentage;
          let display_nettTP = `<span class="${
            nettTP >= 0 ? "positive-value" : "negative-value"
          }">${formatCurrency(nettTP, "USD")}</span>`;
          let display_nettSL = `<span class="negative-value">${formatCurrency(
            nettSL,
            "USD"
          )}</span>`;

          // --- LOGIKA UTAMA UNTUK TAMPILAN 'SEBELUM & SESUDAH' ---
          if (isExecutedPlanTable) {
            // PERBAIKAN: Tambahkan '!isNaN()' untuk memastikan nilai "original" adalah angka yang valid, bukan NaN.
            if (
              typeof originalTpPrice === "number" &&
              !isNaN(originalTpPrice) &&
              originalTpPrice !== tpPrice
            ) {
              display_tpPrice = createComparisonHtml(
                formatNumber(tpPrice, currentAssetData.decimals, false),
                formatNumber(originalTpPrice, currentAssetData.decimals, false)
              );
            }
            if (
              typeof originalTpPips === "number" &&
              !isNaN(originalTpPips) &&
              originalTpPips !== tpPips
            ) {
              display_tpPips = createComparisonHtml(
                getVisualPoints(tpPips, symbol, true).display,
                getVisualPoints(originalTpPips, symbol, true).display
              );
            }
            if (
              typeof originalRrPips === "number" &&
              !isNaN(originalRrPips) &&
              originalRrPips !== rrPips
            ) {
              display_rrPips = createComparisonHtml(
                rrPips > 0 ? "1:" + formatNumber(rrPips, 1, false) : "N/A",
                originalRrPips > 0
                  ? "1:" + formatNumber(originalRrPips, 1, false)
                  : "N/A"
              );
            }
            if (
              typeof originalNettSL === "number" &&
              !isNaN(originalNettSL) &&
              originalNettSL !== nettSL
            ) {
              display_nettSL = createComparisonHtml(
                formatCurrency(nettSL, "USD"),
                formatCurrency(originalNettSL, "USD"),
                false
              );
            }
            if (
              typeof originalNettTP === "number" &&
              !isNaN(originalNettTP) &&
              originalNettTP !== nettTP
            ) {
              display_nettTP = createComparisonHtml(
                formatCurrency(nettTP, "USD"),
                formatCurrency(originalNettTP, "USD"),
                nettTP >= 0
              );
            }
          }
          // --- AKHIR DARI LOGIKA TAMPILAN ---

          let rrPercentageHtml = '<span class="neutral-value">N/A</span>';
          if (
            display_rrPercentage &&
            typeof display_rrPercentage.sl !== "undefined"
          ) {
            rrPercentageHtml = `<span class="negative-value">-${formatNumber(
              display_rrPercentage.sl,
              2
            )}%</span> : <span class="${
              display_rrPercentage.tp >= 0 ? "positive-value" : "negative-value"
            }">${formatNumber(display_rrPercentage.tp, 2)}%</span>`;

            // PERBAIKAN: Tambahkan '!isNaN()' untuk R:R % juga.
            if (
              isExecutedPlanTable &&
              originalRrPercentage &&
              typeof originalRrPercentage.tp === "number" &&
              !isNaN(originalRrPercentage.tp) &&
              originalRrPercentage.tp !== display_rrPercentage.tp
            ) {
              const originalHtml = `<span class="negative-value">-${formatNumber(
                originalRrPercentage.sl,
                2
              )}%</span> : <span class="${
                originalRrPercentage.tp >= 0
                  ? "positive-value"
                  : "negative-value"
              }">${formatNumber(originalRrPercentage.tp, 2)}%</span>`;
              rrPercentageHtml = createComparisonHtml(
                rrPercentageHtml,
                originalHtml,
                display_rrPercentage.tp >= 0
              );
            }
          }

          const slPipsDisplay = getVisualPoints(slPips, symbol, true).display;
          const pendingPipsDisplay = getVisualPoints(
            pendingPips,
            symbol,
            isExecutedPlanTable
          ).display;
          const entryTimeHtml = formatDateAndTime(entryTime);
          const exitTimeHtml = timestamp ? formatDateAndTime(timestamp) : "N/A";
          const outcomeText =
            outcome === "Cancel"
              ? "Dibatalkan"
              : outcome === "Tes"
              ? "Tes Selesai"
              : outcome === "Stop Loss"
              ? "Selesai: SL"
              : outcome === "Take Profit"
              ? "Selesai: TP"
              : "Running";

          let actionButtonsHtml = "";
          if (isCalculated) {
            actionButtonsHtml = `<button type="button" class="action-button-small" data-from-section="calculated" data-outcome="Running" data-row-id="${rowId}" data-id="${id}">Set Running</button>`;
          } else if (isRunning) {
            const formattedTime = new Date(entryTime)
              .toLocaleTimeString("id-ID", {
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
              })
              .replace(/\./g, ":");
            const timeInfoHtml = `<span class="text-gray-400 font-mono text-xs ml-2">(${formattedTime})</span>`;

            actionButtonsHtml = `
                      <button type="button" class="action-button-small" data-from-section="running" data-outcome="Tes" data-row-id="${rowId}" data-id="${id}">TES ${timeInfoHtml}</button>
                      <button type="button" class="action-button-small" data-from-section="running" data-outcome="Cancel" data-row-id="${rowId}" data-id="${id}">BATAL ${timeInfoHtml}</button>
                      <button type="button" class="action-button-small" data-from-section="running" data-outcome="Stop Loss" data-row-id="${rowId}" data-id="${id}">SL ${timeInfoHtml}</button>
                      <button type="button" class="action-button-small" data-from-section="running" data-outcome="Take Profit" data-row-id="${rowId}" data-id="${id}">TP ${timeInfoHtml}</button>
                      <button type="button" class="action-button-small" data-from-section="running" data-outcome="Edit" data-row-id="${rowId}" data-id="${id}">EDIT ${timeInfoHtml}</button>
                  `;
          }

          bodyElement.insertAdjacentHTML(
            "beforeend",
            `
                  <tr class="hover:bg-gray-50">
                      <td>${symbol}</td>
                      <td class="font-semibold ${
                        tradeType === "BUY"
                          ? "positive-value"
                          : "negative-value"
                      }">${tradeType}</td>
                      <td>${formatCurrency(balance, "USD")}</td>
                      <td>${entryTimeHtml}</td>
                      <td>${formatNumber(
                        priceNow,
                        currentAssetData.decimals,
                        false
                      )}</td>
                      <td>${formatNumber(
                        openPrice,
                        currentAssetData.decimals,
                        false
                      )}</td>
                      <td>${formatNumber(
                        slPrice,
                        currentAssetData.decimals,
                        false
                      )}</td>
                      <td>${display_tpPrice}</td>
                      <td class="${
                        pendingPipsDisplay >= 0
                          ? "positive-value"
                          : "negative-value"
                      }">${pendingPipsDisplay}</td>
                      <td class="neutral-value">${slPipsDisplay}</td>
                      <td class="positive-value">${display_tpPips}</td>
                      <td>${display_rrPips}</td>
                      <td>${rrPercentageHtml}</td>
                      <td class="${
                        lotSize === 0 ? "negative-value" : "neutral-value"
                      }">${formatNumber(lotSize, 2)}</td>
                      <td>${display_nettSL}</td>
                      <td>${display_nettTP}</td>
                      <td>${note || "-"}</td>
                      ${
                        isCalculated || isRunning
                          ? `<td class="action-buttons-cell">${actionButtonsHtml}</td>`
                          : `<td><span>${outcomeText}</span></td><td>${exitTimeHtml}</td>`
                      }
                  </tr>
              `
          );
        });

        // --- PERBAIKAN: Seluruh blok 'forEach' yang memasang event listener dari sini DIHAPUS. ---
        // Kode ini menyebabkan konflik dan sudah tidak diperlukan karena ditangani oleh
        // fungsi global 'handleActionClick'.

        // --- ▲▲▲ HINGGA DI SINI ▲▲▲ ---

        // --- INI BAGIAN PERBAIKAN ---
        // Event listener sekarang dipasang dengan benar untuk memanggil fungsi yang sudah ada.
        bodyElement
          .querySelectorAll(".action-button-small")
          .forEach((button) => {
            button.addEventListener("click", (event) => {
              // --- PERBAIKAN UTAMA: Menggunakan data-entry-time ---
              const { rowId, outcome, fromSection, entryTime } =
                event.target.closest(".action-button-small").dataset;

              if (fromSection === "calculated") {
                setRunning(rowId);
              } else if (fromSection === "running") {
                const entryTime = button.dataset.entryTime;
                const outcome = button.dataset.outcome;

                const planToConfirm = runningPlansData.find(
                  (p) => p.entryTime === entryTime
                );

                if (!planToConfirm) {
                  console.error(
                    "Tidak dapat menemukan detail trade untuk konfirmasi:",
                    entryTime
                  );
                  showMessageBox(
                    "Gagal",
                    "Tidak dapat menemukan detail trade. Coba muat ulang halaman.",
                    false
                  );
                  return;
                }

                // --- PERBAIKAN UTAMA: Memperbarui isi notifikasi agar lebih detail ---
                const rrPipsFormatted =
                  planToConfirm.rrPips > 0
                    ? "1:" + formatNumber(planToConfirm.rrPips, 1, false)
                    : "N/A";
                let rrPercentageHtml = "N/A";
                if (planToConfirm.rrPercentage) {
                  rrPercentageHtml = `<span class="negative-value">-${formatNumber(
                    planToConfirm.rrPercentage.sl,
                    2
                  )}%</span> : <span class="positive-value">${formatNumber(
                    planToConfirm.rrPercentage.tp,
                    2
                  )}%</span>`;
                }

                // Membuat HTML detail yang baru dan lengkap
                const detailsHtml = `
              <div class="text-left text-xs space-y-1 bg-gray-50 p-4 rounded-lg border border-gray-200 grid grid-cols-2 gap-x-4 gap-y-2">
                  <p><strong>Aset:</strong></p> <p>${planToConfirm.symbol}</p>
                  <p><strong>Tipe Trade:</strong></p> <p><span class="${
                    planToConfirm.tradeType === "BUY"
                      ? "positive-value"
                      : "negative-value"
                  } font-semibold">${planToConfirm.tradeType}</span></p>
                  <p><strong>Balance Akun:</strong></p> <p>${formatCurrency(
                    planToConfirm.balance,
                    "USD"
                  )}</p>
                  <p><strong>Waktu Masuk:</strong></p> <p>${formatDateAndTimeForExport(
                    planToConfirm.entryTime
                  )}</p>
                  <p><strong>Open Price:</strong></p> <p>${formatNumber(
                    planToConfirm.openPrice,
                    planToConfirm.assetData.decimals,
                    false
                  )}</p>
                  <p><strong>SL Price:</strong></p> <p>${formatNumber(
                    planToConfirm.slPrice,
                    planToConfirm.assetData.decimals,
                    false
                  )}</p>
                  <p><strong>TP Price:</strong></p> <p>${formatNumber(
                    planToConfirm.tpPrice,
                    planToConfirm.assetData.decimals,
                    false
                  )}</p>
                  <p><strong>Pending Pips:</strong></p> <p>${
                    getVisualPoints(
                      planToConfirm.pendingPips,
                      planToConfirm.symbol
                    ).display
                  }</p>
                  <p><strong>SL Pips:</strong></p> <p>${
                    getVisualPoints(planToConfirm.slPips, planToConfirm.symbol)
                      .display
                  }</p>
                  <p><strong>TP Pips:</strong></p> <p>${
                    getVisualPoints(planToConfirm.tpPips, planToConfirm.symbol)
                      .display
                  }</p>
                  <p><strong>R:R Pips:</strong></p> <p>${rrPipsFormatted}</p>
                  <p><strong>R:R %:</strong></p> <div>${rrPercentageHtml}</div>
                  <p><strong>Lot/Units:</strong></p> <p>${formatNumber(
                    planToConfirm.lotSize,
                    2
                  )}</p>
                  <p><strong>Nett SL:</strong></p> <p class="negative-value">${formatCurrency(
                    planToConfirm.nettSL,
                    "USD"
                  )}</p>
                  <p><strong>Nett TP:</strong></p> <p class="positive-value">${formatCurrency(
                    planToConfirm.nettTP,
                    "USD"
                  )}</p>
                  <p><strong>Catatan:</strong></p> <p>${
                    planToConfirm.note || "-"
                  }</p>
              </div>
              <hr class="my-4">
          `;
                // --- AKHIR PERBAIKAN ---

                if (outcome === "Edit") {
                  const confirmationMessage = `<p class="text-sm text-center">Yakin ingin <strong>MENGEDIT</strong> trade ini? Rencana akan kembali ke formulir input.</p>`;
                  showMessageBox(
                    "Konfirmasi: Edit",
                    detailsHtml + confirmationMessage,
                    true
                  ).then((result) => {
                    if (result.confirmed) editRunningPlan(entryTime);
                  });
                } else {
                  const actionText =
                    outcome === "Cancel"
                      ? "MEMBATALKAN"
                      : outcome.toUpperCase();
                  const confirmationMessage = `<p class="text-sm text-center">Yakin ingin menyelesaikan trade ini dengan hasil <strong>${actionText}</strong>?</p>`;

                  showMessageBox(
                    `Konfirmasi: ${outcome}`,
                    detailsHtml + confirmationMessage,
                    true,
                    { editableNettValues: true, plan: planToConfirm }
                  ).then((result) => {
                    if (result.confirmed) {
                      completeTrade(entryTime, outcome, fromSection, result);
                    }
                  });
                }
              }
            });
          });
      }

      function renderCalculatedPlans() {
        console.log(
          "Rendering calculated plans. Data length:",
          calculatedPlansData.length
        );
        renderPlans(
          calculatedPlansData,
          calculatedPlansBody,
          18,
          "Belum ada rencana trading baru.",
          true,
          false
        );
      }

      function renderRunningPlans() {
        console.log(
          "Rendering running plans. Data length:",
          runningPlansData.length
        );
        renderPlans(
          runningPlansData,
          runningPlansBody,
          18,
          "Belum ada rencana trading aktif.",
          false,
          true
        );
        updateActivePlansSummary();
      }

      async function renderExecutedPlans() {
        console.log(
          "Rendering executed plans. Data length:",
          executedPlansData.length
        );
        renderPlans(
          executedPlansData,
          executedPlansBody,
          19,
          "Belum ada rencana trading yang selesai."
        );
        updateRiskRewardStatistics();
      }

      /**
       * FUNGSI BANTUAN BARU: Mengatur skala grafik agar responsif.
       * @param {Array} labels - Daftar semua label untuk sumbu-X.
       * @param {string} yAxisTitle - Judul untuk sumbu-Y.
       * @param {Function} yTickCallback - Fungsi untuk memformat label sumbu-Y.
       * @param {boolean} yBeginAtZero - Apakah sumbu-Y harus dimulai dari nol.
       * @returns {Object} Konfigurasi skala untuk Chart.js.
       */
      function getResponsiveChartScales(
        labels,
        yAxisTitle,
        yTickCallback,
        yBeginAtZero = false
      ) {
        const isMobile = window.innerWidth <= 768;
        const totalLabels = labels.length;

        // Tentukan indeks yang akan ditampilkan di mobile
        const indicesToShow = new Set();
        if (totalLabels > 0) {
          indicesToShow.add(0); // Selalu tampilkan yang pertama
          indicesToShow.add(Math.floor((totalLabels - 1) / 2)); // Tampilkan yang tengah
          indicesToShow.add(totalLabels - 1); // Selalu tampilkan yang terakhir
        }

        return {
          x: {
            title: {
              display: true,
              text: "Tanggal & Waktu Trade",
              color: "#555",
              font: { family: "Inter", size: 8, weight: "bold" },
            },
            ticks: {
              color: "#555",
              font: { family: "Inter", size: 7 },
              callback: function (value, index, ticks) {
                // Di mobile, hanya tampilkan label pada indeks yang telah ditentukan
                if (isMobile && totalLabels > 3) {
                  // Terapkan hanya jika ada lebih dari 3 data
                  if (indicesToShow.has(index)) {
                    // Mengambil label asli dari array `labels`
                    return labels[index];
                  }
                  return null; // Sembunyikan label lainnya
                }
                // Di desktop, tampilkan semua label
                return labels[index];
              },
              autoSkip: false, // Wajib untuk memastikan callback kita berjalan untuk semua label
            },
          },
          y: {
            beginAtZero: yBeginAtZero,
            title: {
              display: true,
              text: yAxisTitle,
              color: "#555",
              font: { family: "Inter", size: 8, weight: "bold" },
            },
            ticks: {
              callback: yTickCallback,
              color: "#555",
              font: { family: "Inter", size: 7 },
            },
          },
        };
      }

      // --- LETAKKAN FUNGSI BARU INI DI SINI ---
      // --- ▼▼▼ GANTI SELURUH FUNGSI checkMonthlyPerformanceAndLockout DENGAN FUNGSI BARU INI ▼▼▼ ---

      // --- ▼▼▼ GANTI SELURUH FUNGSI checkAllTradeLimits LAMA DENGAN FUNGSI BARU INI ▼▼▼ ---

      /**
       * FUNGSI BARU & KOMPREHENSIF: Memeriksa semua aturan batas kerugian dan penguncian.
       * @returns {{isLocked: boolean, reason: string}}
       */
      function checkAllTradeLimits() {
        const now = new Date();
        const currentDay = now.getDate();
        const currentMonthIdentifier = `${now.getFullYear()}-${now.getMonth()}`;
        const todayDateString = now.toISOString().slice(0, 10); // Format: YYYY-MM-DD

        // --- PERBAIKAN 1: Logika terpisah untuk memeriksa penguncian Harian ---
        const lockedDate = localStorage.getItem("tradingLockoutDate");
        if (lockedDate && lockedDate === todayDateString) {
          const lockedReason =
            localStorage.getItem("tradingLockoutReason") ||
            `Trading dikunci karena batas kerugian harian tercapai.`;
          return { isLocked: true, reason: lockedReason };
        } else if (lockedDate && lockedDate !== todayDateString) {
          // Hari baru telah dimulai, hapus kunci harian yang lama.
          localStorage.removeItem("tradingLockoutDate");
          localStorage.removeItem("tradingLockoutReason"); // Hapus juga alasannya
        }
        // --- AKHIR PERBAIKAN 1 ---

        // 1. Cek apakah penguncian bulanan sudah aktif dari sesi sebelumnya.
        const lockedMonth = localStorage.getItem("tradingLockoutMonth");
        if (lockedMonth && lockedMonth === currentMonthIdentifier) {
          const lockedReason =
            localStorage.getItem("tradingLockoutReason") ||
            `Trading dikunci hingga awal bulan berikutnya.`;
          return { isLocked: true, reason: lockedReason };
        } else if (lockedMonth && lockedMonth !== currentMonthIdentifier) {
          // Bulan baru telah dimulai, hapus kunci bulanan yang lama.
          localStorage.removeItem("tradingLockoutMonth");
          localStorage.removeItem("tradingLockoutReason");
        }

        // --- Mulai Kalkulasi Performa ---
        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          return { isLocked: false, reason: "" }; // Tidak ada data, tidak ada kunci.
        }

        const initialBalanceOverall = relevantTrades[0].balance;
        const finalBalanceOverall = relevantTrades.reduce(
          (balance, trade) => balance + getTradeResult(trade).profitLoss,
          initialBalanceOverall
        );
        const overallPercentage =
          initialBalanceOverall > 0
            ? ((finalBalanceOverall - initialBalanceOverall) /
                initialBalanceOverall) *
              100
            : 0;

        // Kalkulasi Bulanan
        const tradesThisMonth = relevantTrades.filter(
          (t) =>
            new Date(t.timestamp).getMonth() === now.getMonth() &&
            new Date(t.timestamp).getFullYear() === now.getFullYear()
        );
        let monthlyPercentage = 0,
          peakCumulativePercentage = 0;
        if (tradesThisMonth.length > 0) {
          const initialBalanceThisMonth = tradesThisMonth[0].balance;
          let cumulativePL = 0;
          tradesThisMonth.forEach((trade) => {
            cumulativePL += getTradeResult(trade).profitLoss;
            const currentPercentage =
              initialBalanceThisMonth > 0
                ? (cumulativePL / initialBalanceThisMonth) * 100
                : 0;
            if (currentPercentage > peakCumulativePercentage) {
              peakCumulativePercentage = currentPercentage;
            }
          });
          monthlyPercentage =
            initialBalanceThisMonth > 0
              ? (cumulativePL / initialBalanceThisMonth) * 100
              : 0;
        }

        // Kalkulasi Harian
        const tradesToday = tradesThisMonth.filter(
          (t) => new Date(t.timestamp).getDate() === currentDay
        );
        let dailyPercentage = 0;
        if (tradesToday.length > 0) {
          const initialBalanceToday = tradesToday[0].balance;
          const dailyPL = tradesToday.reduce(
            (sum, trade) => sum + getTradeResult(trade).profitLoss,
            0
          );
          dailyPercentage =
            initialBalanceToday > 0 ? (dailyPL / initialBalanceToday) * 100 : 0;
        }

        // --- Pengecekan Aturan Secara Berurutan ---
        let reason = "";
        let isDailyLock = false; // Flag untuk menandai jenis kunci

        if (overallPercentage <= OVERALL_MAX_LOSS_LIMIT) {
          reason = `Anda telah mencapai batas kerugian maksimal keseluruhan (${formatNumber(
            OVERALL_MAX_LOSS_LIMIT,
            2
          )}%). Trading dikunci hingga awal bulan berikutnya.`;
        } else if (monthlyPercentage <= MONTHLY_LOSS_LIMIT) {
          reason = `Anda telah mencapai batas kerugian bulanan (${formatNumber(
            MONTHLY_LOSS_LIMIT,
            2
          )}%). Trading dikunci hingga awal bulan berikutnya.`;
        } else if (dailyPercentage <= DAILY_LOSS_LIMIT) {
          reason = `Anda telah mencapai batas kerugian harian (${formatNumber(
            DAILY_LOSS_LIMIT,
            2
          )}%). Trading dikunci hingga esok hari.`;
          isDailyLock = true; // Tandai ini sebagai kunci harian
        } else if (
          currentDay >= 26 &&
          peakCumulativePercentage >= 5 &&
          monthlyPercentage >= 2 &&
          monthlyPercentage <= 2.5
        ) {
          reason = `Trading terkunci karena drawdown di akhir bulan (profit turun ke ${formatNumber(
            monthlyPercentage,
            2
          )}%). Trading akan dibuka kembali pada tanggal 1 bulan berikutnya.`;
        }

        // --- PERBAIKAN 2: Simpan kunci ke localStorage yang benar ---
        if (reason) {
          if (isDailyLock) {
            localStorage.setItem("tradingLockoutDate", todayDateString);
          } else {
            // Untuk semua alasan lain, gunakan kunci bulanan
            localStorage.setItem("tradingLockoutMonth", currentMonthIdentifier);
          }
          localStorage.setItem("tradingLockoutReason", reason);
          return { isLocked: true, reason: reason };
        }
        // --- AKHIR PERBAIKAN 2 ---

        return { isLocked: false, reason: "" };
      }

      // --- ▲▲▲ HINGGA DI SINI ▲▲▲ ---

      // --- LETAKKAN FUNGSI BARU INI TEPAT SETELAH FUNGSI checkMonthlyPerformanceAndLockout() ---

      /**
       * FUNGSI BARU: Memeriksa performa setelah trade selesai & memicu notifikasi.
       * @param {object} completedTrade - Objek data trade yang baru saja selesai.
       */
      function checkPerformanceAndNotify(completedTrade) {
        const now = new Date();
        // Ambil semua trade yang valid di bulan ini, termasuk yang baru saja selesai
        const tradesThisMonth = executedPlansData
          .filter(
            (t) =>
              getTradeResult(t).isValid &&
              new Date(t.timestamp).getMonth() === now.getMonth() &&
              new Date(t.timestamp).getFullYear() === now.getFullYear()
          )
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (tradesThisMonth.length === 0) return; // Keluar jika tidak ada data

        // Tentukan balance awal untuk bulan ini dari trade pertama di bulan tersebut
        const initialBalanceThisMonth = tradesThisMonth[0].balance;

        // Hitung total Profit/Loss setelah trade ini selesai
        const totalPLAfter = tradesThisMonth.reduce(
          (sum, t) => sum + getTradeResult(t).profitLoss,
          0
        );

        // Hitung total Profit/Loss SEBELUM trade ini (untuk perbandingan)
        const totalPLBefore =
          totalPLAfter - getTradeResult(completedTrade).profitLoss;

        const percentageAfter =
          initialBalanceThisMonth > 0
            ? (totalPLAfter / initialBalanceThisMonth) * 100
            : 0;
        const percentageBefore =
          initialBalanceThisMonth > 0
            ? (totalPLBefore / initialBalanceThisMonth) * 100
            : 0;

        // --- PERBAIKAN: Aturan notifikasi "Overconfident" ditambahkan untuk semua tingkatan ---
        const milestones = [5, 8, 10, 15, 20];
        milestones.forEach((milestone) => {
          if (percentageAfter >= milestone && percentageBefore < milestone) {
            setTimeout(
              () =>
                showMessageBox(
                  `Pencapaian ${milestone}% Tercapai!`,
                  `Selamat, Anda telah mencapai profit bulanan ${milestone}%! Jangan menjadi terlalu percaya diri (OVERCONFIDENT) dan tetap jaga psikologi trading Anda.`,
                  false
                ),
              500
            );
          }
        });
        // --- AKHIR PERBAIKAN ---
      }
      // --- ▼▼▼ GANTI SELURUH FUNGSI DI BAWAH INI ▼▼▼ ---
      // --- GANTI SELURUH FUNGSI LAMA DI BAWAH INI DENGAN VERSI BARU ---
      /**
       * PERBAIKAN: Menyelesaikan trade, menangani nilai yang diedit dari pop-up,
       * dan memindahkan data ke tabel Rencana Trading Selesai.
       * @param {string} rowId - Pengenal unik untuk trade (ID baris).
       * @param {string} outcome - Hasil trade (TP, SL, dll.).
       * @param {string} fromSection - Asal tabel ('running').
       * @param {Object} result - Objek hasil dari pop-up, berisi nilai yang diedit.
       */
      async function completeTrade(
        rowId,
        outcome,
        fromSection,
        result = {},
        id
      ) {
        console.log(
          `Menyelesaikan trade untuk rowId: ${rowId} dengan hasil: ${outcome}`,
          result
        );

        // PERBAIKAN: Mencari berdasarkan 'rowId' bukan 'entryTime'
        const index = runningPlansData.findIndex(
          (plan) => plan.rowId === rowId
        );
        if (index === -1) {
          console.warn(`Trade dengan rowId ${rowId} tidak ditemukan.`);
          return;
        }
        const nows = new Date();
        saveRunningPlan(
          id,
          "EXECUTED",
          outcome,
          nows.toISOString(),
          runningPlansData[index].tpPrice,
          runningPlansData[index].nettSL,
          runningPlansData[index].nettTP,
          runningPlansData[index].rrPercentage.sl,
          runningPlansData[index].rrPercentage.tp,
          runningPlansData[index].rrPips,
          runningPlansData[index].tpPips,
          runningPlansData[index].slPips
        );
        // Buat salinan untuk dimodifikasi
        const planToExecute = { ...runningPlansData[index] };

        if (!planToExecute.assetData) {
          planToExecute.assetData = getAssetData(planToExecute.symbol);
        }

        // Simpan nilai asli untuk perbandingan di tabel hasil
        planToExecute.originalNettSL = planToExecute.nettSL;
        planToExecute.originalNettTP = planToExecute.nettTP;

        // Opsi 1: Jika pengguna mengedit TP Price, hitung ulang semua nilai terkait
        if (
          typeof result.editedTpPrice === "number" &&
          outcome === "Take Profit"
        ) {
          // Simpan nilai asli lainnya untuk ditampilkan sebagai perbandingan
          planToExecute.originalTpPrice = planToExecute.tpPrice;
          planToExecute.originalTpPips = planToExecute.tpPips;
          planToExecute.originalRrPips = planToExecute.rrPips;
          planToExecute.originalRrPercentage = {
            ...planToExecute.rrPercentage,
          };

          // Perbarui TP Price dengan nilai baru dari input
          planToExecute.tpPrice = result.editedTpPrice;

          // Hitung ulang TP Pips dari harga baru
          const priceDiffTP =
            planToExecute.tradeType === "BUY"
              ? planToExecute.tpPrice - planToExecute.openPrice
              : planToExecute.openPrice - planToExecute.tpPrice;
          planToExecute.tpPips = calculatePipsPoints(
            priceDiffTP,
            planToExecute.symbol
          );

          // Hitung ulang R:R Pips
          planToExecute.rrPips =
            planToExecute.slPips > 0
              ? planToExecute.tpPips / planToExecute.slPips
              : 0;

          // Hitung ulang Nett TP menggunakan rumus yang benar
          const visualTPPoints = getVisualPoints(
            planToExecute.tpPips,
            planToExecute.symbol,
            true
          ).forCalc;
          const pipValue = planToExecute.assetData.pipValue;
          planToExecute.nettTP =
            planToExecute.lotSize * visualTPPoints * pipValue;
        } else {
          // Opsi 2: Jika pengguna hanya mengedit Nett SL/TP secara langsung
          if (typeof result.editedNettSL === "number")
            planToExecute.nettSL = result.editedNettSL;
          if (typeof result.editedNettTP === "number")
            planToExecute.nettTP = result.editedNettTP;
        }

        // Setelah semua nilai Nett final, hitung ulang R:R %
        if (planToExecute.balance > 0) {
          planToExecute.rrPercentage.sl =
            (Math.abs(planToExecute.nettSL) / planToExecute.balance) * 100;
          planToExecute.rrPercentage.tp =
            (planToExecute.nettTP / planToExecute.balance) * 100;
        } else {
          planToExecute.rrPercentage = { sl: 0, tp: 0 };
        }

        // Hapus rencana dari 'Aktif'
        runningPlansData.splice(index, 1);
        await editRunningPlan(id);
        await updatePrice(
          id,
          planToExecute.tpPrice,
          planToExecute.nettSL,
          planToExecute.nettTP,
          planToExecute.rrPercentage.sl,
          planToExecute.rrPercentage.tp,
          planToExecute.rrPips,
          planToExecute.tpPips,
          planToExecute.slPips
        );

        // Atur properti akhir dan tambahkan ke 'Selesai'
        planToExecute.outcome = outcome;
        planToExecute.timestamp = new Date().toISOString();
        if (outcome === "Tes")
          planToExecute.note = "Tes selesai, silakan cek Ringkasan Bulanan.";

        executedPlansData.push(planToExecute);

        // Simpan dan perbarui UI
        if (db && userId !== "anonymous") {
          await saveExecutedPlan(userId, planToExecute);
        } else {
          saveDataToLocalStorage();
        }

        // Panggil fungsi notifikasi performa SEBELUM merender ulang UI
        checkPerformanceAndNotify(planToExecute);

        updateAllDataAndRenderUI();
        console.log("Trade selesai diproses dan data berhasil diperbarui.");
      }
      // --- ▲▲▲ HINGGA DI SINI ▲▲▲

      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      // --- ▼▼▼ GANTI SELURUH FUNGSI setRunning LAMA DENGAN FUNGSI BARU INI ▼▼▼ ---

      async function setRunning(rowId, id) {
        // 1. Panggil validasi penguncian kerugian yang komprehensif.
        const lockoutStatus = checkAllTradeLimits();
        if (lockoutStatus.isLocked) {
          showMessageBox("Trading Terkunci", lockoutStatus.reason, false);
          return; // Hentikan eksekusi jika terkunci.
        }

        const index = calculatedPlansData.findIndex((plan) => plan.id === id);
        if (index === -1) {
          return;
        }
        const planToRun = calculatedPlansData[index];

        // 2. Validasi batas risiko aktif (MAX_ACTIVE_RISK_PERCENT).
        const currentActiveRisk = runningPlansData.reduce(
          (total, plan) => total + (plan.rrPercentage?.sl || 0),
          0
        );
        const newTotalActiveRisk =
          currentActiveRisk + (planToRun.rrPercentage?.sl || 0);

        if (newTotalActiveRisk > MAX_ACTIVE_RISK_PERCENT) {
          showMessageBox(
            "Batas Risiko Aktif Tercapai",
            `Menjalankan trade ini akan membuat total risiko aktif Anda (${formatNumber(
              newTotalActiveRisk,
              2
            )}%) melebihi batas (${formatNumber(
              MAX_ACTIVE_RISK_PERCENT,
              2
            )}%).`,
            false
          );
          return; // Hentikan eksekusi jika melebihi batas.
        }

        calculatedPlansData.splice(index, 1);
        runningPlansData.push(planToRun);
        await saveRunningPlan(id);
        saveDataToLocalStorage();

        renderCalculatedPlans();
        renderRunningPlans();
        console.log("Trade moved to Running plans.");
      }

      // --- ▲▲▲ HINGGA DI SINI ▲▲▲ ---
      async function editRunningPlan(rowId, id) {
        console.log(`Mengedit trade yang berjalan untuk rowId: ${rowId}`);
        // PERBAIKAN UTAMA: Mencari berdasarkan 'rowId' bukan 'entryTime'
        const index = runningPlansData.findIndex(
          (plan) => plan.rowId === rowId
        );
        if (index !== -1) {
          const planToEdit = runningPlansData.splice(index, 1)[0];
          await deleteRunningPlan(userId, id);
          saveDataToLocalStorage();

          addInputRow(planToEdit);

          renderRunningPlans();
          console.log(
            "Trade dipindahkan dari rencana Berjalan ke formulir input untuk diedit."
          );
        }
      }

      // --- DYNAMIC INPUT ROW MANAGEMENT ---
      function addInputRow(initialData = {}) {
        rowCounter++;
        const newRowId = `inputRow-${rowCounter}`;
        const groupedAssets = {
          "Forex Mayor": [],
          "Forex Cross Rate": [],
          "Forex Eksotis": [],
          Komoditas: [],
          Indeks: [],
          Kripto: [],
        };
        Object.keys(assetValues).forEach((symbol) => {
          const asset = assetValues[symbol];
          let categoryLabel;
          switch (asset.type) {
            case "forexMajor":
              categoryLabel = "Forex Mayor";
              break;
            case "forexCross":
              categoryLabel = "Forex Cross Rate";
              break;
            case "forexExotic":
              categoryLabel = "Forex Eksotis";
              break;
            case "commodity":
              categoryLabel = "Komoditas";
              break;
            case "index":
              categoryLabel = "Indeks";
              break;
            case "crypto":
              categoryLabel = "Kripto";
              break;
            default:
              categoryLabel = "Lainnya";
          }
          if (!groupedAssets[categoryLabel]) groupedAssets[categoryLabel] = [];
          groupedAssets[categoryLabel].push(symbol);
        });
        let symbolsOptions =
          '<option value="" disabled selected>Pilih Aset</option>'; // Added default option
        const categoryOrder = [
          "Forex Mayor",
          "Forex Cross Rate",
          "Forex Eksotis",
          "Komoditas",
          "Indeks",
          "Kripto",
          "Lainnya",
        ];
        categoryOrder.forEach((category) => {
          if (groupedAssets[category] && groupedAssets[category].length > 0) {
            symbolsOptions += `<optgroup label="${category}">`;
            groupedAssets[category].sort().forEach((symbol) => {
              symbolsOptions += `<option value="${symbol}">${symbol}</option>`;
            });
            symbolsOptions += `</optgroup>`;
          }
        });
        const rowHtml = `
                      <div id="${newRowId}" class="input-row bg-white p-6 rounded-lg border border-gray-200 relative">
                          <button type="button" class="delete-row-btn absolute top-3 right-3"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button>
                          <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-y-4 gap-x-6">
                              <div><label for="symbol-${rowCounter}" class="block text-sm input-label mb-1">Aset</label><select id="symbol-${rowCounter}" name="symbol" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-gray-300 focus:border-gray-300 sm:text-sm select-field">${symbolsOptions}</select></div>
                              <div><label for="tradeType-${rowCounter}" class="block text-sm input-label mb-1">Tipe Trade</label><div class="flex rounded-md shadow-sm"><button type="button" id="buyBtn-${rowCounter}" class="buy-button w-1/2 py-2 px-4 rounded-l-md border text-center font-medium">BUY</button><button type="button" id="sellBtn-${rowCounter}" class="sell-button w-1/2 py-2 px-4 rounded-r-md border text-center font-medium">SELL</button></div></div>
                              <div><label for="balance-${rowCounter}" class="block text-sm input-label mb-1">Balance Akun ($)</label><input type="number" id="balance-${rowCounter}" name="balance" step="0.01" value="${
          initialData.balance !== undefined ? initialData.balance : ""
        }" placeholder="Cth: 10000" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                              <div class="input-group-percent"><label for="riskPercent-${rowCounter}" class="block text-sm input-label mb-1">Risiko (%)</label><div class="flex mt-1"><input type="number" id="riskPercent-${rowCounter}" name="riskPercent" step="0.01" value="${
          initialData.riskPercent !== undefined ? initialData.riskPercent : ""
        }" placeholder="Cth: 0.2" class="block w-full border rounded-l-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"><span class="inline-flex items-center px-3 border border-l-0 rounded-r-md text-sm font-medium"> % </span></div><p id="riskLimitNote-${rowCounter}" class="text-red-500 text-xs mt-1 hidden">Risiko maksimal adalah ${MAX_RISK_PER_TRADE}%</p></div>
                              <div><label for="priceNow-${rowCounter}" class="block text-sm input-label mb-1">Price Now</label><input type="number" id="priceNow-${rowCounter}" name="priceNow" step="any" value="${
          initialData.priceNow !== undefined ? initialData.priceNow : ""
        }" placeholder="Cth: 1.07500 / 35000.50" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                              <div><label for="openPrice-${rowCounter}" class="block text-sm input-label mb-1">Open Price</label><input type="number" id="openPrice-${rowCounter}" name="openPrice" step="any" value="${
          initialData.openPrice !== undefined ? initialData.openPrice : ""
        }" placeholder="Cth: 1.07500 / 35000.50" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field">
                              </div>
                              <div><label for="slPrice-${rowCounter}" class="block text-sm input-label mb-1">SL Price</label><input type="number" id="slPrice-${rowCounter}" name="slPrice" step="any" value="${
          initialData.slPrice !== undefined ? initialData.slPrice : ""
        }" placeholder="Cth: 1.07000 / 34900.00" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                              <div><label for="tpPrice-${rowCounter}" class="block text-sm input-label mb-1">TP Price</label><input type="number" id="tpPrice-${rowCounter}" name="tpPrice" step="any" value="${
          initialData.tpPrice !== undefined ? initialData.tpPrice : ""
        }" placeholder="Cth: 1.09000 / 35500.00" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                              <div><label for="note-${rowCounter}" class="block text-sm input-label mb-1">Catatan (Opsional)</label><input type="text" id="note-${rowCounter}" name="note" value="${
          initialData.note !== undefined ? initialData.note : ""
        }" placeholder="Cth: Breakout strategy" class="mt-1 block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none sm:text-sm input-field"></div>
                          </div>
                      </div>
                  `;
        inputRowsContainer.insertAdjacentHTML("beforeend", rowHtml);

        // Attach event listeners to all inputs in the new row to save data automatically
        const newRowElement = document.getElementById(newRowId);
        newRowElement.querySelectorAll("input, select").forEach((input) => {
          input.addEventListener("change", saveInputRowsToLocalStorage);
        });
        const buyBtn = newRowElement.querySelector(`#buyBtn-${rowCounter}`);
        const sellBtn = newRowElement.querySelector(`#sellBtn-${rowCounter}`);

        buyBtn.addEventListener("click", () => {
          buyBtn.classList.add("active");
          sellBtn.classList.remove("active");
          saveInputRowsToLocalStorage();
        });
        sellBtn.addEventListener("click", () => {
          sellBtn.classList.add("active");
          buyBtn.classList.remove("active");
          saveInputRowsToLocalStorage();
        });

        newRowElement
          .querySelector(".delete-row-btn")
          .addEventListener("click", () => {
            newRowElement.remove();
            saveInputRowsToLocalStorage();
          });

        const symbolSelect = document.getElementById(`symbol-${rowCounter}`);
        const priceNowInput = document.getElementById(`priceNow-${rowCounter}`);
        const openPriceInput = document.getElementById(
          `openPrice-${rowCounter}`
        );
        const slPriceInput = document.getElementById(`slPrice-${rowCounter}`);
        const tpPriceInput = document.getElementById(`tpPrice-${rowCounter}`);

        const updatePriceInputStepsAndFormat = (selectedSymbol) => {
          const assetData = getAssetData(selectedSymbol);
          const decimals = assetData ? assetData.decimals : 5;
          const stepValue = getStepValue(decimals);

          [priceNowInput, openPriceInput, slPriceInput, tpPriceInput].forEach(
            (input) => {
              if (input) {
                // Add null check here
                input.setAttribute("step", stepValue);
                if (input.value !== "") {
                  // Only format the value if it's not empty, to avoid changing user's partial input
                  input.value = parseFloat(input.value).toFixed(decimals);
                }
              }
            }
          );
        };

        if (symbolSelect) {
          // Add null check here
          symbolSelect.addEventListener("change", (event) => {
            updatePriceInputStepsAndFormat(event.target.value);
          });
        }

        // Apply formatting on blur for price inputs
        [priceNowInput, openPriceInput, slPriceInput, tpPriceInput].forEach(
          (input) => {
            if (input) {
              // Add null check here
              input.addEventListener("blur", (event) => {
                if (symbolSelect && event.target.value !== "") {
                  // Add null check and empty string check
                  const assetData = getAssetData(symbolSelect.value);
                  const decimals = assetData ? assetData.decimals : 5;
                  event.target.value = parseFloat(event.target.value).toFixed(
                    decimals
                  );
                }
              });
            }
          }
        );

        if (initialData.tradeType === "BUY") {
          if (buyBtn) buyBtn.classList.add("active");
          if (sellBtn) sellBtn.classList.remove("active");
        } else if (initialData.tradeType === "SELL") {
          if (sellBtn) sellBtn.classList.add("active");
          if (buyBtn) buyBtn.classList.remove("active");
        } else {
          if (buyBtn) buyBtn.classList.add("active");
          if (sellBtn) sellBtn.classList.remove("active");
        }

        if (initialData.symbol && symbolSelect) {
          // Add null check here
          symbolSelect.value = initialData.symbol;
          // Pastikan pemformatan awal dan pengaturan langkah untuk data yang dimuat
          updatePriceInputStepsAndFormat(initialData.symbol);
        }

        const riskPercentInput = document.getElementById(
          `riskPercent-${rowCounter}`
        );
        const riskLimitNote = document.getElementById(
          `riskLimitNote-${rowCounter}`
        );
        if (riskPercentInput) {
          // Add null check here
          riskPercentInput.addEventListener("input", () => {
            let value = parseFloat(riskPercentInput.value);
            if (isNaN(value)) {
              if (riskLimitNote) riskLimitNote.classList.add("hidden");
              return;
            }
            if (value > MAX_RISK_PER_TRADE) {
              riskPercentInput.value = MAX_RISK_PER_TRADE;
              if (riskLimitNote) riskLimitNote.classList.remove("hidden");
            } else {
              if (riskLimitNote) riskLimitNote.classList.add("hidden");
            }
          });
        }
        if (newRowElement) {
          // Add null check here
          newRowElement.scrollIntoView({
            behavior: "smooth",
            block: "nearest",
          });
        }
        console.log("Baris input ditambahkan:", newRowId);
      }

      /*
      /**
       * FUNGSI PERBAIKAN: Mengonversi array data menjadi string CSV dan memicu unduhan.
       * Fungsi ini memastikan semua data diformat dengan benar agar tidak rusak saat dibuka di Excel.
       * @param {string} filename - Nama file yang akan diunduh.
       * @param {Array<Object>} dataArray - Array berisi objek data.
       * @param {Array<string>} headers - Array berisi header untuk kolom CSV.
       */
      function downloadAsExcel(filename, dataArray, headers) {
        if (!dataArray || dataArray.length === 0) {
          showMessageBox("Informasi", "Tidak ada data untuk diunduh.", false);
          return;
        }

        // Fungsi bantuan untuk memformat setiap sel agar sesuai dengan standar CSV
        const formatCsvCell = (value) => {
          let valueStr =
            value !== undefined && value !== null ? String(value) : "";

          // Jika nilai mengandung karakter yang perlu "dilindungi" (kutip, koma, atau baris baru)
          if (valueStr.search(/("|,|\n)/g) >= 0) {
            // 1. Ganti setiap tanda kutip (") di dalam nilai menjadi dua tanda kutip ("")
            valueStr = valueStr.replace(/"/g, '""');
            // 2. Apit seluruh nilai dengan sepasang tanda kutip
            valueStr = `"${valueStr}"`;
          }
          return valueStr;
        };

        // Buat baris header
        const headerRow = headers
          .map((header) => formatCsvCell(header))
          .join(",");

        // Buat semua baris data
        const dataRows = dataArray.map((row) => {
          // Ambil nilai dari objek 'row' sesuai urutan di 'headers'
          return headers
            .map((header) => {
              const value = row[header];
              // Kolom "R:R %" memiliki format khusus yang sudah diberi kutip, jadi kita tangani secara spesifik
              // untuk menghindari kutip ganda yang salah.
              if (
                header === "R:R %" &&
                typeof value === "string" &&
                value.startsWith('"') &&
                value.endsWith('"')
              ) {
                return formatCsvCell(value.substring(1, value.length - 1));
              }
              return formatCsvCell(value);
            })
            .join(",");
        });

        // Gabungkan header dan baris data
        const csvContent = [headerRow, ...dataRows].join("\r\n");

        // Buat file dan picu unduhan (dengan BOM untuk kompatibilitas Excel)
        const blob = new Blob(
          [new Uint8Array([0xef, 0xbb, 0xbf]), csvContent],
          { type: "text/csv;charset=utf-8;" }
        );
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", filename);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      /**
       * PERBAIKAN: Menambahkan "Price Now" dan menyamakan nama header dengan permintaan.
       * @param {Object} plan - Objek data rencana trading.
       * @param {string} status - Status rencana ('Baru', 'Aktif', 'Selesai').
       * @returns {Object} Objek yang sudah diformat untuk ekspor.
       */
      function preparePlanForExport(plan, status) {
        const currentAssetData = plan.assetData || getAssetData(plan.symbol);
        const rrPercentageString = plan.rrPercentage
          ? `${-formatNumber(plan.rrPercentage.sl, 2)}% : ${formatNumber(
              plan.rrPercentage.tp,
              2
            )}%`
          : "N/A";
        const originalRrPercentageString = plan.originalRrPercentage
          ? `${-formatNumber(
              plan.originalRrPercentage.sl,
              2
            )}% : ${formatNumber(plan.originalRrPercentage.tp, 2)}%`
          : "N/A";
        const isForExecutedTable = status === "Selesai";

        return {
          Status: status,
          Aset: plan.symbol || "N/A",
          Trade: plan.tradeType,
          "Balance Akun": plan.balance,
          "Waktu Masuk": formatDateAndTimeForExport(plan.entryTime),
          "Price Now": formatNumber(
            plan.priceNow,
            currentAssetData.decimals,
            false
          ),
          "Open Price": formatNumber(
            plan.openPrice,
            currentAssetData.decimals,
            false
          ),
          "SL Price": formatNumber(
            plan.slPrice,
            currentAssetData.decimals,
            false
          ),
          "TP Price": formatNumber(
            plan.tpPrice,
            currentAssetData.decimals,
            false
          ),
          OriginalTpPrice:
            typeof plan.originalTpPrice === "number"
              ? formatNumber(
                  plan.originalTpPrice,
                  currentAssetData.decimals,
                  false
                )
              : "N/A",
          "Pending Pips/Points": getVisualPoints(
            plan.pendingPips,
            plan.symbol,
            isForExecutedTable
          ).display,
          "SL Pips/Points": getVisualPoints(
            plan.slPips,
            plan.symbol,
            isForExecutedTable
          ).display,
          "TP Pips/Points": getVisualPoints(
            plan.tpPips,
            plan.symbol,
            isForExecutedTable
          ).display,
          OriginalTpPips:
            typeof plan.originalTpPips === "number"
              ? getVisualPoints(
                  plan.originalTpPips,
                  plan.symbol,
                  isForExecutedTable
                ).display
              : "N/A",
          "R:R Pips":
            plan.rrPips > 0
              ? `1:${formatNumber(plan.rrPips, 1, false)}`
              : "N/A",
          OriginalRrPips:
            typeof plan.originalRrPips === "number" && plan.originalRrPips > 0
              ? `1:${formatNumber(plan.originalRrPips, 1, false)}`
              : "N/A",
          "R:R %": rrPercentageString,
          OriginalRrPercentage: originalRrPercentageString,
          "Lot/Units": formatNumber(plan.lotSize, 2),
          "Nett SL": plan.nettSL,
          "Nett TP": plan.nettTP,
          OriginalNettSL: plan.originalNettSL,
          OriginalNettTP: plan.originalNettTP,
          Catatan: plan.note || "-",
          Hasil: plan.outcome || "N/A",
          "Waktu Keluar": formatDateAndTimeForExport(plan.timestamp),
        };
      }

      if (downloadExecutedExcelBtn) {
        downloadExecutedExcelBtn.addEventListener("click", () => {
          // PERBAIKAN: Header disesuaikan dengan permintaan, termasuk "Price Now" dan lainnya.
          const headers = [
            "Status",
            "Aset",
            "Trade",
            "Balance Akun",
            "Waktu Masuk",
            "Price Now",
            "Open Price",
            "SL Price",
            "TP Price",
            "Pending Pips/Points",
            "SL Pips/Points",
            "TP Pips/Points",
            "R:R Pips",
            "R:R %",
            "Lot/Units",
            "Nett SL",
            "Nett TP",
            "OriginalNettSL",
            "OriginalNettTP",
            "Catatan",
            "Hasil",
            "Waktu Keluar",
          ];

          const dataToExport = executedPlansData.map((plan) =>
            preparePlanForExport(plan, "Selesai")
          );
          downloadAsExcel(
            `Rencana_Trading_Selesai_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`,
            dataToExport,
            headers
          );
        });
      }

      // --- GANTI SELURUH BLOK FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
      if (deleteAndExportDataBtn) {
        deleteAndExportDataBtn.addEventListener("click", async () => {
          if (executedPlansData.length === 0) {
            showMessageBox(
              "Informasi",
              "Tidak ada data untuk diunduh atau dihapus.",
              false
            );
            return;
          }

          const confirmed = await showMessageBox(
            "Unduh & Hapus Data Selesai?",
            'Anda akan mengunduh semua data dari "Rencana Trading Selesai", lalu menghapusnya secara permanen. Lanjutkan?',
            true
          );

          if (!confirmed) {
            showMessageBox("Dibatalkan", "Proses dibatalkan.", false);
            return;
          }

          try {
            // PERBAIKAN: Header disesuaikan dengan permintaan, termasuk "Price Now" dan lainnya.
            const headers = [
              "Status",
              "Aset",
              "Trade",
              "Balance Akun",
              "Waktu Masuk",
              "Price Now",
              "Open Price",
              "SL Price",
              "TP Price",
              "Pending Pips/Points",
              "SL Pips/Points",
              "TP Pips/Points",
              "R:R Pips",
              "R:R %",
              "Lot/Units",
              "Nett SL",
              "Nett TP",
              "OriginalNettSL",
              "OriginalNettTP",
              "Catatan",
              "Hasil",
              "Waktu Keluar",
            ];
            const dataToExport = executedPlansData.map((plan) =>
              preparePlanForExport(plan, "Selesai")
            );
            downloadAsExcel(
              `ARSIP_Rencana_Trading_Selesai_${new Date()
                .toISOString()
                .slice(0, 10)}.csv`,
              dataToExport,
              headers
            );

            await deleteAllExecutedPlans();

            executedPlansData = [];
            await initializeAppFromLocalStorage();

            showMessageBox(
              "Berhasil",
              "Data telah diunduh dan berhasil dihapus.",
              false
            );
          } catch (error) {
            console.error("Gagal saat proses unduh & hapus:", error);
            showMessageBox(
              "Gagal",
              "Terjadi kesalahan saat proses unduh & hapus. Data tidak dihapus.",
              false
            );
          }
        });
      }

      async function exportToPdf(elementId, filename) {
        const element = document.getElementById(elementId);
        if (!element) {
          console.log("Elemen tidak ditemukan untuk diunduh PDF.");
          return;
        }
        const loadingDiv = document.createElement("div");
        loadingDiv.style.cssText =
          "position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.7);color:white;padding:20px;border-radius:10px;z-index:1000;";
        loadingDiv.textContent = "Membuat PDF...";
        document.body.appendChild(loadingDiv);
        try {
          const canvas = await html2canvas(element, { scale: 2 });
          const imgData = canvas.toDataURL("image/png");
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF("p", "mm", "a4");
          const imgWidth = 210;
          const pageHeight = 297;
          const imgHeight = (canvas.height * imgWidth) / canvas.width;
          let heightLeft = imgHeight;
          let position = 0;
          pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
          heightLeft -= pageHeight;
          while (heightLeft >= 0) {
            position = heightLeft - imgHeight;
            pdf.addPage();
            pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
            heightLeft -= pageHeight;
          }
          pdf.save(filename);
        } catch (error) {
          console.error("Error generating PDF:", error);
          console.log("Gagal membuat PDF: " + error.message);
        } finally {
          document.body.removeChild(loadingDiv);
        }
      }

      /**
       * FUNGSI BANTUAN BARU: Memaksa semua bagian (terutama grafik) untuk dirender
       * sebelum diekspor ke PDF, mengatasi masalah lazy loading dan animasi.
       */
      async function renderAllSectionsForExport() {
        console.log("Force-rendering all sections for PDF export...");
        const renderPromises = [];
        // Loop melalui semua bagian yang terdaftar di chartSections
        for (const sectionId in chartSections) {
          const chartInfo = chartSections[sectionId];
          // Jika bagian tersebut memiliki fungsi render, jalankan
          if (chartInfo && typeof chartInfo.render === "function") {
            renderPromises.push(chartInfo.render());
          }
        }
        // Tunggu semua proses render selesai
        await Promise.all(renderPromises);
        console.log("All sections rendered for export.");
      }

      /**
       * MEMPERBAIKI FUNGSI INI SECARA KESELURUHAN
       * Membuat dan mengunduh file Excel komprehensif yang berisi semua data trading dan statistik,
       * memastikan isinya sama persis dengan data tabel di unduhan PDF.
       * @param {string} filename - Nama file yang akan diunduh.
       */
      async function downloadAllDataAsExcel(filename) {
        if (
          executedPlansData.length === 0 &&
          runningPlansData.length === 0 &&
          calculatedPlansData.length === 0
        ) {
          showMessageBox(
            "Informasi",
            "Tidak ada data trading untuk diunduh.",
            false
          );
          return;
        }

        try {
          const wb = XLSX.utils.book_new();

          // --- (Bagian Statistik & Ringkasan tidak berubah) ---
          const { summaryStats, riskStats } = getDetailedStatisticsForExport();
          // ... (Kode untuk membuat sheet 1 - 8) ...

          // --- PERBAIKAN PADA BAGIAN RENCANA TRADING ---
          const planHeaders = [
            "Status",
            "Aset",
            "Trade",
            "Balance Akun",
            "Waktu Masuk",
            "Price Now",
            "Open Price",
            "SL Price",
            "TP Price",
            "Pending Pips/Points",
            "SL Pips/Points",
            "TP Pips/Points",
            "R:R Pips",
            "R:R %",
            "Lot/Units",
            "Nett SL",
            "Nett TP",
            "OriginalNettSL",
            "OriginalNettTP",
            "Catatan",
            "Hasil",
            "Waktu Keluar",
          ];
          const tradeDataColWidths = [
            { wch: 10 },
            { wch: 15 },
            { wch: 8 },
            { wch: 15 },
            { wch: 20 },
            { wch: 15 },
            { wch: 15 },
            { wch: 15 },
            { wch: 15 },
            { wch: 18 },
            { wch: 15 },
            { wch: 15 },
            { wch: 12 },
            { wch: 18 },
            { wch: 12 },
            { wch: 15 },
            { wch: 15 },
            { wch: 15 },
            { wch: 15 },
            { wch: 25 },
            { wch: 15 },
            { wch: 20 },
          ];

          const convertPlansToAoA = (plans, status) => {
            return plans.map((p) => {
              const formattedPlan = preparePlanForExport(p, status);
              return planHeaders.map((header) => formattedPlan[header]);
            });
          };

          if (calculatedPlansData.length > 0) {
            const body = convertPlansToAoA(calculatedPlansData, "Baru");
            const ws = XLSX.utils.aoa_to_sheet([planHeaders, ...body]);
            ws["!cols"] = tradeDataColWidths;
            XLSX.utils.book_append_sheet(wb, ws, "9. Rencana Trading Baru");
          }

          if (runningPlansData.length > 0) {
            const body = convertPlansToAoA(runningPlansData, "Aktif");
            const ws = XLSX.utils.aoa_to_sheet([planHeaders, ...body]);
            ws["!cols"] = tradeDataColWidths;
            XLSX.utils.book_append_sheet(wb, ws, "10. Rencana Trading Aktif");
          }

          if (executedPlansData.length > 0) {
            const body = convertPlansToAoA(executedPlansData, "Selesai");
            const ws = XLSX.utils.aoa_to_sheet([planHeaders, ...body]);
            ws["!cols"] = tradeDataColWidths;
            XLSX.utils.book_append_sheet(wb, ws, "11. Rencana Trading Selesai");
          }
          // --- AKHIR PERBAIKAN ---

          XLSX.writeFile(wb, filename);
          showMessageBox(
            "Berhasil",
            "File Excel yang komprehensif telah berhasil diunduh.",
            false
          );
        } catch (error) {
          console.error("Gagal membuat file Excel:", error);
          showMessageBox(
            "Gagal Mengunduh",
            "Terjadi kesalahan saat menyiapkan data untuk diunduh.",
            false
          );
        }
      }
      // --- GANTI FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      async function downloadAllDataAsPdf(filename) {
        const initialScrollY = window.scrollY;
        const loadingDiv = document.createElement("div");
        loadingDiv.style.cssText =
          'position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.85); color:white; padding:25px; border-radius:10px; z-index:1001; font-family: "Inter", sans-serif; text-align: center;';
        const progressText = document.createElement("div");
        loadingDiv.appendChild(progressText);
        document.body.appendChild(loadingDiv);

        if (scrollObserver) scrollObserver.disconnect();
        document
          .querySelectorAll(".scroll-animate-section")
          .forEach((section) => section.classList.add("scrolled-into-view"));

        Chart.defaults.animation = false;
        progressText.textContent = "Merender semua grafik...";
        await renderAllSectionsForExport();
        const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

        try {
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF({ orientation: "p", unit: "mm", format: "a4" });
          const pageHeight = pdf.internal.pageSize.getHeight();
          let finalY = 10;

          const addSectionTitle = (title, estimatedContentHeight = 20) => {
            if (finalY + estimatedContentHeight > pageHeight - 15) {
              pdf.addPage();
              finalY = 10;
            }
            pdf.setFontSize(10);
            pdf.setTextColor(42, 42, 42);
            pdf.text(title, 10, finalY);
            finalY += 3;
          };

          const captureVisibleElement = async (elementId, title) => {
            progressText.textContent = `Mengambil gambar: ${title}...`;
            await delay(100);
            const element = document.getElementById(elementId);
            if (!element) {
              console.warn(`Elemen tidak ditemukan untuk PDF: ${elementId}`);
              return;
            }

            const canvas = await html2canvas(element, {
              scale: 3,
              useCORS: true,
            });
            const imgData = canvas.toDataURL("image/png", 1.0);
            const imgWidth = 190;
            const imgHeight = (canvas.height * imgWidth) / canvas.width;

            addSectionTitle(title, imgHeight + 10);
            pdf.addImage(imgData, "PNG", 10, finalY + 5, imgWidth, imgHeight);
            finalY += imgHeight + 15;
          };

          progressText.textContent = "Membangun tabel...";
          pdf.setFontSize(15);
          pdf.text("Laporan Analisis Kinerja Trading Lengkap", 105, finalY, {
            align: "center",
          });
          finalY += 10;

          const planHeadersFull = [
            "Aset",
            "Trade",
            "Balance",
            "Waktu Masuk",
            "Price Now",
            "Open",
            "SL",
            "TP",
            "Pending",
            "SL Pips",
            "TP Pips",
            "R:R Pips",
            "R:R %",
            "Lot",
            "Nett SL",
            "Nett TP",
            "Nett SL Asli",
            "Nett TP Asli",
            "Catatan",
            "Hasil/Aksi",
          ];
          const executedPlanHeadersFull = [
            ...planHeadersFull.slice(0, 19),
            "Hasil",
            "Waktu Keluar",
          ];

          const mapPlanToFullArray = (p, status) => {
            const currentAssetData = p.assetData || getAssetData(p.symbol);
            const rrPercentageString = p.rrPercentage
              ? `${-formatNumber(p.rrPercentage.sl, 2)}%:${formatNumber(
                  p.rrPercentage.tp,
                  2
                )}%`
              : "N/A";
            const isForExecutedTable = status === "Selesai";

            return [
              p.symbol,
              p.tradeType,
              formatCurrency(p.balance),
              formatDateAndTimeForExport(p.entryTime),
              formatNumber(p.priceNow, currentAssetData.decimals, false),
              formatNumber(p.openPrice, currentAssetData.decimals, false),
              formatNumber(p.slPrice, currentAssetData.decimals, false),
              formatNumber(p.tpPrice, currentAssetData.decimals, false),
              getVisualPoints(p.pendingPips, p.symbol, isForExecutedTable)
                .display,
              getVisualPoints(p.slPips, p.symbol, isForExecutedTable).display,
              getVisualPoints(p.tpPips, p.symbol, isForExecutedTable).display,
              p.rrPips > 0 ? `1:${formatNumber(p.rrPips, 1)}` : "N/A",
              rrPercentageString,
              formatNumber(p.lotSize, 2),
              formatCurrency(p.nettSL),
              formatCurrency(p.nettTP),
              typeof p.originalNettSL === "number"
                ? formatCurrency(p.originalNettSL)
                : "N/A",
              typeof p.originalNettTP === "number"
                ? formatCurrency(p.originalNettTP)
                : "N/A",
              p.note || "-",
              status === "Selesai" ? p.outcome : status,
              ...(status === "Selesai"
                ? [formatDateAndTimeForExport(p.timestamp)]
                : []),
            ];
          };

          const tableStyles = { fontSize: 4, cellPadding: 0.7 };
          const summaryTableStyles = { fontSize: 6, cellPadding: 1.2 };

          if (calculatedPlansData.length > 0) {
            const body = calculatedPlansData.map((p) =>
              mapPlanToFullArray(p, "Baru").slice(0, 17)
            );
            addSectionTitle("Rencana Trading Baru", body.length * 3 + 10);
            pdf.autoTable({
              startY: finalY,
              head: [planHeadersFull],
              body: body,
              theme: "grid",
              headStyles: { fillColor: [22, 160, 133] },
              styles: tableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;
          }

          if (runningPlansData.length > 0) {
            const body = runningPlansData.map((p) =>
              mapPlanToFullArray(p, "Aktif").slice(0, 17)
            );
            addSectionTitle("Rencana Trading Aktif", body.length * 3 + 10);
            pdf.autoTable({
              startY: finalY,
              head: [planHeadersFull],
              body: body,
              theme: "grid",
              headStyles: { fillColor: [243, 156, 18] },
              styles: tableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;
          }

          if (executedPlansData.length > 0) {
            const executedBody = executedPlansData.map((p) =>
              mapPlanToFullArray(p, "Selesai")
            );
            addSectionTitle(
              "Rencana Trading Selesai",
              executedBody.length * 3 + 10
            );
            pdf.autoTable({
              startY: finalY,
              head: [executedPlanHeadersFull],
              body: executedBody,
              theme: "grid",
              headStyles: { fillColor: [41, 128, 185] },
              styles: tableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;

            const { summaryStats, riskStats } =
              getDetailedStatisticsForExport();

            addSectionTitle(
              "Statistik Ringkasan Keseluruhan",
              summaryStats.length * 4 + 10
            );
            pdf.autoTable({
              startY: finalY,
              head: [["Metrik", "Nilai"]],
              body: summaryStats,
              theme: "grid",
              styles: summaryTableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;

            addSectionTitle(
              "Statistik Risiko dan Imbalan",
              riskStats.length * 4 + 10
            );
            pdf.autoTable({
              startY: finalY,
              head: [["Metrik", "Nilai"]],
              body: riskStats,
              theme: "grid",
              styles: summaryTableStyles,
            });
            finalY = pdf.lastAutoTable.finalY + 5;

            const plHeaders = [
              "Bulan",
              "Presentase Akumulasi",
              "Total Eksekusi",
              "TP / SL",
              "Total Eksekusi Bersih",
              "TP Bersih ($)",
              "Akumulasi Nett ($)",
              "Total Saldo ($)",
            ];
            const plAoA = tableToAoA(
              document.getElementById("monthlyPLSummaryBody"),
              plHeaders
            ).slice(1);
            if (plAoA.length > 0) {
              addSectionTitle("Ringkasan P/L Bulanan", plAoA.length * 4 + 10);
              pdf.autoTable({
                startY: finalY,
                head: [plHeaders],
                body: plAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }

            // --- PERBAIKAN UTAMA DIMULAI DI SINI ---
            const summaryHeaders = [
              "Periode",
              "Presentase Kumulatif",
              "Pips Kumulatif",
              "Total Trade",
              "Saldo Akhir",
            ];

            const dailyAoA = tableToAoA(
              document.getElementById("newDailySummaryBody"),
              summaryHeaders
            ).slice(1);
            if (dailyAoA.length > 0) {
              addSectionTitle(
                "Ringkasan Harian Kumulatif",
                dailyAoA.length * 4 + 10
              );
              pdf.autoTable({
                startY: finalY,
                head: [summaryHeaders],
                body: dailyAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }

            const weeklyAoA = tableToAoA(
              document.getElementById("newWeeklySummaryBody"),
              summaryHeaders
            ).slice(1);
            if (weeklyAoA.length > 0) {
              addSectionTitle(
                "Ringkasan Mingguan Kumulatif",
                weeklyAoA.length * 4 + 10
              );
              pdf.autoTable({
                startY: finalY,
                head: [summaryHeaders],
                body: weeklyAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }

            const monthlyAoA = tableToAoA(
              document.getElementById("newMonthlySummaryBody"),
              summaryHeaders
            ).slice(1);
            if (monthlyAoA.length > 0) {
              addSectionTitle(
                "Ringkasan Bulanan Kumulatif",
                monthlyAoA.length * 4 + 10
              );
              pdf.autoTable({
                startY: finalY,
                head: [summaryHeaders],
                body: monthlyAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }

            const yearlyAoA = tableToAoA(
              document.getElementById("newYearlySummaryBody"),
              summaryHeaders
            ).slice(1);
            if (yearlyAoA.length > 0) {
              addSectionTitle(
                "Ringkasan Tahunan Kumulatif",
                yearlyAoA.length * 4 + 10
              );
              pdf.autoTable({
                startY: finalY,
                head: [summaryHeaders],
                body: yearlyAoA,
                theme: "striped",
                styles: summaryTableStyles,
              });
              finalY = pdf.lastAutoTable.finalY + 5;
            }
            // --- AKHIR DARI BLOK PERBAIKAN ---

            const chartIdsInOrder = [
              { containerId: "calendarSection", title: "Kalender Bulanan" },
              {
                containerId: "outcomeStatisticsSection",
                title: "Ringkasan Hasil Eksekusi",
              },
              {
                containerId: "assetSuccessStatisticsSection",
                title: "Statistik Keberhasilan Aset",
              },
              {
                containerId: "dailyLineStatisticsSection",
                title: "Statistik Persentase Harian",
              },
              {
                containerId: "monthlyBarStatisticsSection",
                title: "Statistik Persentase Bulanan (Diagram Batang)",
              },
              {
                containerId: "overallPercentageCumulativeStatisticsSection",
                title: "Statistik Persentase Kumulatif Keseluruhan",
              },
              {
                containerId: "overallBalanceCumulativeStatisticsSection",
                title: "Statistik Saldo Akun Kumulatif Keseluruhan",
              },
              {
                containerId: "overallPipsCumulativeStatisticsSection",
                title: "Statistik Pips/Points Kumulatif Keseluruhan",
              },
              {
                containerId: "combinedCumulativeStatisticsSection",
                title: "Statistik Gabungan Kumulatif",
              },
              {
                containerId: "combinedSummaryBarStatisticsSection",
                title: "Ringkasan Akumulasi Gabungan (Diagram Batang)",
              },
              {
                containerId: "balanceFrequencyStatisticsSection",
                title: "Frekuensi Balance per Aset",
              },
              {
                containerId: "percentageFrequencyStatisticsSection",
                title: "Frekuensi Persentase per Aset",
              },
              {
                containerId: "pipsFrequencyStatisticsSection",
                title: "Frekuensi Pips/Points per Aset",
              },
              {
                containerId: "executionFrequencyStatisticsSection",
                title: "Frekuensi Eksekusi per Aset (BUY vs SELL)",
              },
              {
                containerId: "assetExecutionCountStatisticsSection",
                title: "Frekuensi Aset Selesai Dieksekusi",
              },
              {
                containerId: "tradeFrequencyStatisticsSection",
                title: "Frekuensi Eksekusi Trade per Aset",
              },
            ];

            for (const chart of chartIdsInOrder) {
              await captureVisibleElement(chart.containerId, chart.title);
            }
          }

          progressText.textContent = "Menyelesaikan Laporan...";
          const pageCount = pdf.internal.getNumberOfPages();
          for (let i = 1; i <= pageCount; i++) {
            pdf.setPage(i);
            pdf.setFontSize(6);
            pdf.setTextColor(150);
            pdf.text(`Halaman ${i} dari ${pageCount}`, 105, pageHeight - 5, {
              align: "center",
            });
          }

          pdf.save(filename);
          showMessageBox(
            "Berhasil",
            "Laporan PDF komprehensif telah berhasil dibuat.",
            false
          );
        } catch (error) {
          console.error("Gagal membuat PDF:", error);
          showMessageBox(
            "Gagal",
            `Terjadi kesalahan saat membuat file PDF: ${error.message}. Silakan coba lagi.`,
            false
          );
        } finally {
          Chart.defaults.animation = true;
          document.body.removeChild(loadingDiv);
          window.scrollTo({ top: initialScrollY, behavior: "auto" });
          animateOnScroll();
        }
      }
      // --- EVENT LISTENERS (REVISED & CONSOLIDATED) ---
      document.addEventListener("DOMContentLoaded", async () => {
        // ... (kode yang sudah ada) ...

        const downloadPdfBtn = document.getElementById("downloadAllPdfBtn");
        if (downloadPdfBtn) {
          // ... (kode yang sudah ada) ...
        }

        // ▼▼▼ LETAKKAN KODE BARU DI SINI ▼▼▼
        const showPercentageDetailsBtn = document.getElementById(
          "showPercentageDetailsBtn"
        );
        if (showPercentageDetailsBtn) {
          showPercentageDetailsBtn.addEventListener("click", () => {
            const sortedTrades = [...executedPlansData]
              .filter((t) => getTradeResult(t).isValid)
              .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            if (sortedTrades.length === 0) {
              showMessageBox(
                "Informasi",
                "Belum ada data trading yang selesai untuk ditampilkan.",
                false
              );
              return;
            }

            // 1. Kelompokkan data berdasarkan bulan
            const monthlyData = {};
            sortedTrades.forEach((trade) => {
              const monthKey = new Date(trade.timestamp)
                .toISOString()
                .slice(0, 7); // Format: YYYY-MM
              if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = [];
              }
              monthlyData[monthKey].push(trade);
            });

            const sortedMonthKeys = Object.keys(monthlyData).sort();

            // 2. Bangun struktur HTML modal yang lebih profesional
            // Menggunakan grid untuk tata letak yang lebih baik dan scroll vertikal jika perlu
            let modalContentHtml = `
                  <div id="monthlyDetailContainer" class="max-h-[70vh] overflow-y-auto p-2 bg-gray-100 rounded-lg space-y-6">
                      <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
              `;

            const initialBalance = sortedTrades[0].balance;
            let lastMonthCumulativePL = 0;
            let lastMonthBalance = initialBalance;

            sortedMonthKeys.forEach((monthKey) => {
              const tradesForMonth = monthlyData[monthKey];
              const monthDate = new Date(monthKey + "-02T00:00:00"); // Trik parsing tanggal
              const monthName = monthDate.toLocaleString("id-ID", {
                month: "long",
                year: "numeric",
              });

              // --- Kalkulasi Data Statistik Baru untuk Bulan Ini ---
              const totalTradesThisMonth = tradesForMonth.length;
              const assetsThisMonth = [
                ...new Set(tradesForMonth.map((t) => t.symbol)),
              ].join(", ");

              const monthlyPL = tradesForMonth.reduce((sum, trade) => {
                return (
                  sum +
                  (getTradeResult(trade).isWin ? trade.nettTP : trade.nettSL)
                );
              }, 0);

              const startOfMonthBalance = lastMonthBalance;
              const endOfMonthBalance = startOfMonthBalance + monthlyPL;

              const monthlyPercentageGain =
                startOfMonthBalance > 0
                  ? (monthlyPL / startOfMonthBalance) * 100
                  : 0;
              const percentageClass =
                monthlyPercentageGain >= 0
                  ? "positive-value"
                  : "negative-value";

              // --- Akhir Kalkulasi ---

              // Membuat "Kartu" untuk setiap bulan
              modalContentHtml += `
                      <div class="flex flex-col bg-white p-4 rounded-xl shadow-md border border-gray-200">
                          <h4 class="text-base font-semibold text-center text-gray-800 mb-3 pb-2 border-b">${monthName}</h4>

                          <!-- Bagian Statistik -->
                          <div class="text-xs space-y-2 mb-3 text-gray-600">
                              <div class="flex justify-between">
                                  <span class="font-medium">Total Eksekusi:</span>
                                  <span class="font-bold text-gray-800">${totalTradesThisMonth} Trade</span>
                              </div>
                              <div class="flex justify-between">
                                  <span class="font-medium">Presentase Bulan Ini:</span>
                                  <span class="font-bold text-base ${percentageClass}">${formatNumber(
                monthlyPercentageGain,
                2
              )}%</span>
                              </div>
                               <div class="flex justify-between items-start">
                                  <span class="font-medium flex-shrink-0 mr-2">Aset:</span>
                                  <span class="text-right text-gray-500">${
                                    assetsThisMonth || "N/A"
                                  }</span>
                              </div>
                          </div>

                          <!-- Bagian Grafik -->
                          <div class="flex-grow h-48 mt-auto">
                              <canvas id="popupChart-${monthKey}"></canvas>
                          </div>
                      </div>
                  `;

              // Update nilai untuk bulan berikutnya
              lastMonthCumulativePL += monthlyPL;
              lastMonthBalance = endOfMonthBalance;
            });

            modalContentHtml += `</div></div>`;

            // Tampilkan modal dengan struktur baru
            showMessageBox(
              "Detail Performa Bulanan (Persentase Kumulatif)",
              modalContentHtml,
              false
            );

            // 3. Render grafik untuk setiap kanvas setelah modal muncul
            setTimeout(() => {
              let lastMonthCumulativePL_forChart = 0;

              sortedMonthKeys.forEach((monthKey) => {
                const popupCanvas = document.getElementById(
                  `popupChart-${monthKey}`
                );
                const tradesForMonth = monthlyData[monthKey];
                if (
                  !popupCanvas ||
                  !tradesForMonth ||
                  tradesForMonth.length === 0
                )
                  return;

                const labels = [],
                  data = [];
                let currentMonthCumulativePL = 0;

                // Titik awal grafik adalah nilai akhir persentase dari bulan sebelumnya
                labels.push("Mulai");
                const startingPercentage =
                  initialBalance > 0
                    ? (lastMonthCumulativePL_forChart / initialBalance) * 100
                    : 0;
                data.push(startingPercentage);

                // Hitung progres di dalam bulan ini
                tradesForMonth.forEach((trade) => {
                  currentMonthCumulativePL += getTradeResult(trade).isWin
                    ? trade.nettTP
                    : trade.nettSL;
                  const totalCumulativePL =
                    lastMonthCumulativePL_forChart + currentMonthCumulativePL;

                  labels.push(
                    new Date(trade.timestamp).toLocaleDateString("id-ID", {
                      day: "2-digit",
                    })
                  );
                  const currentPercentage =
                    initialBalance > 0
                      ? (totalCumulativePL / initialBalance) * 100
                      : 0;
                  data.push(currentPercentage);
                });

                // Simpan nilai akhir bulan ini untuk bulan berikutnya
                lastMonthCumulativePL_forChart += currentMonthCumulativePL;

                // Render grafik
                new Chart(popupCanvas.getContext("2d"), {
                  type: "line",
                  data: {
                    labels: labels,
                    datasets: [
                      {
                        label: "Persentase Kumulatif",
                        data: data,
                        borderColor: "#2a2a2a",
                        backgroundColor: "rgba(42, 42, 42, 0.1)",
                        fill: true,
                        tension: 0.4,
                        borderWidth: 1.5,
                        pointRadius: 1.5,
                        pointHoverRadius: 4,
                        pointBackgroundColor: "#2a2a2a",
                      },
                    ],
                  },
                  options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                      y: {
                        ticks: {
                          font: { size: 9, family: "Inter" },
                          callback: (val) => `${val.toFixed(1)}%`,
                        },
                        grid: {
                          drawTicks: false,
                          color: "#f0f0f0",
                        },
                      },
                      x: {
                        ticks: {
                          font: { size: 9, family: "Inter" },
                          maxRotation: 0,
                          minRotation: 0,
                        },
                        grid: {
                          display: false,
                        },
                      },
                    },
                  },
                });
              });
            }, 150); // Beri jeda agar DOM modal siap dirender
          });
        }

        // --- LETAKKAN KODE BARU DI SINI (di dalam DOMContentLoaded) ---
        if (prevMonthBtn && nextMonthBtn) {
          prevMonthBtn.addEventListener("click", () => {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
            renderCalendar(currentCalendarDate);
          });

          nextMonthBtn.addEventListener("click", () => {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
            renderCalendar(currentCalendarDate);
          });

          // Render kalender saat pertama kali halaman dimuat
          renderCalendar(currentCalendarDate);
        }
        // ▲▲▲ AKHIR DARI BLOK KODE BARU ▲▲▲

        // Other event listeners
        animateOnScroll();
        startBannerAutoslide();
        console.log("Application initialization complete.");
      });

      // --- Photo Upload & Crop Functions ---
      /**
       * Draws an image onto a canvas, ensuring it covers the canvas area
       * while maintaining aspect ratio, effectively cropping it to 1:1.
       * @param {CanvasRenderingContext2D} ctx The canvas rendering context.
       * @param {HTMLImageElement} img The image to draw.
       * @param {number} canvasWidth The width of the canvas.
       * @param {number} canvasHeight The height of the canvas.
       */
      function drawImageCover(ctx, img, canvasWidth, canvasHeight) {
        const imgAspectRatio = img.width / img.height;
        const canvasAspectRatio = 1 / 1; // Target aspect ratio

        let sx, sy, sWidth, sHeight;

        // Calculate the source rectangle (the part of the image to crop)
        if (imgAspectRatio > canvasAspectRatio) {
          // Image is wider than 1:1, crop from the sides
          sHeight = img.height;
          sWidth = sHeight * canvasAspectRatio;
          sx = (img.width - sWidth) / 2;
          sy = 0;
        } else {
          // Image is taller than 1:1, crop from top and bottom
          sWidth = img.width;
          sHeight = sWidth / canvasAspectRatio;
          sx = 0;
          sy = (img.height - sHeight) / 2;
        }

        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.drawImage(
          img,
          sx,
          sy,
          sWidth,
          sHeight,
          0,
          0,
          canvasWidth,
          canvasHeight
        );
      }

      function renderPhotoGallery() {
        if (!photoSlides) {
          console.error("photoSlides is null. Cannot render photo gallery.");
          return;
        }
        photoSlides.innerHTML = ""; // Clear existing images

        if (userPhotos.length === 0) {
          photoSlides.innerHTML =
            '<img src="https://placehold.co/600x600/cccccc/ffffff?text=Add+Photos+1:1" alt="Placeholder" class="w-full h-full object-cover flex-shrink-0">';
          if (prevPhotoBtn) prevPhotoBtn.classList.add("hidden");
          if (nextPhotoBtn) nextPhotoBtn.classList.add("hidden");
          if (photoCounter) photoCounter.classList.add("hidden");
          return;
        }

        userPhotos.forEach((photoUrl, index) => {
          const img = document.createElement("img");
          img.src = photoUrl;
          img.alt = `User Photo ${index + 1}`;
          img.className = "w-full h-full object-cover flex-shrink-0";
          photoSlides.appendChild(img);
        });

        if (photoSlides)
          photoSlides.style.transform = `translateX(-${
            currentPhotoIndex * 100
          }%)`;
        if (prevPhotoBtn)
          prevPhotoBtn.classList.toggle(
            "hidden",
            userPhotos.length <= 1 || currentPhotoIndex === 0
          );
        if (nextPhotoBtn)
          nextPhotoBtn.classList.toggle(
            "hidden",
            userPhotos.length <= 1 ||
              currentPhotoIndex === userPhotos.length - 1
          );
        if (photoCounter)
          photoCounter.classList.toggle("hidden", userPhotos.length === 0);
        if (photoCounter)
          photoCounter.textContent = `${currentPhotoIndex + 1} / ${
            userPhotos.length
          }`;
      }

      function showNextPhoto() {
        if (currentPhotoIndex < userPhotos.length - 1) {
          currentPhotoIndex++;
          renderPhotoGallery();
        }
      }

      function showPrevPhoto() {
        if (currentPhotoIndex > 0) {
          currentPhotoIndex--;
          renderPhotoGallery();
        }
      }

      // Long press variables
      let longPressTimer;
      let isLongPress = false;
      const LONG_PRESS_THRESHOLD = 500; // milliseconds
      const MOVE_THRESHOLD = 10; // pixels
      let startX, startY;

      // --- REFACTORED PHOTO EVENT LISTENERS ---
      const photoGalleryContainer = document.querySelector(
        ".photo-gallery-container"
      );
      if (photoGalleryContainer) {
        photoGalleryContainer.addEventListener("mousedown", (e) => {
          if (e.target.tagName === "BUTTON" || e.target.closest("button"))
            return; // Ignore clicks on nav buttons
          if (e.button !== 0) return; // Only left click
          startX = e.clientX;
          startY = e.clientY;
          isLongPress = false;
          longPressTimer = setTimeout(async () => {
            isLongPress = true;
            if (userPhotos.length > 0) {
              const confirmed = await showMessageBox(
                "Hapus Foto?",
                "Apakah Anda yakin ingin menghapus foto ini?",
                true
              );
              if (confirmed) {
                const indexToDelete = currentPhotoIndex;
                if (db && userId !== "anonymous") {
                  await deleteProfilePicture(userId, indexToDelete);
                } else {
                  userPhotos.splice(indexToDelete, 1);
                  savePhotosToLocalStorage();
                }
                if (
                  currentPhotoIndex >= userPhotos.length &&
                  userPhotos.length > 0
                ) {
                  currentPhotoIndex = userPhotos.length - 1;
                } else if (userPhotos.length === 0) {
                  currentPhotoIndex = 0;
                }
                renderPhotoGallery();
                showMessageBox("Berhasil", "Foto berhasil dihapus.", false);
              }
            }
          }, LONG_PRESS_THRESHOLD);
        });

        photoGalleryContainer.addEventListener("mouseup", (e) => {
          if (e.target.tagName === "BUTTON" || e.target.closest("button"))
            return;
          clearTimeout(longPressTimer);
          if (isLongPress) {
            e.preventDefault(); // Prevent the label from triggering file input on long press release
          }
          isLongPress = false;
        });

        photoGalleryContainer.addEventListener("touchend", (e) => {
          clearTimeout(longPressTimer);
          if (isLongPress) {
            e.preventDefault(); // Prevent the label click after a long press
          }
          isLongPress = false;
        });

        photoGalleryContainer.addEventListener("touchmove", (e) => {
          if (
            longPressTimer &&
            (Math.abs(e.touches[0].clientX - startX) > MOVE_THRESHOLD ||
              Math.abs(e.touches[0].clientY - startY) > MOVE_THRESHOLD)
          ) {
            clearTimeout(longPressTimer);
          }
        });
      }

      if (imageInput) {
        imageInput.addEventListener("change", (event) => {
          // Check if the upload is allowed
          if (userPhotos.length >= MAX_PHOTOS) {
            showMessageBox(
              "Batas Unggahan Tercapai",
              `Anda hanya dapat mengunggah maksimal ${MAX_PHOTOS} foto.`,
              false
            );
            event.target.value = ""; // Reset file input
            return;
          }

          const files = event.target.files;
          if (files.length === 0) return;

          const file = files[0];
          if (file && file.type.startsWith("image/")) {
            const reader = new FileReader();
            reader.onload = (e) => {
              currentImageToCrop = new Image();
              currentImageToCrop.onload = () => {
                if (photoUploadModal) showModal(photoUploadModal);

                const canvasSize = 500;
                imageCanvas.width = canvasSize;
                imageCanvas.height = canvasSize;

                drawImageCover(ctx, currentImageToCrop, canvasSize, canvasSize);
              };
              currentImageToCrop.src = e.target.result;
            };
            reader.readAsDataURL(file);
          } else {
            showMessageBox(
              "Gagal",
              "Silakan pilih file gambar yang valid.",
              false
            );
          }
          event.target.value = ""; // Reset file input to allow re-uploading the same file
        });
      }

      if (cropAndSaveBtn) {
        cropAndSaveBtn.addEventListener("click", async () => {
          if (currentImageToCrop && imageCanvas) {
            const imageDataUrl = imageCanvas.toDataURL("image/png");
            const targetIndex = userPhotos.length;
            if (db && userId !== "anonymous") {
              await saveProfilePicture(userId, imageDataUrl, targetIndex);
            } else {
              userPhotos.push(imageDataUrl);
              savePhotosToLocalStorage();
              showMessageBox(
                "Berhasil",
                "Foto profil berhasil disimpan.",
                false
              );
            }
            currentPhotoIndex = targetIndex;
            renderPhotoGallery();
            if (photoUploadModal) hideModal(photoUploadModal);
            currentImageToCrop = null;
          }
        });
      }

      if (cancelPhotoBtn)
        cancelPhotoBtn.addEventListener("click", () => {
          if (photoUploadModal) hideModal(photoUploadModal);
          currentImageToCrop = null;
        });

      if (prevPhotoBtn)
        prevPhotoBtn.addEventListener("click", (e) => {
          e.preventDefault(); // Prevent label click
          e.stopPropagation(); // Stop event from bubbling up
          showPrevPhoto();
        });
      if (nextPhotoBtn)
        nextPhotoBtn.addEventListener("click", (e) => {
          e.preventDefault(); // Prevent label click
          e.stopPropagation(); // Stop event from bubbling up
          showNextPhoto();
        });

      // --- Limit Checking Logic (Refactored for single pass) ---
      function checkTradeLimits() {
        let overallInitialBalance = null,
          overallCurrentBalance = null,
          monthlyInitialBalance = null,
          monthlyCurrentBalance = null,
          dailyInitialBalance = null,
          dailyCurrentBalance = null;
        const now = new Date();
        const currentMonthYearIdentifier = `${now.getFullYear()}-${now.getMonth()}`;
        const todayStart = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
          0,
          0,
          0
        ).getTime();

        executedPlansData.forEach((trade) => {
          if (trade.outcome === "Cancel") {
            console.log("Skipping cancelled trade:", trade);
            return;
          }
          const profitLossAmount =
            trade.outcome === "Take Profit"
              ? trade.nettTP
              : trade.outcome === "Stop Loss"
              ? trade.nettSL
              : 0;
          const tradeDate = new Date(trade.timestamp);
          const tradeTimestamp = tradeDate.getTime();
          const tradeMonthYearIdentifier = `${tradeDate.getFullYear()}-${tradeDate.getMonth()}`;

          // Overall balance calculation
          if (overallInitialBalance === null) {
            overallInitialBalance = trade.balance;
            overallCurrentBalance = trade.balance;
          }
          overallCurrentBalance += profitLossAmount;

          // Monthly balance calculation
          if (tradeMonthYearIdentifier === currentMonthYearIdentifier) {
            if (monthlyInitialBalance === null) {
              monthlyInitialBalance = trade.balance;
              monthlyCurrentBalance = trade.balance;
            }
            monthlyCurrentBalance += profitLossAmount;
          }
          // Daily balance calculation
          if (tradeTimestamp >= todayStart && tradeTimestamp <= now.getTime()) {
            if (dailyInitialBalance === null) {
              dailyInitialBalance = trade.balance;
              dailyCurrentBalance = trade.balance;
            }
            dailyCurrentBalance += profitLossAmount;
          }
        });

        const overallCumulativePercentageLoss =
          overallInitialBalance !== null && overallInitialBalance !== 0
            ? ((overallCurrentBalance - overallInitialBalance) /
                overallInitialBalance) *
              100
            : 0;
        const currentMonthPercentageLoss =
          monthlyInitialBalance !== null && monthlyInitialBalance !== 0
            ? ((monthlyCurrentBalance - monthlyInitialBalance) /
                monthlyInitialBalance) *
              100
            : 0;
        const currentDailyPercentageLoss =
          dailyInitialBalance !== null && dailyInitialBalance !== 0
            ? ((dailyCurrentBalance - dailyInitialBalance) /
                dailyInitialBalance) *
              100
            : 0;

        const lastOverallLossBreachMonth = localStorage.getItem(
          "lastOverallLossBreachMonth"
        );
        if (overallCumulativePercentageLoss <= OVERALL_MAX_LOSS_LIMIT) {
          if (lastOverallLossBreachMonth === currentMonthYearIdentifier) {
            limitNotificationMessage = `Anda sudah mencapai batas kerugian maksimal (-${Math.abs(
              OVERALL_MAX_LOSS_LIMIT
            )}%) secara keseluruhan. Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`;
            return false;
          } else {
            localStorage.setItem(
              "lastOverallLossBreachMonth",
              currentMonthYearIdentifier
            );
            limitNotificationMessage = `Anda sudah mencapai batas kerugian maksimal (-${Math.abs(
              OVERALL_MAX_LOSS_LIMIT
            )}%) secara keseluruhan. Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`;
            return false;
          }
        } else {
          if (lastOverallLossBreachMonth === currentMonthYearIdentifier)
            localStorage.removeItem("lastOverallLossBreachMonth");
        }
        if (currentMonthPercentageLoss <= MONTHLY_LOSS_LIMIT) {
          limitNotificationMessage = `Anda telah mencapai batas kerugian bulanan maksimum (-${Math.abs(
            MONTHLY_LOSS_LIMIT
          )}%). Input data akan diaktifkan kembali pada tanggal 1 bulan berikutnya.`;
          return false;
        }
        if (currentDailyPercentageLoss <= DAILY_LOSS_LIMIT) {
          limitNotificationMessage = `Anda telah mencapai batas kerugian harian (-${Math.abs(
            DAILY_LOSS_LIMIT
          )}%). Input data akan diaktifkan kembali pada hari berikutnya.`;
          return false;
        }
        limitNotificationMessage = "";
        return true;
      }

      function displayLimitNotification(message) {
        const notificationDiv = document.getElementById("limitNotification");
        if (notificationDiv) {
          // Add null check here
          if (message) {
            notificationDiv.textContent = message;
            notificationDiv.classList.remove("hidden", "error-message");
            notificationDiv.classList.add("error-message");
          } else {
            notificationDiv.textContent = "";
            notificationDiv.classList.add("hidden");
            notificationDiv.classList.remove("error-message");
          }
        }
      }

      // --- EVENT LISTENERS ---
      const addInputRowBtn = document.getElementById("addInputRowBtn");
      if (addInputRowBtn) {
        // Add null check here
        addInputRowBtn.addEventListener("click", () => {
          if (checkTradeLimits()) {
            addInputRow();
            saveInputRowsToLocalStorage();
            displayLimitNotification("");
          } else {
            displayLimitNotification(limitNotificationMessage);
          }
        });
      }

      const calculateAllBtn = document.getElementById("calculateAllBtn");
      if (calculateAllBtn) {
        // Add null check here
        calculateAllBtn.addEventListener("click", () => {
          calculateAllRows();
        });
      }

      // --- LETAKKAN SEMUA KODE DI BAWAH INI SEBELUM EVENT LISTENER downloadNewMonthlySummaryBtn ---

      const downloadDailySummaryBtn = document.getElementById(
        "downloadNewDailySummaryBtn"
      );
      if (downloadDailySummaryBtn) {
        downloadDailySummaryBtn.addEventListener("click", () => {
          downloadDailySummaryAsExcel(
            `Ringkasan_Harian_Kumulatif_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`
          );
        });
      }

      const downloadWeeklySummaryBtn = document.getElementById(
        "downloadNewWeeklySummaryBtn"
      );
      if (downloadWeeklySummaryBtn) {
        downloadWeeklySummaryBtn.addEventListener("click", () => {
          downloadWeeklySummaryAsExcel(
            `Ringkasan_Mingguan_Kumulatif_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`
          );
        });
      }

      const downloadYearlySummaryBtn = document.getElementById(
        "downloadNewYearlySummaryBtn"
      );
      if (downloadYearlySummaryBtn) {
        downloadYearlySummaryBtn.addEventListener("click", () => {
          downloadYearlySummaryAsExcel(
            `Ringkasan_Tahunan_Kumulatif_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`
          );
        });
      }

      // --- AKHIR DARI BLOK KODE BARU ---
      // --- PENAMBAHAN: Event listener untuk tombol unduh ringkasan bulanan ---
      const downloadMonthlySummaryBtn = document.getElementById(
        "downloadNewMonthlySummaryBtn"
      );
      if (downloadMonthlySummaryBtn) {
        downloadMonthlySummaryBtn.addEventListener("click", () => {
          downloadNewMonthlySummaryAsExcel(
            `Ringkasan_Bulanan_Kumulatif_${new Date()
              .toISOString()
              .slice(0, 10)}.csv`
          );
        });
      }

      // --- DELETE AND EXPORT DATA FUNCTIONALITY ---
      if (deleteAndExportDataBtn) {
        deleteAndExportDataBtn.addEventListener("click", async () => {
          if (executedPlansData.length === 0) {
            showMessageBox(
              "Informasi",
              "Tidak ada data untuk diunduh atau dihapus.",
              false
            );
            return;
          }

          const confirmed = await showMessageBox(
            "Unduh & Hapus Data?",
            "Anda akan mengunduh semua data trading yang telah selesai, lalu menghapusnya secara permanen. Lanjutkan?",
            true
          );

          if (!confirmed) {
            showMessageBox("Dibatalkan", "Proses dibatalkan.", false);
            return;
          }

          // --- Langkah 1: Siapkan dan Unduh Data ---
          try {
            // Langkah 1: Siapkan dan Unduh Data dengan format yang benar
            const headers = [
              "Status",
              "Aset",
              "Trade",
              "BalanceAkun",
              "WaktuMasuk",
              "OpenPrice",
              "SLPrice",
              "TPPrice",
              "PendingPipsPoints",
              "SLPipsPoints",
              "TPPipsPoints",
              "RRPips",
              "R:R %",
              "LotUnits",
              "NettSL",
              "NettTP",
              "OriginalNettSL",
              "OriginalNettTP",
              "Catatan",
              "Hasil",
              "WaktuKeluar",
            ];
            const dataToExport = executedPlansData.map((plan) =>
              preparePlanForExport(plan, "Selesai")
            );
            downloadAsExcel(
              `ARSIP_Rencana_Trading_Selesai_${new Date()
                .toISOString()
                .slice(0, 10)}.csv`,
              dataToExport,
              headers
            );

            // Langkah 2: Hapus Data setelah unduhan dimulai
            await deleteAllExecutedPlans();

            executedPlansData = []; // Hapus hanya data yang selesai
            saveDataToLocalStorage();

            // Langkah 3: Render ulang semua komponen yang terpengaruh
            await initializeAppFromLocalStorage(); // Cara termudah untuk me-reset seluruh UI dengan benar

            showMessageBox(
              "Berhasil",
              "Data telah diunduh dan berhasil dihapus.",
              false
            );
          } catch (error) {
            console.error("Gagal saat proses unduh & hapus:", error);
            showMessageBox(
              "Gagal",
              "Terjadi kesalahan saat proses unduh & hapus. Data tidak dihapus.",
              false
            );
            return; // Batalkan proses jika unduhan gagal
          }

          // --- Langkah 2: Hapus Data Setelah Unduhan Dimulai ---
          try {
            // Hapus dari Firestore
            await deleteAllExecutedPlans(userId);

            // Hapus dari state lokal dan localStorage
            executedPlansData = [];
            localStorage.removeItem("lastOverallLossBreachMonth");
            saveDataToLocalStorage();

            // Render ulang semua komponen yang terpengaruh
            renderExecutedPlans();
            calculateSummaryStatistics();
            updateRiskRewardStatistics();
            calculateAndRenderMonthlyPLSummary();
            calculateAndRenderDailySummary();
            calculateAndRenderWeeklySummary();
            calculateAndRenderNewMonthlySummary();
            calculateAndRenderYearlySummary();

            // Reset semua grafik
            for (const sectionId in chartSections) {
              const chartInfo = chartSections[sectionId];
              if (chartInfo.chartInstance && chartInfo.chartInstance()) {
                chartInfo.chartInstance().destroy();
                chartInfo.setInstance(null);
                chartInfo.hasRendered = false;
              }
            }

            checkTradeLimits();
            displayLimitNotification(limitNotificationMessage);

            showMessageBox(
              "Berhasil",
              "Data telah diunduh dan berhasil dihapus.",
              false
            );
          } catch (error) {
            console.error("Error during data deletion:", error);
            showMessageBox(
              "Gagal Menghapus",
              "Data berhasil diunduh, tetapi terjadi kesalahan saat menghapus data dari aplikasi.",
              false
            );
            return;
          }
        });
      }

      // ... kode yang sudah ada ...

      // --- UPLOAD DATA FUNCTIONALITY ---
      const hiddenFileInput = document.createElement("input");
      hiddenFileInput.type = "file";
      // PERBAIKAN: Menerima file .xlsx dan .csv
      hiddenFileInput.accept =
        ".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel";
      hiddenFileInput.style.display = "none";
      document.body.appendChild(hiddenFileInput);

      if (uploadDataBtn) {
        uploadDataBtn.addEventListener("click", async () => {
          const confirmed = await showMessageBox(
            "Unggah & Tambah Data?",
            "Tindakan ini akan <strong>MENAMBAHKAN</strong> data dari file ke data yang sudah ada. Mengunggah file yang sama dua kali akan menyebabkan duplikasi data. Lanjutkan?",
            true
          );
          if (confirmed) {
            hiddenFileInput.click();
          }
        });
      }

      // --- GANTI SELURUH BLOK EVENT LISTENER DI BAWAH INI ---
      hiddenFileInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) {
          hiddenFileInput.value = "";
          return;
        }

        const reader = new FileReader();

        reader.onload = async (e) => {
          showMessageBox(
            "Memproses File...",
            "Harap tunggu, data sedang diimpor...",
            false
          );

          try {
            let csvString;
            if (file.name.toLowerCase().endsWith(".xlsx")) {
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: "array" });
              const firstSheetName = workbook.SheetNames[0];
              const worksheet = workbook.Sheets[firstSheetName];
              csvString = XLSX.utils.sheet_to_csv(worksheet);
            } else {
              csvString = e.target.result;
            }

            const parsedResult = parseAllPlansFromCSV(csvString);

            // Panggil fungsi import yang sudah diperbaiki
            await importAllPlans(parsedResult);

            // Hapus notifikasi loading (pesan sukses akan ditampilkan oleh importAllPlans)
            const existingModal = document.querySelector(".message-box-modal");
            if (
              existingModal &&
              existingModal
                .querySelector("h3")
                .textContent.includes("Memproses")
            ) {
              existingModal.remove();
            }
          } catch (error) {
            console.error("Gagal mem-parsing atau mengimpor file:", error);
            document.querySelector(".message-box-modal")?.remove();
            showMessageBox(
              "Gagal Unggah",
              `Terjadi kesalahan. Pastikan format file Anda benar. Error: ${error.message}`,
              false
            );
          } finally {
            hiddenFileInput.value = "";
          }
        };

        if (file.name.toLowerCase().endsWith(".xlsx")) {
          reader.readAsArrayBuffer(file);
        } else {
          reader.readAsText(file);
        }
      });
      // --- AKHIR DARI BLOK PENGGANTIAN ---

      // ... sisa kode Anda ...

      // --- AKHIR DARI BLOK PENGGANTIAN ---
      // --- AKHIR DARI BLOK PENGGANTIAN ---

      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      // --- GANTI SELURUH FUNGSI PARSING DENGAN KODE INI ---
      function parseAllPlansFromCSV(csvString) {
        const lines = csvString.trim().replace(/\r/g, "").split("\n");
        if (lines.length < 2) return { successful: [], failedCount: 0 };

        const headers = lines[0]
          .split(",")
          .map((h) => h.trim().toLowerCase().replace(/"/g, ""));
        const dataRows = lines.slice(1);

        const successful = [];
        let failedCount = 0;

        const headerMapping = {
          symbol: ["aset", "symbol", "pair"],
          tradeType: ["trade", "tipe", "type"],
          balance: ["balance akun", "balance", "saldo"],
          entryTime: ["waktu masuk", "entry time", "open time"],
          priceNow: ["price now", "harga sekarang"],
          openPrice: ["open price", "harga buka"],
          slPrice: ["sl price", "stop loss"],
          tpPrice: ["tp price", "take profit"],
          originalTpPrice: ["originaltpprice"],
          pendingPipsPoints: ["pending pips/points", "pending"],
          slPipsPoints: ["sl pips/points"],
          tpPipsPoints: ["tp pips/points"],
          originalTpPipsPoints: ["originaltppips"],
          originalRrPips: ["originalrrpips"],
          originalRrPercentage: ["originalrrpercentage"],
          nettSL: ["nett sl", "netsl"],
          nettTP: ["nett tp", "nettp"],
          originalNettSL: ["originalnettsl"],
          originalNettTP: ["originalnettp"],
          note: ["catatan", "note", "notes"],
          outcome: ["hasil", "outcome", "result"],
          timestamp: ["waktu keluar", "exit time", "close time"],
          lotSize: ["lot/units", "lot", "size", "volume"],
          rrPercentage: ["r:r %", "rr %", "risk:reward %"],
        };

        const findHeaderIndex = (key) => {
          const possibleNames = headerMapping[key];
          if (!possibleNames) return -1;
          for (const name of possibleNames) {
            const index = headers.indexOf(name);
            if (index !== -1) return index;
          }
          return -1;
        };

        const unquoteCsvField = (field) => {
          if (typeof field !== "string") return field;
          const trimmedField = field.trim();
          if (trimmedField.startsWith('"') && trimmedField.endsWith('"')) {
            return trimmedField
              .substring(1, trimmedField.length - 1)
              .replace(/""/g, '"');
          }
          return trimmedField;
        };

        const cleanNumber = (value) => {
          if (
            typeof value !== "string" ||
            value === "" ||
            value.toLowerCase() === "n/a" ||
            value.toLowerCase() === "nan"
          )
            return NaN;
          return parseFloat(value.replace(/[^0-9.-]/g, ""));
        };

        dataRows.forEach((row, rowIndex) => {
          try {
            const values = row
              .split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/)
              .map(unquoteCsvField);
            const getValue = (key) => {
              const index = findHeaderIndex(key);
              return index !== -1 ? values[index] : undefined;
            };

            const newPlan = {
              status: "Selesai",
              symbol: getValue("symbol"),
              tradeType: getValue("tradeType")?.toUpperCase(),
              balance: cleanNumber(getValue("balance")),
              entryTime: parseDateRobust(getValue("entryTime"))?.toISOString(),
              priceNow: cleanNumber(getValue("priceNow")),
              openPrice: cleanNumber(getValue("openPrice")),
              slPrice: cleanNumber(getValue("slPrice")),
              tpPrice: cleanNumber(getValue("tpPrice")),
              originalTpPrice: cleanNumber(getValue("originalTpPrice")),
              nettSL: cleanNumber(getValue("nettSL")),
              nettTP: cleanNumber(getValue("nettTP")),
              originalNettSL: cleanNumber(getValue("originalNettSL")),
              originalNettTP: cleanNumber(getValue("originalNettTP")),
              note: getValue("note"),
              outcome: getValue("outcome"),
              timestamp: parseDateRobust(getValue("timestamp"))?.toISOString(),
              lotSize: cleanNumber(getValue("lotSize")),
            };

            if (
              !newPlan.symbol ||
              !newPlan.tradeType ||
              isNaN(newPlan.balance) ||
              !newPlan.timestamp
            ) {
              console.warn(
                `Melewatkan baris ${rowIndex + 2}: Data inti tidak valid.`,
                row
              );
              failedCount++;
              return;
            }

            const assetData = getAssetData(newPlan.symbol);
            const pipsDivisor = newPlan.symbol === "XAG/USD" ? 100 : 10;

            const slPoints = cleanNumber(getValue("slPipsPoints"));
            const tpPoints = cleanNumber(getValue("tpPipsPoints"));
            const pendingPoints = cleanNumber(getValue("pendingPipsPoints"));
            const originalTpPoints = cleanNumber(
              getValue("originalTpPipsPoints")
            );

            newPlan.slPips = !isNaN(slPoints) ? slPoints / pipsDivisor : 0;
            newPlan.tpPips = !isNaN(tpPoints) ? tpPoints / pipsDivisor : 0;
            newPlan.pendingPips = !isNaN(pendingPoints)
              ? pendingPoints / pipsDivisor
              : 0;
            newPlan.originalTpPips = !isNaN(originalTpPoints)
              ? originalTpPoints / pipsDivisor
              : 0;

            const rrPipsString = getValue("originalRrPips")?.replace("1:", "");
            newPlan.originalRrPips = !isNaN(parseFloat(rrPipsString))
              ? parseFloat(rrPipsString)
              : NaN;

            newPlan.rrPips =
              newPlan.slPips > 0 ? newPlan.tpPips / newPlan.slPips : 0;

            const parseRrPercentage = (rrString) => {
              let parsed = { sl: 0, tp: 0 };
              if (rrString && rrString.toLowerCase() !== "n/a") {
                const parts = rrString.replace(/["%]/g, "").split(":");
                if (parts.length === 2) {
                  parsed.sl = Math.abs(parseFloat(parts[0].trim()));
                  parsed.tp = parseFloat(parts[1].trim());
                }
              }
              return parsed;
            };

            newPlan.rrPercentage = parseRrPercentage(getValue("rrPercentage"));
            newPlan.originalRrPercentage = parseRrPercentage(
              getValue("originalRrPercentage")
            );

            newPlan.assetData = assetData;
            newPlan.rowId = `imported-${Date.now()}-${rowIndex}`;

            successful.push(newPlan);
          } catch (error) {
            console.warn(`Gagal memproses baris ${rowIndex + 2}:`, error, row);
            failedCount++;
          }
        });

        return { successful, failedCount };
      }

      // --- Letakkan fungsi ini di dalam blok // --- HELPER FUNCTIONS --- ---
      // --- LETAKKAN FUNGSI BARU INI DI DALAM BLOK HELPER FUNCTIONS ---
      /**
       * FUNGSI BANTUAN BARU: Menjadi satu-satunya sumber kebenaran untuk hasil trade.
       * @param {object} trade - Objek data trading.
       * @returns {{isWin: boolean, isValid: boolean, profitLoss: number}}
       */
      function getTradeResult(trade) {
        const isValid =
          trade &&
          (trade.outcome === "Take Profit" || trade.outcome === "Stop Loss");
        const isWin = isValid && trade.outcome === "Take Profit";
        const profitLoss = isValid
          ? isWin
            ? trade.nettTP || 0
            : trade.nettSL || 0
          : 0;
        return { isWin, isValid, profitLoss };
      }
      /**
       * PERBAIKAN: Fungsi parsing tanggal yang lebih andal untuk menangani berbagai format.
       * @param {string} dateString - String tanggal, misal: "27/09/2025 15:30:00" atau "2025-09-27T08:30:00.000Z".
       * @returns {Date|null}
       */
      function parseDateRobust(dateString) {
        if (!dateString || typeof dateString !== "string") return null;

        // 1. Coba format ISO (paling andal)
        let date = new Date(dateString);
        if (!isNaN(date.getTime())) return date;

        // 2. Coba format DD/MM/YYYY HH:MM:SS atau DD-MM-YYYY HH:MM:SS
        const matchDMY = dateString.match(
          /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})(?:.*?(\d{1,2}):(\d{1,2}):?(\d{1,2})?)?/
        );
        if (matchDMY) {
          const day = parseInt(matchDMY[1], 10);
          const month = parseInt(matchDMY[2], 10) - 1; // Bulan di JS dari 0-11
          const year = parseInt(matchDMY[3], 10);
          const hour = parseInt(matchDMY[4] || "0", 10);
          const min = parseInt(matchDMY[5] || "0", 10);
          const sec = parseInt(matchDMY[6] || "0", 10);
          date = new Date(year, month, day, hour, min, sec);
          if (!isNaN(date.getTime())) return date;
        }

        // 3. Coba format MM/DD/YYYY HH:MM:SS (kurang umum di Indonesia, tapi sebagai fallback)
        const matchMDY = dateString.match(
          /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/
        );
        if (matchMDY) {
          // Asumsi ini adalah MM/DD/YYYY jika parsing DMY gagal
          const month = parseInt(matchMDY[1], 10) - 1;
          const day = parseInt(matchMDY[2], 10);
          const year = parseInt(matchMDY[3], 10);
          date = new Date(year, month, day);
          if (!isNaN(date.getTime())) return date;
        }

        // Gagal mem-parsing
        return null;
      }
      // --- AKHIR DARI BLOK PENGGANTIAN ---

      // --- GANTI FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      // --- GANTI FUNGSI LAMA DENGAN FUNGSI BARU INI ---
      // --- GANTI SELURUH FUNGSI LAMA DENGAN FUNGSI BARU DI BAWAH INI ---
      /**
       * PERBAIKAN: Mengimpor data dengan logika anti-duplikasi.
       * Hanya data yang belum ada di tabel (berdasarkan entryTime) yang akan ditambahkan.
       * @param {{successful: Array<Object>, failedCount: number}} parsedResult - Objek hasil dari parseAllPlansFromCSV.
       */
      async function importAllPlans(parsedResult) {
        const newExecutedFromFile = parsedResult.successful;
        const failedCount = parsedResult.failedCount;

        if (newExecutedFromFile.length === 0 && failedCount > 0) {
          showMessageBox(
            "Gagal Impor",
            `Tidak ada data yang berhasil diimpor. ${failedCount} baris data gagal diproses.`,
            false
          );
          return;
        }
        if (newExecutedFromFile.length === 0) {
          showMessageBox(
            "Informasi",
            "Tidak ada data baru untuk diimpor dari file yang dipilih.",
            false
          );
          return;
        }

        // --- LOGIKA ANTI-DUPLIKASI DIMULAI DI SINI ---
        // 1. Buat Set dari semua entryTime yang sudah ada untuk pencarian yang cepat.
        const existingEntryTimes = new Set(
          executedPlansData.map((plan) => plan.entryTime)
        );

        // 2. Filter data dari file, hanya ambil yang entryTime-nya belum ada.
        const trulyNewPlans = newExecutedFromFile.filter(
          (plan) => !existingEntryTimes.has(plan.entryTime)
        );
        const duplicateCount =
          newExecutedFromFile.length - trulyNewPlans.length;
        // --- AKHIR LOGIKA ANTI-DUPLIKASI ---

        if (trulyNewPlans.length === 0) {
          let message = "Tidak ada data baru yang ditambahkan.";
          if (duplicateCount > 0) {
            message += ` ${duplicateCount} data duplikat dilewati.`;
          }
          showMessageBox("Proses Selesai", message, false);
          return;
        }

        // Simpan HANYA data yang benar-benar baru
        if (db && userId !== "anonymous") {
          try {
            const savePromises = trulyNewPlans.map((p) =>
              saveExecutedPlan(userId, p)
            );
            await Promise.all(savePromises);
            // Listener onSnapshot akan secara otomatis memperbarui UI dari database.
          } catch (error) {
            console.error(
              "Gagal menyimpan data yang diunggah ke Firestore:",
              error
            );
            showMessageBox(
              "Gagal Menyimpan",
              "Terjadi kesalahan saat menyimpan data baru ke database.",
              false
            );
            return;
          }
        } else {
          // Untuk pengguna non-database, panggil pembaruan UI secara manual.
          updateAllDataAndRenderUI([], [], trulyNewPlans);
        }

        // Berikan umpan balik yang jelas kepada pengguna
        let successMessage = `Berhasil! ${trulyNewPlans.length} data baru berhasil ditambahkan.`;
        if (duplicateCount > 0) {
          successMessage += ` ${duplicateCount} data duplikat dilewati.`;
        }
        if (failedCount > 0) {
          successMessage += ` ${failedCount} baris data gagal diproses.`;
        }
        showMessageBox("Proses Selesai", successMessage, false);
      }

      // --- GANTI SELURUH FUNGSI calculateSummaryStatistics DAN updateRiskRewardStatistics DENGAN BLOK DI BAWAH INI ---

      function calculateSummaryStatistics() {
        const elements = {
          totalSettledTrades: document.getElementById(
            "totalSettledTradesSummary"
          ),
          probability: document.getElementById("probabilitySummary"),
          totalPips: document.getElementById("totalPipsSummary"),
          avgPercentagePerTrade: document.getElementById(
            "avgPercentagePerTradeSummary"
          ),
          dailyPercentage: document.getElementById("dailyPercentageSummary"),
          monthlyPercentage: document.getElementById(
            "monthlyPercentageSummary"
          ),
          yearlyPercentage: document.getElementById("yearlyPercentageSummary"),
          finalBalance: document.getElementById("finalBalanceSummary"),
          overallPercentage: document.getElementById(
            "overallPercentageSummary"
          ),
          joinTime: document.getElementById("joinTimeSummary"),
          balanceDrawdown: document.getElementById("balanceDrawdownSummary"),
          balanceDrawdownPeriod: document.getElementById(
            "balanceDrawdownSummaryPeriod"
          ),
          overallMaxDrawdownPercentage: document.getElementById(
            "overallMaxDrawdownPercentage"
          ),
          overallMaxDrawdownPercentagePeriod: document.getElementById(
            "overallMaxDrawdownPercentagePeriod"
          ),
        };

        // PERBAIKAN: Selalu filter dan urutkan data sebelum diproses
        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          // Reset semua elemen jika tidak ada data
          Object.values(elements).forEach((el) => {
            if (el) {
              el.textContent = "N/A";
              el.className = el.className.replace(
                /positive-value|negative-value/g,
                ""
              );
            }
          });
          elements.totalSettledTrades.textContent = "0";
          elements.probability.textContent = "0.00%";
          elements.totalPips.textContent = "0";
          elements.avgPercentagePerTrade.textContent = "0.00%";
          elements.dailyPercentage.textContent = "0.00%";
          elements.monthlyPercentage.textContent = "0.00%";
          elements.yearlyPercentage.textContent = "0.00%";
          elements.finalBalance.textContent = formatCurrency(0, "USD");
          elements.overallPercentage.textContent = "0.00%";
          elements.balanceDrawdown.textContent = formatCurrency(0, "USD");
          elements.overallMaxDrawdownPercentage.textContent = "0.00%";
          elements.balanceDrawdownPeriod.textContent = "Periode: N/A";
          elements.overallMaxDrawdownPercentagePeriod.textContent =
            "Periode: N/A";
          return;
        }

        let totalPips = 0,
          totalTakeProfitTrades = 0,
          totalPercentageChange = 0;
        const initialBalance = relevantTrades[0].balance;
        let currentBalance = initialBalance;
        let peakBalance = initialBalance;
        let maxDrawdownAmount = 0;
        let maxDrawdownPercentage = 0;
        let maxDrawdownStartDate = null;
        let maxDrawdownEndDate = null;
        let peakDate = new Date(relevantTrades[0].timestamp);

        const dailyChanges = {},
          monthlyChanges = {},
          yearlyChanges = {};

        relevantTrades.forEach((trade) => {
          const tradeResult = getTradeResult(trade);
          totalPercentageChange +=
            trade.balance > 0
              ? (tradeResult.profitLoss / trade.balance) * 100
              : 0;
          currentBalance += tradeResult.profitLoss;

          if (tradeResult.isWin) {
            totalTakeProfitTrades++;
            totalPips += getVisualPoints(
              trade.tpPips,
              trade.symbol,
              true
            ).forCalc;
          } else {
            totalPips -= getVisualPoints(
              trade.slPips,
              trade.symbol,
              true
            ).forCalc;
          }

          // PERBAIKAN: Logika Drawdown yang lebih akurat
          if (currentBalance > peakBalance) {
            peakBalance = currentBalance;
            peakDate = new Date(trade.timestamp);
          }
          const currentDrawdown = peakBalance - currentBalance;
          if (currentDrawdown > maxDrawdownAmount) {
            maxDrawdownAmount = currentDrawdown;
            maxDrawdownPercentage =
              peakBalance > 0 ? (maxDrawdownAmount / peakBalance) * 100 : 0;
            maxDrawdownStartDate = peakDate;
            maxDrawdownEndDate = new Date(trade.timestamp);
          }

          const tradeDate = new Date(trade.timestamp);
          const dayKey = tradeDate.toISOString().slice(0, 10);
          const monthKey = tradeDate.toISOString().slice(0, 7);
          const yearKey = tradeDate.getFullYear().toString();

          dailyChanges[dayKey] =
            (dailyChanges[dayKey] || 0) +
            (trade.balance > 0
              ? (tradeResult.profitLoss / trade.balance) * 100
              : 0);
          monthlyChanges[monthKey] =
            (monthlyChanges[monthKey] || 0) +
            (trade.balance > 0
              ? (tradeResult.profitLoss / trade.balance) * 100
              : 0);
          yearlyChanges[yearKey] =
            (yearlyChanges[yearKey] || 0) +
            (trade.balance > 0
              ? (tradeResult.profitLoss / trade.balance) * 100
              : 0);
        });

        const totalSettledTrades = relevantTrades.length;
        const probability =
          totalSettledTrades > 0
            ? (totalTakeProfitTrades / totalSettledTrades) * 100
            : 0;
        const overallPercentageChange =
          initialBalance > 0
            ? ((currentBalance - initialBalance) / initialBalance) * 100
            : 0;
        const drawdownDurationMs =
          maxDrawdownStartDate && maxDrawdownEndDate
            ? maxDrawdownEndDate.getTime() - maxDrawdownStartDate.getTime()
            : 0;

        const avgPercentagePerTradeVal =
          totalSettledTrades > 0
            ? totalPercentageChange / totalSettledTrades
            : 0;
        const avgDailyPercentage =
          Object.keys(dailyChanges).length > 0
            ? Object.values(dailyChanges).reduce((a, b) => a + b, 0) /
              Object.keys(dailyChanges).length
            : 0;
        const avgMonthlyPercentage =
          Object.keys(monthlyChanges).length > 0
            ? Object.values(monthlyChanges).reduce((a, b) => a + b, 0) /
              Object.keys(monthlyChanges).length
            : 0;
        const avgYearlyPercentage =
          Object.keys(yearlyChanges).length > 0
            ? Object.values(yearlyChanges).reduce((a, b) => a + b, 0) /
              Object.keys(yearlyChanges).length
            : 0;

        const applyColorClass = (el, val) => {
          el.classList.remove("positive-value", "negative-value");
          el.classList.add(val < 0 ? "negative-value" : "positive-value");
        };

        elements.totalSettledTrades.textContent = totalSettledTrades;
        elements.probability.textContent = `${formatNumber(probability, 2)}%`;
        elements.joinTime.textContent = new Date(
          relevantTrades[0].timestamp
        ).toLocaleDateString("id-ID");

        elements.totalPips.textContent = formatNumber(totalPips, 0);
        applyColorClass(elements.totalPips, totalPips);

        elements.avgPercentagePerTrade.textContent = `${formatNumber(
          avgPercentagePerTradeVal,
          2
        )}%`;
        applyColorClass(
          elements.avgPercentagePerTrade,
          avgPercentagePerTradeVal
        );

        elements.dailyPercentage.textContent = `${formatNumber(
          avgDailyPercentage,
          2
        )}%`;
        applyColorClass(elements.dailyPercentage, avgDailyPercentage);

        elements.monthlyPercentage.textContent = `${formatNumber(
          avgMonthlyPercentage,
          2
        )}%`;
        applyColorClass(elements.monthlyPercentage, avgMonthlyPercentage);

        elements.yearlyPercentage.textContent = `${formatNumber(
          avgYearlyPercentage,
          2
        )}%`;
        applyColorClass(elements.yearlyPercentage, avgYearlyPercentage);

        elements.finalBalance.textContent = formatCurrency(
          currentBalance,
          "USD"
        );
        applyColorClass(elements.finalBalance, currentBalance - initialBalance);

        elements.overallPercentage.textContent = `${formatNumber(
          overallPercentageChange,
          2
        )}%`;
        applyColorClass(elements.overallPercentage, overallPercentageChange);

        elements.balanceDrawdown.textContent = formatCurrency(
          -maxDrawdownAmount,
          "USD"
        );
        elements.balanceDrawdown.classList.add("negative-value");
        elements.balanceDrawdownPeriod.textContent = `Periode: ${formatDuration(
          drawdownDurationMs
        )}`;

        elements.overallMaxDrawdownPercentage.textContent = `-${formatNumber(
          maxDrawdownPercentage,
          2
        )}%`;
        elements.overallMaxDrawdownPercentage.classList.add("negative-value");
        elements.overallMaxDrawdownPercentagePeriod.textContent = `Periode: ${formatDuration(
          drawdownDurationMs
        )}`;
      }

      function updateRiskRewardStatistics() {
        const elements = {
          avgRiskReward: document.getElementById("avgRiskReward"),
          avgSignalSettledWeek: document.getElementById("avgSignalSettledWeek"),
          avgSignalSettledMonth: document.getElementById(
            "avgSignalSettledMonth"
          ),
          avgHoldingPeriod: document.getElementById("avgHoldingPeriod"),
          maxHoldingPeriod: document.getElementById("maxHoldingPeriod"),
          avgTpPips: document.getElementById("avgTpPips"),
          maxTpPips: document.getElementById("maxTpPips"),
          avgSlPips: document.getElementById("avgSlPips"),
          maxSlPips: document.getElementById("maxSlPips"),
          consecutiveProfit: document.getElementById("consecutiveProfit"),
          consecutiveProfitPeriod: document.getElementById(
            "consecutiveProfitPeriod"
          ),
          consecutiveLoss: document.getElementById("consecutiveLoss"),
          consecutiveLossPeriod: document.getElementById(
            "consecutiveLossPeriod"
          ),
          averagePips: document.getElementById("averagePips"),
          grossProfit: document.getElementById("grossProfit"),
          grossLoss: document.getElementById("grossLoss"),
          netProfit: document.getElementById("netProfit"),
          maxBalanceDrawdown: document.getElementById("maxBalanceDrawdown"),
          maxBalanceDrawdownPeriod: document.getElementById(
            "maxBalanceDrawdownPeriod"
          ),
          monthlyBalanceDrawdown: document.getElementById(
            "monthlyBalanceDrawdown"
          ),
          monthlyBalanceDrawdownPeriod: document.getElementById(
            "monthlyBalanceDrawdownPeriod"
          ),
          monthlyMaxDrawdownPercentage: document.getElementById(
            "monthlyMaxDrawdownPercentage"
          ),
          monthlyMaxDrawdownPercentagePeriod: document.getElementById(
            "monthlyMaxDrawdownPercentagePeriod"
          ),
        };

        // PERBAIKAN: Selalu filter dan urutkan data
        const relevantTrades = executedPlansData
          .filter((trade) => getTradeResult(trade).isValid)
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

        if (relevantTrades.length === 0) {
          Object.values(elements).forEach((el) => {
            if (el) el.textContent = "N/A";
          });
          elements.avgRiskReward.textContent = "1 : N/A";
          elements.avgSignalSettledWeek.textContent = "0";
          elements.consecutiveProfit.textContent = "0";
          elements.consecutiveLoss.textContent = "0";
          elements.grossProfit.textContent = formatCurrency(0);
          elements.grossLoss.textContent = formatCurrency(0);
          elements.netProfit.textContent = formatCurrency(0);
          elements.consecutiveProfitPeriod.textContent = "Periode: N/A";
          elements.consecutiveLossPeriod.textContent = "Periode: N/A";
          return;
        }

        const applyColorClass = (el, val) => {
          if (!el) return;
          el.classList.remove("positive-value", "negative-value");
          el.classList.add(val < 0 ? "negative-value" : "positive-value");
        };

        let totalTpPips = 0,
          countTpTrades = 0,
          totalSlPipsAbsolute = 0,
          countSlTrades = 0,
          grossProfitVal = 0,
          grossLossVal = 0,
          totalHoldingPeriodMs = 0;
        let currentProfitStreak = 0,
          maxProfitStreak = 0,
          profitStreakEnd = null,
          maxProfitStreakStart = null;
        let currentLossStreak = 0,
          maxLossStreak = 0,
          lossStreakEnd = null,
          maxLossStreakStart = null;
        let maxHoldingPeriodMs = 0,
          maxTpPipsVal = 0,
          maxSlPipsVal = 0;
        const monthlyTradeCounts = {},
          weeklyTradeCounts = {};

        relevantTrades.forEach((trade, index) => {
          const tradeResult = getTradeResult(trade);
          const holdingDuration = trade.entryTime
            ? new Date(trade.timestamp).getTime() -
              new Date(trade.entryTime).getTime()
            : 0;
          totalHoldingPeriodMs += holdingDuration;
          if (holdingDuration > maxHoldingPeriodMs)
            maxHoldingPeriodMs = holdingDuration;

          const tradeDate = new Date(trade.timestamp);
          const monthYear = tradeDate.toISOString().slice(0, 7);
          const weekYear = `${tradeDate.getFullYear()}-W${getWeekNumber(
            tradeDate
          )}`;
          monthlyTradeCounts[monthYear] =
            (monthlyTradeCounts[monthYear] || 0) + 1;
          weeklyTradeCounts[weekYear] = (weeklyTradeCounts[weekYear] || 0) + 1;

          if (tradeResult.isWin) {
            const pips = getVisualPoints(
              trade.tpPips,
              trade.symbol,
              true
            ).forCalc;
            totalTpPips += pips;
            if (pips > maxTpPipsVal) maxTpPipsVal = pips;
            countTpTrades++;
            grossProfitVal += tradeResult.profitLoss;
            currentProfitStreak++;
            currentLossStreak = 0;
            if (currentProfitStreak > maxProfitStreak) {
              maxProfitStreak = currentProfitStreak;
              profitStreakEnd = tradeDate;
              maxProfitStreakStart = new Date(
                relevantTrades[index - maxProfitStreak + 1].timestamp
              );
            }
          } else {
            const pips = getVisualPoints(
              trade.slPips,
              trade.symbol,
              true
            ).forCalc;
            totalSlPipsAbsolute += pips;
            if (pips > maxSlPipsVal) maxSlPipsVal = pips;
            countSlTrades++;
            grossLossVal += tradeResult.profitLoss;
            currentLossStreak++;
            currentProfitStreak = 0;
            if (currentLossStreak > maxLossStreak) {
              maxLossStreak = currentLossStreak;
              lossStreakEnd = tradeDate;
              maxLossStreakStart = new Date(
                relevantTrades[index - maxLossStreak + 1].timestamp
              );
            }
          }
        });

        const totalPips = totalTpPips - totalSlPipsAbsolute;
        const avgTpPipsVal =
          countTpTrades > 0 ? totalTpPips / countTpTrades : 0;
        const avgSlPipsVal =
          countSlTrades > 0 ? totalSlPipsAbsolute / countSlTrades : 0;
        const avgRiskRewardVal =
          avgSlPipsVal > 0 ? avgTpPipsVal / avgSlPipsVal : 0;
        const avgPipsVal =
          relevantTrades.length > 0 ? totalPips / relevantTrades.length : 0;
        const avgHoldingPeriodMsVal =
          relevantTrades.length > 0
            ? totalHoldingPeriodMs / relevantTrades.length
            : 0;
        const avgSignalSettledMonthVal =
          Object.keys(monthlyTradeCounts).length > 0
            ? Object.values(monthlyTradeCounts).reduce((s, c) => s + c, 0) /
              Object.keys(monthlyTradeCounts).length
            : 0;
        const avgSignalSettledWeekVal =
          Object.keys(weeklyTradeCounts).length > 0
            ? Object.values(weeklyTradeCounts).reduce((s, c) => s + c, 0) /
              Object.keys(weeklyTradeCounts).length
            : 0;
        const profitStreakDurationMs =
          maxProfitStreakStart && profitStreakEnd
            ? profitStreakEnd.getTime() - maxProfitStreakStart.getTime()
            : 0;
        const lossStreakDurationMs =
          maxLossStreakStart && lossStreakEnd
            ? lossStreakEnd.getTime() - maxLossStreakStart.getTime()
            : 0;

        // Hitung ulang drawdown maksimal dari statistik ringkasan
        calculateSummaryStatistics(); // Memastikan data drawdown di-update
        const maxDrawdownAmount = parseFloat(
          document
            .getElementById("balanceDrawdownSummary")
            .textContent.replace(/[^0-9.-]+/g, "")
        );
        const balanceDrawdownDuration = document.getElementById(
          "balanceDrawdownSummaryPeriod"
        ).textContent;

        // PERBAIKAN: Hitung drawdown bulanan secara terpisah dan akurat
        const monthlyDrawdowns = {};
        let initialBalance = relevantTrades[0].balance;
        let cumulativeBalance = initialBalance;

        relevantTrades.forEach((trade) => {
          const monthKey = new Date(trade.timestamp).toISOString().slice(0, 7);
          if (!monthlyDrawdowns[monthKey]) {
            const firstTradeOfMonth = relevantTrades.find(
              (t) =>
                new Date(t.timestamp).toISOString().slice(0, 7) === monthKey
            );
            monthlyDrawdowns[monthKey] = {
              peakBalance: firstTradeOfMonth ? firstTradeOfMonth.balance : 0,
              currentBalance: firstTradeOfMonth ? firstTradeOfMonth.balance : 0,
              maxDrawdownAmount: 0,
              maxDrawdownPercentage: 0,
              maxDrawdownStart: null,
              maxDrawdownEnd: null,
              peakDate: firstTradeOfMonth
                ? new Date(firstTradeOfMonth.timestamp)
                : null,
            };
          }
        });

        // Iterasi kedua untuk menghitung drawdown bulanan
        let monthlyBalances = {};
        relevantTrades.forEach((trade) => {
          const tradeResult = getTradeResult(trade);
          const monthKey = new Date(trade.timestamp).toISOString().slice(0, 7);
          if (monthlyBalances[monthKey] === undefined) {
            const prevMonthKey = new Date(
              new Date(trade.timestamp).setMonth(
                new Date(trade.timestamp).getMonth() - 1
              )
            )
              .toISOString()
              .slice(0, 7);
            monthlyBalances[monthKey] =
              monthlyBalances[prevMonthKey] || initialBalance;
          }

          monthlyBalances[monthKey] += tradeResult.profitLoss;

          let monthData = monthlyDrawdowns[monthKey];
          if (monthlyBalances[monthKey] > monthData.peakBalance) {
            monthData.peakBalance = monthlyBalances[monthKey];
            monthData.peakDate = new Date(trade.timestamp);
          }

          const currentDDA = monthData.peakBalance - monthlyBalances[monthKey];
          if (currentDDA > monthData.maxDrawdownAmount) {
            monthData.maxDrawdownAmount = currentDDA;
            monthData.maxDrawdownPercentage =
              monthData.peakBalance > 0
                ? (currentDDA / monthData.peakBalance) * 100
                : 0;
            monthData.maxDrawdownStart = monthData.peakDate;
            monthData.maxDrawdownEnd = new Date(trade.timestamp);
          }
        });

        const overallMonthlyMaxDDA = Math.max(
          0,
          ...Object.values(monthlyDrawdowns).map((m) => m.maxDrawdownAmount)
        );
        const overallMonthlyMaxDDP = Math.max(
          0,
          ...Object.values(monthlyDrawdowns).map((m) => m.maxDrawdownPercentage)
        );
        const maxDDMonthData = Object.values(monthlyDrawdowns).find(
          (m) => m.maxDrawdownAmount === overallMonthlyMaxDDA
        );
        const monthlyDDDurationMs =
          maxDDMonthData &&
          maxDDMonthData.maxDrawdownStart &&
          maxDDMonthData.maxDrawdownEnd
            ? maxDDMonthData.maxDrawdownEnd.getTime() -
              maxDDMonthData.maxDrawdownStart.getTime()
            : 0;

        // Pembaruan UI
        elements.avgRiskReward.textContent = `1 : ${formatNumber(
          avgRiskRewardVal,
          1
        )}`;
        elements.avgSignalSettledWeek.textContent = formatNumber(
          avgSignalSettledWeekVal,
          0
        );
        elements.avgSignalSettledMonth.textContent = formatNumber(
          avgSignalSettledMonthVal,
          0
        );
        elements.avgHoldingPeriod.textContent = formatDuration(
          avgHoldingPeriodMsVal
        );
        elements.maxHoldingPeriod.textContent =
          formatDuration(maxHoldingPeriodMs);
        elements.avgTpPips.textContent = formatNumber(avgTpPipsVal, 0);
        applyColorClass(elements.avgTpPips, avgTpPipsVal);
        elements.maxTpPips.textContent = formatNumber(maxTpPipsVal, 0);
        applyColorClass(elements.maxTpPips, maxTpPipsVal);
        elements.avgSlPips.textContent = formatNumber(-avgSlPipsVal, 0);
        applyColorClass(elements.avgSlPips, -1);
        elements.maxSlPips.textContent = formatNumber(-maxSlPipsVal, 0);
        applyColorClass(elements.maxSlPips, -1);
        elements.averagePips.textContent =
          formatNumber(avgPipsVal, 0) + " Pips";
        applyColorClass(elements.averagePips, avgPipsVal);
        elements.consecutiveProfit.textContent = formatNumber(
          maxProfitStreak,
          0
        );
        applyColorClass(elements.consecutiveProfit, maxProfitStreak);
        elements.consecutiveProfitPeriod.textContent = `Periode: ${formatDuration(
          profitStreakDurationMs
        )}`;
        elements.consecutiveLoss.textContent = formatNumber(maxLossStreak, 0);
        applyColorClass(elements.consecutiveLoss, -1);
        elements.consecutiveLossPeriod.textContent = `Periode: ${formatDuration(
          lossStreakDurationMs
        )}`;
        elements.grossProfit.textContent = formatCurrency(
          grossProfitVal,
          "USD"
        );
        applyColorClass(elements.grossProfit, grossProfitVal);
        elements.grossLoss.textContent = formatCurrency(grossLossVal, "USD");
        applyColorClass(elements.grossLoss, grossLossVal);
        const netProfitVal = grossProfitVal + grossLossVal;
        elements.netProfit.textContent = formatCurrency(netProfitVal, "USD");
        applyColorClass(elements.netProfit, netProfitVal);
        elements.maxBalanceDrawdown.textContent = formatCurrency(
          -Math.abs(maxDrawdownAmount),
          "USD"
        );
        applyColorClass(elements.maxBalanceDrawdown, -1);
        elements.maxBalanceDrawdownPeriod.textContent = balanceDrawdownDuration;
        elements.monthlyBalanceDrawdown.textContent = formatCurrency(
          -overallMonthlyMaxDDA,
          "USD"
        );
        applyColorClass(elements.monthlyBalanceDrawdown, -1);
        elements.monthlyBalanceDrawdownPeriod.textContent = `Periode: ${formatDuration(
          monthlyDDDurationMs
        )}`;
        elements.monthlyMaxDrawdownPercentage.textContent = `-${formatNumber(
          overallMonthlyMaxDDP,
          2
        )}%`;
        applyColorClass(elements.monthlyMaxDrawdownPercentage, -1);
        elements.monthlyMaxDrawdownPercentagePeriod.textContent = `Periode: ${formatDuration(
          monthlyDDDurationMs
        )}`;
      }

      async function initializeAppFromLocalStorage() {
        console.log("Inisialisasi aplikasi dari localStorage...");

        // --- PERBAIKAN DIMULAI DI SINI ---
        // 1. Muat semua data dari localStorage ke dalam variabel global
        await loadDataFromLocalStorage(); // Memuat data trading
        loadPhotosFromLocalStorage(); // MEMUAT DATA FOTO (YANG HILANG)
        bannerPhotos = JSON.parse(localStorage.getItem("bannerPhotos")) || [];
        loadSimulatorData(); // Memuat data simulator
        const hasInputRows = loadInputRowsFromLocalStorage(); // Memuat baris input

        // Jika tidak ada baris input yang tersimpan, tambahkan satu baris default
        if (!hasInputRows) {
          addInputRow();
        }

        // 2. Render ulang semua komponen dari data yang sudah dimuat
        renderPhotoGallery(); // MERENDER GALERI FOTO (YANG HILANG)
        renderBannerGallery();
        renderCalculatedPlans();
        renderRunningPlans();
        renderExecutedPlans();

        // 3. Hitung ulang dan tampilkan semua statistik dan ringkasan
        calculateSummaryStatistics();
        updateRiskRewardStatistics();
        calculateAndRenderMonthlyPLSummary();
        calculateAndRenderDailySummary();
        calculateAndRenderWeeklySummary();
        calculateAndRenderNewMonthlySummary();
        calculateAndRenderYearlySummary();
        fetchAndRenderOutcomeRadarChart();
        fetchAndRenderCombinedCumulativeChart();

        // 4. Cek batas risiko dan tampilkan notifikasi jika perlu
        checkTradeLimits();
        displayLimitNotification(limitNotificationMessage);
        // --- AKHIR PERBAIKAN ---
      }

      const chartSections = {
        overallSummaryStatisticsSection: {
          render: calculateSummaryStatistics,
          chartInstance: () => null,
          setInstance: () => {},
          canvasId: null,
          loadingId: null,
          errorId: null,
          noDataId: null,
          hasRendered: false,
        },
        riskRewardStatisticsSection: {
          render: updateRiskRewardStatistics,
          chartInstance: () => null,
          setInstance: () => {},
          canvasId: null,
          loadingId: null,
          errorId: null,
          noDataId: null,
          hasRendered: false,
        },
        assetSuccessStatisticsSection: {
          render: fetchAndRenderPieChart,
          chartInstance: () => assetPieChart,
          setInstance: (chart) => (assetPieChart = chart),
          canvasId: "assetSuccessPieChart",
          loadingId: "pieChartLoading",
          errorId: "pieChartError",
          noDataId: "pieChartNoData",
          hasRendered: false,
        },
        dailyLineStatisticsSection: {
          render: fetchAndRenderDailyLineChart,
          chartInstance: () => dailyLineChart,
          setInstance: (chart) => (dailyLineChart = chart),
          canvasId: "dailyLineChart",
          loadingId: "dailyLineChartLoading",
          errorId: "dailyLineChartError",
          noDataId: "dailyLineChartNoData",
          hasRendered: false,
        },
        monthlyBarStatisticsSection: {
          render: fetchAndRenderMonthlyBarChart,
          chartInstance: () => monthlyBarChart,
          setInstance: (chart) => (monthlyBarChart = chart),
          canvasId: "monthlyBarChart",
          loadingId: "monthlyBarChartLoading",
          errorId: "monthlyBarChartError",
          noDataId: "monthlyBarChartNoData",
          hasRendered: false,
        },
        overallPercentageCumulativeStatisticsSection: {
          render: fetchAndRenderOverallPercentageCumulativeChart,
          chartInstance: () => overallPercentageCumulativeChart,
          setInstance: (chart) => (overallPercentageCumulativeChart = chart),
          canvasId: "overallPercentageCumulativeChart",
          loadingId: "overallPercentageCumulativeChartLoading",
          errorId: "overallPercentageCumulativeChartError",
          noDataId: "overallPercentageCumulativeChartNoData",
          hasRendered: false,
        },
        overallBalanceCumulativeStatisticsSection: {
          render: fetchAndRenderOverallBalanceCumulativeChart,
          chartInstance: () => overallBalanceCumulativeChart,
          setInstance: (chart) => (overallBalanceCumulativeChart = chart),
          canvasId: "overallBalanceCumulativeChart",
          loadingId: "overallBalanceCumulativeChartLoading",
          errorId: "overallBalanceCumulativeChartError",
          noDataId: "overallBalanceCumulativeChartNoData",
          hasRendered: false,
        },
        overallPipsCumulativeStatisticsSection: {
          render: fetchAndRenderOverallPipsCumulativeChart,
          chartInstance: () => overallPipsCumulativeChart,
          setInstance: (chart) => (overallPipsCumulativeChart = chart),
          canvasId: "overallPipsCumulativeChart",
          loadingId: "overallPipsCumulativeChartLoading",
          errorId: "overallPipsCumulativeChartError",
          noDataId: "overallPipsCumulativeChartNoData",
          hasRendered: false,
        },
        combinedSummaryBarStatisticsSection: {
          render: fetchAndRenderCombinedBarChart,
          chartInstance: () => combinedBarChart,
          setInstance: (chart) => (combinedBarChart = chart),
          canvasId: "combinedSummaryBarChart",
          loadingId: "combinedSummaryBarChartLoading",
          errorId: "combinedSummaryBarChartError",
          noDataId: "combinedSummaryBarChartNoData",
          hasRendered: false,
        },
        tradeFrequencyStatisticsSection: {
          render: fetchAndRenderTradeFrequencyChart,
          chartInstance: () => tradeFrequencyChart,
          setInstance: (chart) => (tradeFrequencyChart = chart),
          canvasId: "tradeFrequencyChart",
          loadingId: "tradeFrequencyChartLoading",
          errorId: "tradeFrequencyChartError",
          noDataId: "tradeFrequencyChartNoData",
          hasRendered: false,
        },
        balanceFrequencyStatisticsSection: {
          render: fetchAndRenderBalanceFrequencyChart,
          chartInstance: () => balanceFrequencyChart,
          setInstance: (chart) => (balanceFrequencyChart = chart),
          canvasId: "balanceFrequencyChart",
          loadingId: "balanceFrequencyChartLoading",
          errorId: "balanceFrequencyChartError",
          noDataId: "balanceFrequencyChartNoData",
          hasRendered: false,
        },
        percentageFrequencyStatisticsSection: {
          render: fetchAndRenderPercentageFrequencyChart,
          chartInstance: () => percentageFrequencyChart,
          setInstance: (chart) => (percentageFrequencyChart = chart),
          canvasId: "percentageFrequencyChart",
          loadingId: "percentageFrequencyChartLoading",
          errorId: "percentageFrequencyChartError",
          noDataId: "percentageFrequencyChartNoData",
          hasRendered: false,
        },
        pipsFrequencyStatisticsSection: {
          render: fetchAndRenderPipsFrequencyChart,
          chartInstance: () => pipsFrequencyChart,
          setInstance: (chart) => (pipsFrequencyChart = chart),
          canvasId: "pipsFrequencyChart",
          loadingId: "pipsFrequencyChartLoading",
          errorId: "pipsFrequencyChartError",
          noDataId: "pipsFrequencyChartNoData",
          hasRendered: false,
        },
        executionFrequencyStatisticsSection: {
          render: fetchAndRenderExecutionFrequencyChart,
          chartInstance: () => executionFrequencyChart,
          setInstance: (chart) => (executionFrequencyChart = chart),
          canvasId: "executionFrequencyChart",
          loadingId: "executionFrequencyChartLoading",
          errorId: "executionFrequencyChartError",
          noDataId: "executionFrequencyChartNoData",
          hasRendered: false,
        },
        assetExecutionCountStatisticsSection: {
          render: fetchAndRenderAssetExecutionCountChart,
          chartInstance: () => assetExecutionCountChart,
          setInstance: (chart) => (assetExecutionCountChart = chart),
          canvasId: "assetExecutionCountChart",
          loadingId: "assetExecutionCountChartLoading",
          errorId: "assetExecutionCountChartError",
          noDataId: "assetExecutionCountChartNoData",
          hasRendered: false,
        },
        outcomeStatisticsSection: {
          render: fetchAndRenderOutcomeRadarChart,
          chartInstance: () => outcomeRadarChart,
          setInstance: (chart) => (outcomeRadarChart = chart),
          canvasId: "outcomeRadarChart",
          loadingId: "outcomeRadarChartLoading",
          errorId: "outcomeRadarChartError",
          noDataId: "outcomeRadarChartNoData",
          hasRendered: false,
        },
        combinedCumulativeStatisticsSection: {
          render: fetchAndRenderCombinedCumulativeChart,
          chartInstance: () => combinedCumulativeChart,
          setInstance: (chart) => (combinedCumulativeChart = chart),
          canvasId: "combinedCumulativeChart",
          loadingId: "combinedCumulativeChartLoading",
          errorId: "combinedCumulativeChartError",
          noDataId: "combinedCumulativeChartNoData",
          hasRendered: false,
        },
      };

      // --- SCROLL ANIMATION LOGIC ---
      const animateOnScroll = () => {
        const sections = document.querySelectorAll(".scroll-animate-section");

        // Putuskan koneksi observer lama jika ada untuk menghindari duplikasi
        if (scrollObserver) {
          scrollObserver.disconnect();
        }

        scrollObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              const sectionId = entry.target.id;
              const chartInfo = chartSections[sectionId];
              if (entry.isIntersecting) {
                entry.target.classList.add("scrolled-into-view");
                if (chartInfo && !chartInfo.hasRendered && chartInfo.canvasId) {
                  chartInfo.render();
                  chartInfo.hasRendered = true;
                }
              } else {
                // Jangan hapus kelas jika tidak ingin animasi berulang saat scroll ke atas
                // entry.target.classList.remove('scrolled-into-view');
                if (
                  chartInfo &&
                  chartInfo.chartInstance &&
                  chartInfo.chartInstance()
                ) {
                  chartInfo.chartInstance().destroy();
                  chartInfo.setInstance(null);
                  chartInfo.hasRendered = false;
                }
              }
            });
          },
          { root: null, rootMargin: "0px", threshold: 0.1 }
        );
        sections.forEach((section) => scrollObserver.observe(section));
      };
      // --- LETAKKAN BLOK KODE BARU YANG SUDAH DIPERBAIKI DI SINI ---

      // --- GANTI SELURUH BLOK LOGIKA INTERAKSI BANNER DENGAN INI ---
      const bannerLabel = document.querySelector('label[for="imageInput16x4"]');
      const imageInput16x4 = document.getElementById("imageInput16x4");

      // Variabel untuk melacak status klik/tahan
      let pressStartTime = 0;
      const DELETE_PHOTO_THRESHOLD = 800; // Tahan > 800ms untuk dianggap 'tahan lama'

      if (bannerLabel && imageInput16x4) {
        const handlePressStart = (e) => {
          if (e.button && e.button !== 0) return; // Abaikan klik kanan
          pressStartTime = Date.now();
        };

        const handlePressEnd = async (e) => {
          if (pressStartTime === 0) return;
          const pressDuration = Date.now() - pressStartTime;
          pressStartTime = 0;

          // Hanya jalankan aksi HAPUS jika ini adalah 'tahan lama'
          if (pressDuration >= DELETE_PHOTO_THRESHOLD) {
            e.preventDefault(); // Mencegah pemicu input file setelah tahan lama

            if (bannerPhotos.length > 0) {
              const confirmed = await showMessageBox(
                "Hapus Foto Banner?",
                `Yakin ingin menghapus foto ${currentBannerPhotoIndex + 1}?`,
                true
              );
              if (confirmed) {
                deleteBannerPhoto(currentBannerPhotoIndex);
                if (
                  currentBannerPhotoIndex >= bannerPhotos.length &&
                  bannerPhotos.length > 0
                ) {
                  currentBannerPhotoIndex = bannerPhotos.length - 1;
                }
                renderBannerGallery();
              }
            }
          }
          // Klik singkat (kurang dari threshold) akan ditangani oleh <label> secara native.
        };

        // Pasang event listener ke <label>
        bannerLabel.addEventListener("mousedown", handlePressStart);
        bannerLabel.addEventListener("mouseup", handlePressEnd);
        bannerLabel.addEventListener("mouseleave", () => {
          pressStartTime = 0;
        });
        bannerLabel.addEventListener("touchstart", handlePressStart, {
          passive: true,
        });
        bannerLabel.addEventListener("touchend", handlePressEnd);

        // Pasang event listener ke input file banner itu sendiri
        imageInput16x4.addEventListener("change", (event) =>
          handleImageUpload(event, "16:4")
        );
      }
      // --- AKHIR BLOK PENGGANTIAN ---
      // --- AKHIR BLOK PENGGANTIAN ---
      // --- AKHIR BLOK PENGGANTIAN ---

      // --- EVENT LISTENERS (REVISED & CONSOLIDATED) ---
      document.addEventListener("DOMContentLoaded", async () => {
        console.log("DOM Content Loaded. Initializing app...");
        updateDateTime();
        setInterval(updateDateTime, 1000);

        // Initialize Firebase or fallback to localStorage
        if (
          Object.keys(firebaseConfig).length > 0 &&
          typeof __firebase_config !== "undefined" &&
          __firebase_config !== "{}"
        ) {
          console.log("Firebase config found, initializing...");
          app = initializeApp(firebaseConfig);
          db = getFirestore(app);
          auth = getAuth(app);
          storage = getStorage(app);

          onAuthStateChanged(auth, async (user) => {
            if (user) {
              userId = user.uid;
              console.log("Authenticated with Firebase UID:", userId);
              await loadProfilePictures(userId);
              await loadCalculatedPlans(userId);
              await loadRunningPlans(userId);
              await loadExecutedPlans(userId);
              loadBannerPhotos(); // Tidak perlu 'await' dan 'userId'
            } else {
              try {
                const initialAuthToken =
                  typeof __initial_auth_token !== "undefined"
                    ? __initial_auth_token
                    : null;
                if (initialAuthToken) {
                  await signInWithCustomToken(auth, initialAuthToken);
                } else {
                  await signInAnonymously(auth);
                }
              } catch (error) {
                console.error(
                  "Firebase authentication failed, falling back to localStorage.",
                  error
                );
                await initializeAppFromLocalStorage();
              }
            }
          });
        } else {
          console.log("No Firebase config. Using localStorage.");
          await initializeAppFromLocalStorage();
        }

        // Attach all button event listeners here to ensure functions are in scope
        const addInputRowBtn = document.getElementById("addInputRowBtn");
        if (addInputRowBtn) {
          addInputRowBtn.addEventListener("click", () => {
            if (checkTradeLimits()) {
              addInputRow();
              saveInputRowsToLocalStorage();
              displayLimitNotification("");
            } else {
              displayLimitNotification(limitNotificationMessage);
            }
          });
        }

        // PDF Download Listener
        const downloadPdfBtn = document.getElementById("downloadAllPdfBtn");
        if (downloadPdfBtn) {
          downloadPdfBtn.addEventListener("click", () => {
            downloadAllDataAsPdf(
              `Laporan_Trading_Lengkap_${new Date()
                .toISOString()
                .slice(0, 10)}.pdf`
            );
          });
        }

        // Other event listeners
        animateOnScroll();
        startBannerAutoslide();
        console.log("Application initialization complete.");
      });
      window.exportToPdf = exportToPdf;
    </script>

    <script>
      const token = localStorage.getItem("token");
      if (!token) {
        window.location.href = "/LeodraHtml/contact.html";
      } else {
        fetch("http://101.50.2.92:4578/api/auth/me", {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        })
          .then((res) => {
            if (!res.ok) {
              // token invalid atau expired
              localStorage.removeItem("token");
              window.location.href = "login.html";
            }
            return res.json();
          })
          .then((user) => {})
          .catch(() => {
            localStorage.removeItem("token");
            window.location.href = "LeodraHtml/contact.html";
          });
      }
    </script>
  </body>
</html>
